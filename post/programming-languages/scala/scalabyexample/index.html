<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Scala By Example - Ye Zheng&#39;s Blog</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="Ye Zheng" />
  <meta name="description" content="Introduction Scala smoothly integrates object-oriented and functional programming.
 Abstract types and mixin composition unify concepts from object and module systems. Pattern matching over class hierarchies uniﬁes functional and object-oriented data access. It greatly simpliﬁes the processing of XML trees. A ﬂexible syntax and type system enables the construction of advanced libraries and new domain speciﬁc languages.  Starting with simple expressions and functions, and working up through objects and classes, lists and streams, mutable state, pattern matching to more complete examples that show interesting programming techniques." />

  <meta name="keywords" content="technique, programming, computer science" />






<meta name="generator" content="Hugo 0.72.0" />


<link rel="canonical" href="http://csyezheng.github.io/post/programming-languages/scala/scalabyexample/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.0493617b29ca314c4891213673bd17850fd873c91d68aa156d61f090a97c5ca6.css" integrity="sha256-BJNheynKMUxIkSE2c70XhQ/Yc8kdaKoVbWHwkKl8XKY=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="Scala By Example" />
<meta property="og:description" content="Introduction Scala smoothly integrates object-oriented and functional programming.
 Abstract types and mixin composition unify concepts from object and module systems. Pattern matching over class hierarchies uniﬁes functional and object-oriented data access. It greatly simpliﬁes the processing of XML trees. A ﬂexible syntax and type system enables the construction of advanced libraries and new domain speciﬁc languages.  Starting with simple expressions and functions, and working up through objects and classes, lists and streams, mutable state, pattern matching to more complete examples that show interesting programming techniques." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://csyezheng.github.io/post/programming-languages/scala/scalabyexample/" />
<meta property="article:published_time" content="2019-03-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-03-01T00:00:00+00:00" />
<meta itemprop="name" content="Scala By Example">
<meta itemprop="description" content="Introduction Scala smoothly integrates object-oriented and functional programming.
 Abstract types and mixin composition unify concepts from object and module systems. Pattern matching over class hierarchies uniﬁes functional and object-oriented data access. It greatly simpliﬁes the processing of XML trees. A ﬂexible syntax and type system enables the construction of advanced libraries and new domain speciﬁc languages.  Starting with simple expressions and functions, and working up through objects and classes, lists and streams, mutable state, pattern matching to more complete examples that show interesting programming techniques.">
<meta itemprop="datePublished" content="2019-03-01T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2019-03-01T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="33542">



<meta itemprop="keywords" content="Scala," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Scala By Example"/>
<meta name="twitter:description" content="Introduction Scala smoothly integrates object-oriented and functional programming.
 Abstract types and mixin composition unify concepts from object and module systems. Pattern matching over class hierarchies uniﬁes functional and object-oriented data access. It greatly simpliﬁes the processing of XML trees. A ﬂexible syntax and type system enables the construction of advanced libraries and new domain speciﬁc languages.  Starting with simple expressions and functions, and working up through objects and classes, lists and streams, mutable state, pattern matching to more complete examples that show interesting programming techniques."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Ye Zheng's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/about/">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      Ye Zheng's Blog
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/about/">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">Scala By Example</h1>
      
      <div class="post-meta">
        <time datetime="2019-03-01" class="post-time">
          2019-03-01
        </time>
        <div class="post-category">
            <a href="http://csyezheng.github.io/categories/programming-languages/"> programming-languages </a>
            <a href="http://csyezheng.github.io/categories/scala/"> Scala </a>
            
          </div>
        

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#a-first-example">A First Example</a></li>
    <li><a href="#programming-with-actors-and-messages">Programming with Actors and Messages</a></li>
    <li><a href="#expressions-and-simple-functions">Expressions and Simple Functions</a>
      <ul>
        <li><a href="#41-expressions-and-simple-functions">4.1 Expressions And Simple Functions</a></li>
        <li><a href="#42-parameters">4.2 Parameters</a></li>
        <li><a href="#43-conditional-expressions">4.3 Conditional Expressions</a></li>
        <li><a href="#44-example-square-roots-by-newtons-method">4.4 Example: Square Roots by Newton’s Method</a></li>
        <li><a href="#45-nested-functions">4.5 Nested Functions</a></li>
        <li><a href="#46-tail-recursion">4.6 Tail Recursion</a></li>
      </ul>
    </li>
    <li><a href="#first-class-functions">First-Class Functions</a>
      <ul>
        <li><a href="#51-anonymous-functions">5.1 Anonymous Functions</a></li>
        <li><a href="#52-currying">5.2 Currying</a></li>
        <li><a href="#53-example-finding-fixed-points-of-functions">5.3 Example: Finding Fixed Points of Functions</a></li>
        <li><a href="#54-summary">5.4 Summary</a></li>
        <li><a href="#55-language-elements-seen-so-far">5.5 Language Elements Seen So Far</a></li>
      </ul>
    </li>
    <li><a href="#classes-and-objects">Classes and Objects</a></li>
    <li><a href="#case-classes-and-pattern-matching">Case Classes and Pattern Matching</a>
      <ul>
        <li><a href="#71-case-classes-and-case-objects">7.1 Case Classes and Case Objects</a></li>
        <li><a href="#72-pattern-matching">7.2 Pattern Matching</a></li>
      </ul>
    </li>
    <li><a href="#generic-types-and-methods">Generic Types and Methods</a>
      <ul>
        <li><a href="#81-type-parameter-bounds">8.1 Type Parameter Bounds</a></li>
        <li><a href="#82-variance-annotations">8.2 Variance Annotations</a></li>
        <li><a href="#83-lower-bounds">8.3 Lower Bounds</a></li>
        <li><a href="#84-least-types">8.4 Least Types</a></li>
        <li><a href="#85-tuples">8.5 Tuples</a></li>
        <li><a href="#86-functions">8.6 Functions</a></li>
      </ul>
    </li>
    <li><a href="#lists">Lists</a>
      <ul>
        <li><a href="#91-using-lists">9.1 Using Lists</a></li>
        <li><a href="#92-deﬁnition-of-class-list-i-first-order-methods">9.2 Deﬁnition of class List I: First Order Methods</a></li>
        <li><a href="#93-example-merge-sort">9.3 Example: Merge sort</a></li>
        <li><a href="#94-deﬁnition-of-class-list-ii-higher-order-methods">9.4 Deﬁnition of class List II: Higher-Order Methods</a></li>
        <li><a href="#95-summary">9.5 Summary</a></li>
      </ul>
    </li>
    <li><a href="#for-comprehensions">For-Comprehensions</a>
      <ul>
        <li><a href="#101-the-n-queens-problem">10.1 The N-Queens Problem</a></li>
        <li><a href="#102-querying-with-for-comprehensions">10.2 Querying with For-Comprehensions</a></li>
        <li><a href="#103-translation-of-for-comprehensions">10.3 Translation of For-Comprehensions</a></li>
        <li><a href="#104-for-loops">10.4 For-Loops</a></li>
        <li><a href="#105-generalizing-for">10.5 Generalizing For</a></li>
      </ul>
    </li>
    <li><a href="#mutable-state">Mutable State</a>
      <ul>
        <li><a href="#111-stateful-objects">11.1 Stateful Objects</a></li>
        <li><a href="#112-imperative-control-structures">11.2 Imperative Control Structures</a></li>
        <li><a href="#113-extended-example-discrete-event-simulation">11.3 Extended Example: Discrete Event Simulation</a></li>
        <li><a href="#114-summary">11.4 Summary</a></li>
      </ul>
    </li>
    <li><a href="#computing-with-streams">Computing with Streams</a></li>
    <li><a href="#iterators">Iterators</a>
      <ul>
        <li><a href="#131-iterator-methods">13.1 Iterator Methods</a></li>
        <li><a href="#132-constructing-iterators">13.2 Constructing Iterators</a></li>
        <li><a href="#133-using-iterators">13.3 Using Iterators</a></li>
      </ul>
    </li>
    <li><a href="#lazy-values">Lazy Values</a></li>
    <li><a href="#implicit-parameters-and-conversions">Implicit Parameters and Conversions</a></li>
    <li><a href="#hindleymilner-type-inference">Hindley/Milner Type Inference</a></li>
    <li><a href="#abstractions-for-concurrency">Abstractions for Concurrency</a>
      <ul>
        <li><a href="#171-signals-and-monitors">17.1 Signals and Monitors</a></li>
        <li><a href="#172-syncvars">17.2 SyncVars</a></li>
        <li><a href="#173-futures">17.3 Futures</a></li>
        <li><a href="#174-parallel-computations">17.4 Parallel Computations</a></li>
        <li><a href="#175-semaphores">17.5 Semaphores</a></li>
        <li><a href="#176-readerswriters">17.6 Readers/Writers</a></li>
        <li><a href="#177-asynchronous-channels">17.7 Asynchronous Channels</a></li>
        <li><a href="#178-synchronous-channels">17.8 Synchronous Channels</a></li>
        <li><a href="#179-workers">17.9 Workers</a></li>
        <li><a href="#1711-actors">17.11 Actors</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h2 id="introduction">Introduction</h2>
<p>Scala smoothly integrates object-oriented and functional programming.</p>
<ul>
<li>Abstract types and mixin composition unify concepts from object and module systems.</li>
<li>Pattern matching over class hierarchies uniﬁes functional and object-oriented data access. It greatly simpliﬁes the processing of XML trees.</li>
<li>A ﬂexible syntax and type system enables the construction of advanced libraries and new domain speciﬁc languages.</li>
</ul>
<p>Starting with simple expressions and functions, and working up through objects and classes, lists and streams, mutable state, pattern matching to more complete examples that show interesting programming techniques.</p>
<h2 id="a-first-example">A First Example</h2>
<p><code>Quicksort</code> in Scala.</p>
<pre><code>def sort(xs: Array[Int]) {
    def swap(i: Int, j: Int) {
        val t = xs(i); xs(i) = xs(j); xs(j) = t
    }
    def sort1(l: Int, r: Int) {
        val pivot = xs((l + r) / 2)
        var i = l; var j = r
        while (i &lt;= j) {
            while (xs(i) &lt; pivot) i += 1
            while (xs(j) &gt; pivot) j -= 1
            if (i &lt;= j) {
                swap(i, j)
                i += 1
                j -= 1
            }
        }
        if (l &lt; j) sort1(l, j)
        if (j &lt; r) sort1(i, r)
    }
    sort1(0, xs.length - 1)
}
</code></pre><ul>
<li>Deﬁnitions start with a reserved word. Function deﬁnitions start with <strong>def</strong>, variable deﬁnitions start with <strong>var</strong> and deﬁnitions of values (i.e. read only variables) start with <strong>val</strong>.</li>
<li>he declared type of a symbol is given after the symbol and a colon. The declared type can often be omitted, because the compiler can infer it from thecontext.</li>
<li>Array types are written <strong>Array[T]</strong> rather than T[], and array selections are writ-ten <strong>a(i)</strong> rather than a[i].</li>
<li>Functions can be nested inside other functions. Nested functions can access parameters and local variables of enclosing functions.</li>
</ul>
<p>In fact it is possible to write programs in a conventional imperative or object-oriented style. <strong>This is important</strong> because it is one of the things that makes it easy to combine Scala components with components written in mainstream languages such as Java, C# or Visual Basic.</p>
<p>However, it is also possible to write programs in a style which looks completely different. Here is <code>Quicksort</code> again, this time written in functional style.</p>
<pre><code>def sort(xs: Array[Int]): Array[Int] = {
    if (xs.length &lt;= 1) xs
    else {
        val pivot = xs(xs.length / 2)
        Array.concat(
            sort(xs filter (pivot &gt;)),
                 xs filter (pivot ==),
            sort(xs filter (pivot &lt;)))
    }
}
</code></pre><p>Both the imperative and the functional implementation have the same asymptotic complexity – <code>O(Nlog(N))</code> in the average case and <code>O(N2)</code> in the worst case. But where the imperative implementation operates in place by modifying the argument array, the functional implementation returns a new sorted array and leaves the argument array unchanged. The functional implementation thus requires more transient memory than the imperative one.</p>
<p>All of the operations used in the example are simple library methods of a sequence class <strong>Seq[T]</strong> which is part of the standard Scala library, and which itself is implemented in Scala. Because arrays are instances of Seq all sequence methods are available for them.</p>
<p>In particular, there is the method <strong>filter</strong> which takes as argument a <strong>predicate function</strong>. This predicate function must map array elements to boolean values. The result of filter is an array consisting of all the elements of the original array for which the given predicate function is true. The filter method of an object of type Array[T] thus has the signature.</p>
<pre><code>def filter(p: T =&gt; Boolean): Array[T]
</code></pre><p>Here, <strong>T =&gt; Boolean</strong> is the type of functions that take an element of type t and return a Boolean. Functions like filter that take another function as argument or return one as result are called <strong>higher-order</strong> functions.</p>
<p>Scala does not distinguish between identiﬁers and operator names. An identiﬁer can be either a sequence of letters and digits which begins with a letter, or it can be a sequence of special characters, such as “+”, “*”, or “:”. Any identiﬁer can be used as an inﬁx operator in Scala. The binary operation <strong><code>E op E</code></strong> is always interpreted as the method call <strong><code>E.op(E)</code></strong>. This holds also for binary inﬁx operators which start with a letter. Hence, the expression <code>xs filter (pivot &gt;)</code> is equivalent to the method call <code>xs.filter(pivot &gt;)</code>.</p>
<p>In the <code>quicksort</code> program, filter is applied three times to an <strong>anonymous</strong> <strong>function</strong> argument. The ﬁrst argument, <strong><code>pivot &gt;</code></strong>, represents a function that takes an argument x and returns the value pivot &gt; x. This is an example of a <strong>partially applied function</strong>. Another, equivalent way to write this function which makes the missing argument explicit is <strong><code>x =&gt; pivot &gt; x</code></strong>. The function is <strong>anonymous</strong>, i.e. it is not deﬁned with a name. The type of the x parameter is omitted because a Scala compiler can infer it automatically from the context where the function is used.</p>
<p>For instance, “standard” binary operators such as +, -, or &lt; are not treated in any special way. Like append, they are methods of their left operand. Consequently, the expression <code>i + 1</code> is regarded as the invocation <code>i.+(1)</code> of the + method of the integer value x. Of course, a compiler is free (if it is moderately smart, even expected) to recognize the special case of calling the + method over integer arguments and to generate efﬁcient inline code for it.</p>
<p>For efﬁciency and better error diagnostics the <strong>while</strong> loop is a primitive construct in Scala. But in principle, it could have just as well been a predeﬁned function. Here is a possible implementation of it:</p>
<pre><code>def While (p: =&gt; Boolean) (s: =&gt; Unit) {
    if (p) { s ; While(p)(s) }
}
</code></pre><p>The While function takes as ﬁrst parameter a test function, which takes no parameters and yields a boolean value. As second parameter it takes a command function which also takes no parameters and yields a result of type <strong>Unit</strong>. While invokes the command function as long as the test function yields true.</p>
<p>Scala’s <strong>Unit</strong> type roughly corresponds to void in Java; it is used whenever a function does not return an interesting result. In fact, because Scala is an <strong>expression-oriented</strong> language, every function returns some result. If no explicit return expression is given, the value (), which is pronounced “unit”, is assumed. This value is of type Unit. Unit-returning functions are also called <strong>procedures</strong>. Here’s a more“expression-oriented” formulation of the swap function in the ﬁrst implementation of <code>quicksort</code>, which makes this explicit:</p>
<pre><code>def swap(i: Int, j: Int) {
    val t = xs(i); xs(i) = xs(j); xs(j) = t
    ()
}
</code></pre><p>The result value of this function is simply its last expression – a <strong>return</strong> keyword is not necessary. Note that <strong>functions returning an explicit value always need an “=” before their body</strong> or deﬁning expression.</p>
<h2 id="programming-with-actors-and-messages">Programming with Actors and Messages</h2>
<p>Here’s an example that shows an application area for which Scala is particularly well suited. Consider the task of implementing an electronic auction service. We use an Erlang-style actor process model to implement the participants of the auction. <strong>Actors</strong> are objects to which messages are sent. Every actor has a “mailbox” of its incoming messages <strong>which is represented as a queue.</strong> It can work sequentially through the messages in its mailbox, or search for messages matching some pattern.
For every traded item there is an auctioneer actor that publishes information about the traded item, that accepts offers from clients and that communicates with the seller and winning bidder to close the transaction. We present an overview of a simple implementation here.
As a ﬁrst step, we deﬁne the messages that are exchanged during an auction. There are two abstract base classes <code>AuctionMessage</code> for messages from clients to the auction service, and <code>AuctionReply</code> for replies from the service to the clients. For both base classes there exists a number of cases.
For each base class, there are a number of <strong>case classes</strong> which deﬁne the format of particular messages in the class. These messages might well be ultimately mapped to small XML documents. We expect automatic tools to exist that convert between XML documents and internal data structures like the ones deﬁned above. class <code>Auction</code> for auction actors that coordinate the bidding on one item. Objects of this class are created by indicating</p>
<ul>
<li>a seller actor which needs to be notiﬁed when the auction is over,</li>
<li>a minimal bid,</li>
<li>the date when the auction is to be closed.</li>
</ul>
<p>The behavior of the actor is deﬁned by its act method. That method repeatedly</p>
<pre><code># Message Classes for an Auction Service

import scala.actors.Actor

abstract class AuctionMessage
case class Offer(bid: Int, client: Actor) extends AuctionMessage
case class Inquire(client: Actor)         extends AuctionMessage

abstract class AuctionReply
case class Status(asked: Int, expire: Date) extends AuctionReply
case object BestOffer                       extends AuctionReply
case class BeatenOffer(maxBid: Int)         extends AuctionReply
case class AuctionConcluded(seller: Actor, client: Actor)
                                            extends AuctionReply
case object AuctionFailed                   extends AuctionReply
case object AuctionOver                     extends AuctionReply
</code></pre><p>selects (using <code>receiveWithin</code>) a message and reacts to it, until the auction is closed,which is signaled by a <code>TIMEOUT</code> message. Before ﬁnally stopping, it stays active for another period determined by the <code>timeToShutdown</code> constant and replies to further offers that the auction is closed.</p>
<p>Here are some further explanations of the constructs used in this program:</p>
<ul>
<li>The <code>receiveWithin</code> method of class <strong>Actor</strong> takes as parameters a time span given in milliseconds and a function that processes messages in the mailbox. The function is given by a sequence of cases that each specify a pattern and an action to perform for messages matching the pattern. The <code>receiveWithin</code> method selects the ﬁrst message in the mailbox which matches one of these patterns and applies the corresponding action to it.</li>
<li>The last case of <code>receiveWithin</code> is guarded by a <code>TIMEOUT</code> pattern. If no other messages are received in the meantime, this pattern is triggered after the timespan which is passed as argument to the enclosing <code>receiveWithin</code> method. <code>TIMEOUT</code> is a special message, which is triggered by the Actor implementation itself.</li>
<li>Reply messages are sent using syntax of the form <code>destination ! SomeMessage</code>. ! is used here as a binary operator with an actor and a message as arguments. This is equivalent in Scala to the method call <code>destination.!(SomeMessage)</code>, i.e. the invocation of the <code>!</code> method of the destination actor with the given message as parameter.</li>
</ul>
<p>The preceding discussion gave a ﬂavor of distributed programming in Scala. It might seem that Scala has a rich set of language constructs that support actor processes, message sending and receiving, programming with timeouts, etc. In fact, the</p>
<pre><code>// Implementation of an Auction Service

class Auction(seller: Actor, minBid: Int, closing: Date) extends Actor {
    val timeToShutdown = 36000000 //msec
    val bidIncrement = 10
    def act() {
        var maxBid = minBid - bidIncrement
        var maxBidder: Actor = null
        var running = true
        while (running) {
            receiveWithin ((closing.getTime() - new Date().getTime())) {
            case Offer(bid, client) =&gt;
                if (bid &gt;= maxBid + bidIncrement) {
                    if (maxBid &gt;= minBid) maxBidder ! BeatenOffer(bid)
                    maxBid = bid; maxBidder = client; client ! BestOffer
                } else {
                    client ! BeatenOffer(maxBid)
                }
            case Inquire(client) =&gt;
                client ! Status(maxBid, closing)
            case TIMEOUT =&gt;
                if (maxBid &gt;= minBid) {
                    val reply = AuctionConcluded(seller, maxBidder)
                    maxBidder ! reply; seller ! reply
                } else {
                    seller ! AuctionFailed
                }
                receiveWithin(timeToShutdown) {
                    case Offer(_, client) =&gt; client ! AuctionOver
                    case TIMEOUT =&gt; running = false
                }
            }
        }
    }
}
</code></pre><p>opposite is true. All the constructs discussed above are offered as methods in the library class Actor. That class is itself implemented in Scala, based on the underlying thread model of the host language (e.g. Java, or .NET). The implementation of all features of class Actor used here is given in Section 17.11.</p>
<p>The advantages of the <strong>library-based approach</strong> are relative simplicity of the core language and ﬂexibility for library designers. Because the core language need not specify details of high-level process communication, it can be kept simpler and more general. Because the particular model of messages in a mailbox is a library module,it can be freely modiﬁed if a different model is needed in some applications. The approach requires however that the core language is expressive enough to provide the necessary language abstractions in a convenient way. Scala has been designed with this in mind; one of its major design goals was that it should be ﬂexible enough to <strong>act as a convenient host language for domain speciﬁc languages implemented by library modules.</strong> For instance, the actor communication constructs presented above can be regarded as one such domain speciﬁc language, which conceptually extends the Scala core.</p>
<h2 id="expressions-and-simple-functions">Expressions and Simple Functions</h2>
<h3 id="41-expressions-and-simple-functions">4.1 Expressions And Simple Functions</h3>
<p>A Scala system comes with an <strong>interpreter</strong>. For example:</p>
<pre><code>scala&gt; &quot;hello&quot; + &quot; world!&quot;
unnamed2: java.lang.String = hello world!

scala&gt; def scale = 5
scale: Int

scala&gt; 7 * scale
unnamed3: Int = 35

scala&gt; def pi = 3.141592653589793
pi: Double

scala&gt; def radius = 10
radius: Int

scala&gt; 2 * pi * radius
unnamed4: Double = 62.83185307179586
</code></pre><p>Deﬁnitions start with the reserved word <strong>def</strong>; they introduce a name which stands for the expression following the <strong>=</strong> sign. The interpreter will answer with the introduced name and its type.</p>
<p>Executing a deﬁnition such as <code>def x = e</code> will <strong>not evaluate</strong> the expression e. Instead e is evaluated whenever x is used. Alternatively, Scala offers a value deﬁnition <code>val x = e</code>, which <strong>does evaluate</strong> the right-hand-side e as part of the evaluation of the deﬁnition.</p>
<p>How are expressions evaluated? An expression consisting of operators and operands is evaluated by repeatedly applying the following simpliﬁcation steps.</p>
<ul>
<li>pick the left-most operation</li>
<li>evaluate its operands</li>
<li>apply the operator to the operand values.</li>
</ul>
<p>A name deﬁned by <strong>def</strong> is evaluated by replacing the name by the (<strong>unevaluated</strong>) deﬁnition’s right hand side. A name deﬁned by <strong>val</strong> is evaluated by replacing the name by the <strong>value</strong> of the deﬁnitions’s right-hand side. The evaluation process stops once we have reached a value. A value is some data item such as a string, a number,an array, or a list. The process of stepwise simpliﬁcation of expressions to values is called <strong>reduction</strong>.</p>
<h3 id="42-parameters">4.2 Parameters</h3>
<p>Using def, one can also deﬁne functions with parameters. For example:</p>
<pre><code>scala&gt; def square(x: Double) = x * x
square: (Double)Double

scala&gt; square(2)
unnamed0: Double = 4.0

scala&gt; square(5 + 3)
unnamed1: Double = 64.0

scala&gt; square(square(4))
unnamed2: Double = 256.0

scala&gt; def sumOfSquares(x: Double, y: Double) = square(x) + square(y)
sumOfSquares: (Double,Double)Double

scala&gt; sumOfSquares(3, 2 + 2)
unnamed3: Double = 25.0
</code></pre><p>Every parameter comes with a type, which is indicated following the parameter name and a colon. At the present time, we only need basic numeric types such as the type <code>scala.Double</code> of double precision numbers. Scala deﬁnes <strong>type aliases</strong> for some standard types, so we can write numeric types as in Java. For instance double is a type alias of scala.Double and int is a type alias for scala.Int.
Functions with parameters are evaluated analogously to operators in expressions. First, the arguments of the function are evaluated (in left-to-right order). Then, the function application is replaced by the function’s right hand side, and at the same time all formal parameters of the function are replaced by their corresponding actual arguments.</p>
<pre><code>Example 4.2.1

  sumOfSquares(3, 2+2)
→ sumOfSquares(3, 4)
→ square(3) + square(4)
→ 3 * 3 + square(4)
→ 9 + square(4)
→ 9 + 4 * 4
→ 9 + 16
→ 25
</code></pre><p>The example shows that the interpreter reduces function arguments to values before rewriting the function application. One could instead have chosen to apply the function to unreduced arguments. This would have yielded the following reduction</p>
<pre><code>  sumOfSquares(3, 2+2)
→ square(3) + square(2+2)
→ 3 * 3 + square(2+2)
→ 9 + square(2+2)
→ 9 + (2+2) * (2+2)
→ 9 + 4 * (2+2)
→ 9 + 4 * 4
→ 9 + 16
→ 25
</code></pre><p>The second evaluation order is known as <strong>call-by-name</strong>, whereas the ﬁrst one is known as <strong>call-by-value</strong>. For expressions that use only pure functions and that therefore can be reduced with the substitution model, both schemes yield the same ﬁnal values.</p>
<p><strong>Call-by-value</strong> has the advantage that it avoids repeated evaluation of arguments. Call-by-name has the advantage that it avoids evaluation of arguments when the parameter is not used at all by the function. Call-by-value is usually more efﬁcient than call-by-name, but a call-by-value evaluation might loop where a call-by-name evaluation would terminate. Consider:</p>
<pre><code>scala&gt; def loop: Int = loop
loop: Int

scala&gt; def first(x: Int, y: Int) = x
first: (Int,Int)Int
</code></pre><p>Then first(1, loop) reduces with call-by-name to 1, whereas the same term reduces with call-by-value repeatedly to itself, hence evaluation does not terminate.first(1, loop)</p>
<pre><code>→ first(1, loop)
→ first(1, loop)
→ ...
</code></pre><p><strong>Scala uses call-by-value by default, but it switches to call-by-name evaluation if the parameter type is preceded by =&gt;.</strong></p>
<pre><code>Example 4.2.2

scala&gt; def constOne(x: Int, y: =&gt; Int) = 1
constOne: (Int,=&gt; Int)Int

scala&gt; constOne(1, loop)
unnamed0: Int = 1

scala&gt; constOne(loop, 2)    // gives an infinite loop.
^C                        // stops execution with Ctrl-C
</code></pre><h3 id="43-conditional-expressions">4.3 Conditional Expressions</h3>
<pre><code>/* Example 4.3.1 */
scala&gt; def abs(x: Double) = if (x &gt;= 0) x else -x
abs: (Double)Double
</code></pre><p>Scala’s boolean expressions are similar to Java’s; they are formed from the constants <strong>true</strong> and <strong>false</strong>, comparison operators, boolean negation <strong><code>!</code></strong> and the boolean operators <strong><code>&amp;&amp;</code></strong> and <strong><code>||</code></strong>.</p>
<h3 id="44-example-square-roots-by-newtons-method">4.4 Example: Square Roots by Newton’s Method</h3>
<p>The task is to write a function</p>
<p>def sqrt(x: Double): Double = &hellip;</p>
<p>which computes the square root of x. A common way to compute square roots is by <strong>Newton’s method</strong> of successive approximations. One starts with an initial guess y (say: y = 1). One then repeatedly improves the current guess y by taking the average of y and x/y. As an example, the next three columns indicate the <strong>guess</strong> y, the <strong>quotient</strong> x/y, and their <strong>average</strong> for the ﬁrst approximations of  sqrt(2)</p>
<pre><code>1                         2/1 = 2                            1.5
1.5                       2/1.5 = 1.3333                     1.4167
1.4167                    2/1.4167 = 1.4118                  1.4142
1.4142                    ...                                ...

y                         x/y                                (y + x/y)/2
</code></pre><p>We ﬁrst deﬁne a function for iterating from a guess to the result:</p>
<pre><code>def sqrtIter(guess: Double, x: Double): Double =
    if (isGoodEnough(guess, x)) guess
    else sqrtIter(improve(guess, x), x)
</code></pre><p>Note that <code>sqrtIter</code> calls itself recursively. Loops in imperative programs can always be modeled by recursion in functional programs.</p>
<p><strong>The return types are mandatory for recursive functions.</strong> For anon-recursive function, the return type is optional; if it is missing the type checker will compute it from the type of the function’s right-hand side. However, even for non-recursive functions <strong>it is often a good idea to include a return type</strong> for better documentation.</p>
<p>As a second step, we deﬁne the two functions called by <code>sqrtIter</code>: a function to improve the guess and a termination test <code>isGoodEnough</code>. Here is their deﬁnition.</p>
<pre><code>def improve(guess: Double, x: Double) =
    (guess + x / guess) / 2

def isGoodEnough(guess: Double, x: Double) =
    abs(square(guess) - x) &lt;= math.ulp(x)
</code></pre><p>Finally, the <code>sqrt</code> function itself is deﬁned by an application of <code>sqrtIter</code>.</p>
<pre><code>def sqrt(x: Double) = sqrtIter(1.0, x)
</code></pre><h3 id="45-nested-functions">4.5 Nested Functions</h3>
<p><strong>The functional programming style encourages the construction of many small helper functions.</strong> In the last example, the implementation of sqrt made use of the helper functions <code>sqrtIter</code>, <code>improve</code> and <code>isGoodEnough</code>. The names of these functions are relevant only for the implementation of sqrt. We normally do not want users of sqrt to access these functions directly.</p>
<p>We can enforce this (and <strong>avoid name-space pollution</strong>) by including the helper functions within the calling function itself:</p>
<pre><code>def sqrt(x: Double) = {
	def sqrtIter(guess: Double, x: Double): Double =
		if (isGoodEnough(guess, x)) guess
		else sqrtIter(improve(guess, x), x)
	def improve(guess: Double, x: Double) =
		(guess + x / guess) / 2
	def isGoodEnough(guess: Double, x: Double) =
		abs(square(guess) - x) &lt;= math.ulp(x)
	sqrtIter(1.0, x)
}
</code></pre><p>In this program, the braces { &hellip; } enclose a block. Blocks in Scala are themselves expressions. Every block ends in a result expression which deﬁnes its value. The result expression may be preceded by auxiliary deﬁnitions, which are visible only in the block itself. <strong>Every deﬁnition in a block must be followed by a semicolon</strong>, which separates this deﬁnition from subsequent deﬁnitions or the result expression. However, <strong>a semicolon is inserted implicitly at the end of each line, unless</strong> one of the following conditions is true.</p>
<ol>
<li>
<p>Either the line in question ends in a word such as a period or an inﬁx-operator which would not be legal as the end of an expression.</p>
</li>
<li>
<p>Or the next line begins with a word that cannot start a expression.</p>
</li>
<li>
<p>Or we are inside parentheses (&hellip;) or brackets , because these cannot contain multiple statements anyway.</p>
</li>
</ol>
<p>Therefore, the following are all legal:</p>
<pre><code>def f(x: Int) = x + 1;
f(1) + f(2)

def g1(x: Int) = x + 1
g(1) + g(2)

def g2(x: Int) = {x + 1}; /* ‘;’ mandatory */ g2(1) + g2(2)

def h1(x) =
	x +
	y
h1(1) * h1(2)

def h2(x: Int) = (
	x           // parentheses mandatory, otherwise a semicolon
	- y         // would be inserted after the ‘x’
)
h2(1) / h2(2)
</code></pre><p>Scala uses <strong>the usual block-structured scoping rules. A name deﬁned in some outer block is visible also in some inner block,</strong> provided it is not redeﬁned there. This rule permits us to simplify our sqrt example. We need not pass x around as an additional parameter of the nested functions, since it is always visible in them as a parameter of the outer function sqrt. Here is the simpliﬁed code:</p>
<pre><code>def sqrt(x: Double) = {
	def sqrtIter(guess: Double): Double =
		if (isGoodEnough(guess)) guess
		else sqrtIter(improve(guess))
	def improve(guess: Double) =
		(guess + x / guess) / 2
	def isGoodEnough(guess: Double) =
		abs(square(guess) - x) &lt; 0.001
	sqrtIter(1.0)
}
</code></pre><h3 id="46-tail-recursion">4.6 Tail Recursion</h3>
<p>Consider the following function to compute the greatest common divisor of two given numbers.</p>
<pre><code>def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)
</code></pre><p>Using our substitution model of function evaluation, <code>gcd(14, 21)</code> evaluates as follows:</p>
<pre><code>    gcd(14, 21)
→   if (21 == 0) 14 else gcd(21, 14 % 21)
→   if (false) 14 else gcd(21, 14 % 21)
→   gcd(21, 14 % 21)
→   gcd(21, 14)
→   if (14 == 0) 21 else gcd(14, 21 % 14)
→ → gcd(14, 21 % 14)
→   gcd(14, 7)
→   if (7 == 0) 14 else gcd(7, 14 % 7)
→ → gcd(7, 14 % 7)
→   gcd(7, 0)
→   if (0 == 0) 7 else gcd(0, 7 % 0)
→ → 7
</code></pre><p>Contrast this with the evaluation of another recursive function, factorial:</p>
<pre><code>def factorial(n: Int): Int = if (n == 0) 1 else n * factorial(n - 1)
</code></pre><p>The application factorial(5) rewrites as follows:</p>
<pre><code>        factorial(5)
→       if (5 == 0) 1 else 5 * factorial(5 - 1)
→       5 * factorial(5 - 1)
→       5 * factorial(4)
→ ... → 5 * (4 * factorial(3))
→ ... → 5 * (4 * (3 * factorial(2)))
→ ... → 5 * (4 * (3 * (2 * factorial(1))))
→ ... → 5 * (4 * (3 * (2 * (1 * factorial(0))))
→ ... → 5 * (4 * (3 * (2 * (1 * 1))))
→ ... → 120
</code></pre><p>There is an important difference between the two rewrite sequences: The terms in the rewrite sequence of <code>gcd</code> have again and again the same form. As evaluation proceeds, their size is bounded by a constant. By contrast, in the evaluation of factorial we get longer and longer chains of operands which are then multiplied in the last part of the evaluation sequence.</p>
<p>Even though actual implementations of Scala do not work by rewriting terms, they nevertheless should <strong>have the same space behavior as in the rewrite sequences</strong>. In the implementation of <code>gcd</code>, one notes that the recursive call to <code>gcd</code> is the last action performed in the evaluation of its body. One also says that <code>gcd</code> is “<strong>tail-recursive</strong>”. The ﬁnal call in a tail-recursive function can be implemented by a jump back to the beginning of that function. The arguments of that call can overwrite the parameters of the current instantiation of <code>gcd</code>, so that no new stack space is needed. Hence, <strong>tail recursive functions are iterative processes, which can be executed in constant space.</strong></p>
<p>By contrast, the recursive call in factorial is <strong>followed by a multiplication</strong>. Hence, <strong>a new stack frame is allocated</strong> for the recursive instance of factorial, and is deallocated after that instance has ﬁnished. The given formulation of the factorial function is <strong>not tail-recursive</strong>; it <strong>needs space proportional to its input parameter for its execution.</strong></p>
<p>More generally, if the last action of a function is a call to another (possibly the same) function, only a single stack frame is needed for both functions. Such calls are called “<strong>tail calls</strong>”. In principle, tail calls can always re-use the stack frame of the calling function. However, some run-time environments (such as the Java VM) lack the primitives to make stack frame re-use for tail calls efﬁcient. A production quality Scala implementation is therefore only required to re-use the stack frame of a directly tail-recursive function whose last action is a call to itself. Other tail calls might be optimized also, but one should not rely on this across implementations.</p>
<p>Design a tail-recursive version of factorial.</p>
<pre><code>import annotation.tailrec

def factorial(n: Int): Int = {
	assert(n &gt;= 0)

    @tailrec def factorialRec(n: Int, result: Int): Int =
        if (n == 0) result
        else factorialRec(n - 1, result * n)

    factorialRec(n, 1)
}
</code></pre><h2 id="first-class-functions">First-Class Functions</h2>
<p>Functions which take other functions <strong>as parameters</strong> or return them <strong>as results</strong> are called <strong>higher-order</strong> functions. As a motivating example, consider the following three related tasks:</p>
<ol>
<li>Write a function to sum all integers between two given numbers a and b:</li>
</ol>
<pre><code>def sumInts(a: Int, b: Int): Int =
	if (a &gt; b) 0 else a + sumInts(a + 1, b)
</code></pre><ol start="2">
<li>Write a function to sum the squares of all integers between two given numbers a and b:</li>
</ol>
<pre><code>def square(x: Int): Int = x * x
def sumSquares(a: Int, b: Int): Int =
	if (a &gt; b) 0 else square(a) + sumSquares(a + 1, b)
</code></pre><ol start="3">
<li>Write a function to sum the powers $2^n$ of all integers n between two given numbers a and b:</li>
</ol>
<pre><code>def powerOfTwo(x: Int): Int = if (x == 0) 1 else 2 * powerOfTwo(x - 1)def sumPowersOfTwo(a: Int, b: Int): Int =
	if (a &gt; b) 0 else powerOfTwo(a) + sumPowersOfTwo(a + 1, b)

</code></pre><p>These functions are all instances of $\sum_a^b f (n)$ for different values of $f$. We can factor out the common pattern by deﬁning a function sum:</p>
<pre><code>def sum(f: Int =&gt; Int, a: Int, b: Int): Int =
	if (a &gt; b) 0 else f(a) + sum(f, a + 1, b)
</code></pre><p>The type <code>Int =&gt; Int</code> is the type of functions that take arguments of type Int and return results of type Int. So sum is a function which takes another function as a parameter. In other words, sum is a higher-order function.</p>
<p>Using sum, we can formulate the three summing functions as follows.</p>
<pre><code>def sumInts(a: Int, b: Int): Int = sum(id, a, b)
def sumSquares(a: Int, b: Int): Int = sum(square, a, b)
def sumPowersOfTwo(a: Int, b: Int): Int = sum(powerOfTwo, a, b)
</code></pre><p>where</p>
<pre><code>def id(x: Int): Int = x
def square(x: Int): Int = x * x
def powerOfTwo(x: Int): Int = if (x == 0) 1 else 2 * powerOfTwo(x - 1)
</code></pre><h3 id="51-anonymous-functions">5.1 Anonymous Functions</h3>
<p>Parameterization by functions tends to create many small functions. Instead of using named function deﬁnitions for these small argument functions, we can formulate them in a shorter way as <strong>anonymous functions</strong>. As an example consider the anonymous square function:</p>
<pre><code>(x: Int) =&gt; x * x
</code></pre><p>The part before the arrow <strong><code>=&gt;</code></strong> are the parameters of the function, whereas the part following the <strong><code>=&gt;</code></strong> is its body. For instance, here is an anonymous function which multiples its two arguments.</p>
<pre><code>(x: Int, y: Int) =&gt; x * y
</code></pre><p>Using anonymous functions, we can reformulate the ﬁrst two summation functions without named auxiliary functions:</p>
<pre><code>def sumInts(a: Int, b: Int): Int = sum((x: Int) =&gt; x, a, b)
def sumSquares(a: Int, b: Int): Int = sum((x: Int) =&gt; x * x, a, b)
</code></pre><p>Often, the Scala compiler can deduce the parameter type(s) from the context of the anonymous function in which case they can be omitted. For instance, in the case of <code>sumInts</code> or <code>sumSquares</code>, one knows from the type of sum that the ﬁrst parameter must be a function of type Int =&gt; Int. Hence, <strong>the parameter type Int is redundant and may be omitted.</strong> If there is a single parameter without a type, we may also omit the parentheses around it:</p>
<pre><code>def sumInts(a: Int, b: Int): Int = sum(x =&gt; x, a, b)
def sumSquares(a: Int, b: Int): Int = sum(x =&gt; x * x, a, b)
</code></pre><p>Anonymous functions are not essential language elements of Scala, as they can always be expressed in terms of named functions. We also say, anonymous functions are “syntactic sugar”.</p>
<h3 id="52-currying">5.2 Currying</h3>
<p>The latest formulation of the summing functions is already quite compact. But we can do even better. Note that a and b appear as parameters and arguments of every function but they do not seem to take part in interesting combinations. Is there a way to get rid of them? Let’s try to rewrite sum so that it does not take the bounds a and b as parameters:</p>
<pre><code>def sum(f: Int =&gt; Int): (Int, Int) =&gt; Int = {
    def sumF(a: Int, b: Int): Int =
        if (a &gt; b) 0 else f(a) + sumF(a + 1, b)
    sumF
}
</code></pre><p>In this formulation, sum is a function which returns another function, namely the specialized summing function <code>sumF</code>. This latter function does all the work; it takes the bounds a and b as parameters, applies sum’s function parameter f to all integers between them, and sums up the results. Using this new formulation of sum, we can now deﬁne:</p>
<pre><code>def sumInts = sum(x =&gt; x)
def sumSquares = sum(x =&gt; x * x)
def sumPowersOfTwo = sum(powerOfTwo)
</code></pre><p>Or, equivalently, with value deﬁnitions:</p>
<pre><code>val sumInts = sum(x =&gt; x)
val sumSquares = sum(x =&gt; x * x)
val sumPowersOfTwo = sum(powerOfTwo)
</code></pre><p><code>sumInts</code>, <code>sumSquares</code>, and <code>sumPowersOfTwo</code> can be applied like any other function.For instance,</p>
<pre><code>scala&gt; sumSquares(1, 10) + sumPowersOfTwo(10, 20)
unnamed0: Int = 2096513
</code></pre><p>How are function-returning functions applied? As an example, in the expression</p>
<pre><code>sum(x =&gt; x * x)(1, 10) ,
</code></pre><p>the function sum is applied to the squaring function <code>(x =&gt; x * x)</code>. The resulting function is then applied to the second argument list, (1, 10).</p>
<p>This notation is possible because function application associates to the left. That is, if <code>args1</code> and <code>args2</code> are argument lists, then</p>
<p><code>f(args1)(args2)</code> is equivalent to <code>(f(args1))(args2)</code></p>
<p>In our example, <code>sum(x =&gt; x * x)(1, 10)</code> is equivalent to the following expression: <code>(sum(x =&gt; x * x))(1, 10)</code>.</p>
<p><strong>The style of function-returning functions is so useful that Scala has special syntax for it.</strong> For instance, the next deﬁnition of sum is equivalent to the previous one, but is shorter:</p>
<pre><code>def sum(f: Int =&gt; Int)(a: Int, b: Int): Int =
	if (a &gt; b) 0 else f(a) + sum(f)(a + 1, b)
</code></pre><p>Generally, a curried function deﬁnition</p>
<pre><code>def f (args_1) ... (args_n) = E
</code></pre><p>where n &gt; 1 expands to</p>
<pre><code>def f (args_1) ... (args_{n−1}) = { def g (args_n) = E ; g }
</code></pre><p>where g is a fresh identiﬁer. Or, shorter, using an anonymous function:</p>
<pre><code>def f (args_1) ... (args_{n−1}) = ( args_n ) =&gt; E .
</code></pre><p>Performing this step n times yields that</p>
<pre><code>def f (args_1) ... (args_n) = E
</code></pre><p>is equivalent to</p>
<pre><code>def f = (args_1) =&gt; ... =&gt; (args_n) =&gt; E .
</code></pre><p>Or, equivalently, using a value deﬁnition:</p>
<pre><code>val f = (args_1) =&gt; ... =&gt; (args_n) =&gt; E .
</code></pre><p>This style of function deﬁnition and application is called currying after its promoter, Haskell B. Curry, a logician of the 20th century, even though the idea goes back further to Moses Schönﬁnkel and Gottlob Frege. The type of a function-returning function is expressed analogously to its parameter list. Taking the last formulation of sum as an example, the type of sum is <code>(Int =&gt; Int) =&gt; (Int, Int) =&gt; Int</code>. This is possible because function types associate to the right. I.e.</p>
<p><code>T1 =&gt; T2 =&gt; T3</code>   is equivalent to   <code>T1 =&gt; (T2 =&gt; T3)</code></p>
<p><strong>Exercise 5.2.1 1</strong>. The sum function uses a linear recursion. Can you write a tail-recursive one by ﬁlling in the ??’s?</p>
<pre><code>def sum(f: Int =&gt; Int)(a: Int, b: Int): Int = {
    def iter(a: Int, result: Int): Int = {
        if (a &gt; b) result
        else iter(a + 1, result + f(a))
    }
    iter(a, 0)
}
</code></pre><p><strong>Exercise 5.2.2</strong> Write a function product that computes the product of the values of functions at points over a given range.</p>
<pre><code>def product(f: Int =&gt; Int)(a: Int, b: Int): Int = {
    def iter(a: Int, result: Int): Int = {
        if (a &gt; b) result
        else iter(a + 1, result * f(a))
    }
    iter(a, 1)
}
</code></pre><p><strong>Exercise 5.2.3</strong> Write factorial in terms of product.</p>
<pre><code>def factorial(n: Int): Int = product(x =&gt; x)(1, n)
</code></pre><p><strong>Exercise 5.2.4</strong> Can you write an even more general function which generalizes both sum and product?</p>
<pre><code>def exp(op: (Int, Int) =&gt; Int)(f: Int =&gt; Int)(a: Int, b: Int, init: Int): Int = {
    def iter(a: Int, result: Int): Int = {
        if (a &gt; b) result
        else iter(a + 1, op(result, f(a)))
    }
    iter(a, init)
}
</code></pre><h3 id="53-example-finding-fixed-points-of-functions">5.3 Example: Finding Fixed Points of Functions</h3>
<p>A number x is called a <strong>ﬁxed point</strong> of a function f if</p>
<pre><code>f(x) = x .
</code></pre><p>For some functions <code>f</code> we can locate the ﬁxed point by beginning with an initial guess and <strong>then applying <code>f</code> repeatedly</strong>, until the value does not change anymore (or the change is within a small tolerance). This is possible if the sequence</p>
<pre><code>x, f(x), f(f(x)), f(f(f(x))), ...
</code></pre><p><strong>converges to ﬁxed point of f</strong> . This idea is captured in the following “<strong>ﬁxed-point ﬁnding function</strong>”:</p>
<pre><code>val tolerance = 0.0001
def isCloseEnough(x: Double, y: Double) = abs((x - y) / x) &lt; tolerance
def fixedPoint(f: Double =&gt; Double)(firstGuess: Double) = {
    def iterate(guess: Double): Double = {
        val next = f(guess)
        if (isCloseEnough(guess, next)) next
        else iterate(next)
    }
    iterate(firstGuess)
}
</code></pre><p>We now apply this idea in a reformulation of the square root function. Let’s start with a speciﬁcation of sqrt:</p>
<pre><code>sqrt(x) = the y such that y * y = x
        = the y such that y = x / y
</code></pre><p>Hence, sqrt(x) is a ﬁxed point of the function y =&gt; x / y. This suggests that sqrt(x) can be computed by ﬁxed point iteration:</p>
<pre><code>def sqrt(x: double) = fixedPoint(y =&gt; x / y)(1.0)
</code></pre><p>But if we try this, we ﬁnd that the computation does not converge. Let’s instrument the ﬁxed point function <strong>with a print statement which keeps track of the current guess value</strong>:</p>
<pre><code>def fixedPoint(f: Double =&gt; Double)(firstGuess: Double) = {
	def iterate(guess: Double): Double = {
		val next = f(guess)
		println(next)
		if (isCloseEnough(guess, next)) next
		else iterate(next)
		}
	iterate(firstGuess)
}
</code></pre><p>Then, sqrt(2) yields:</p>
<pre><code>2.0
1.0
2.0
1.0
2.0
...
</code></pre><p>One way to control such oscillations is to prevent the guess from changing too much. This can be achieved by averaging successive values of the original sequence:</p>
<pre><code>scala&gt; def sqrt(x: Double) = fixedPoint(y =&gt; (y + x/y) / 2)(1.0)
sqrt: (Double)Double

scala&gt; sqrt(2.0)
1.5
1.4166666666666665
1.4142156862745097
1.4142135623746899
1.4142135623746899
</code></pre><p>In fact, expanding the <code>fixedPoint</code> function yields exactly our previous deﬁnition of ﬁxed point from Section 4.4. The previous examples showed that <strong>the expressive power of a language is considerably enhanced if functions can be passed as arguments.</strong> The next example shows that <strong>functions which return functions can also be very useful.</strong></p>
<p>Consider again ﬁxed point iterations. We started with the observation that a ﬁxed point of the function <code>y =&gt; x / y</code>. Then we made the iteration converge by averaging successive values. <strong>This technique of average damping is so general that it can be wrapped in another function</strong>.</p>
<pre><code>def averageDamp(f: Double =&gt; Double)(x: Double) = (x + f(x)) / 2
</code></pre><p>Using <code>averageDamp</code>, we can reformulate the square root function as follows.</p>
<pre><code>def sqrt(x: Double) = fixedPoint(averageDamp(y =&gt; x/y))(1.0)
</code></pre><p>This expresses the elements of the algorithm as clearly as possible.</p>
<p><strong>Exercise 5.3.1</strong> Write a function for cube roots using <code>fixedPoint</code> and <code>averageDamp</code>.</p>
<pre><code>def cube(x: Double) = 
    fixedPoint(averageDamp(y =&gt; (x / (y * y) + 2 * y) / 3))(1.0)
</code></pre><h3 id="54-summary">5.4 Summary</h3>
<p>We have seen in the previous chapter that functions are essential abstractions, because they permit us to introduce general methods of computing as explicit, named elements in our programming language. The present chapter has shown that these abstractions can be combined by higher-order functions to create further abstractions. <strong>As programmers, we should look out for opportunities to abstract and to reuse.</strong> The highest possible level of <strong>abstraction is not always the best</strong>, but it is important to know abstraction techniques, so that one can <strong>use abstractions where appropriate.</strong></p>
<h3 id="55-language-elements-seen-so-far">5.5 Language Elements Seen So Far</h3>
<p>Chapters 4 and 5 have covered Scala’s language elements to express expressions and types comprising of primitive data and functions. The context-free syntax of these language elements is given below in extended Backus-Naur form, where ‘|’ denotes alternatives, [&hellip;] denotes option (0 or 1 occurrence), and {&hellip;} denotes repetition(0 or more occurrences).</p>
<p><strong>Characters</strong></p>
<p>Scala programs are sequences of (Unicode) characters. We distinguish the following character sets:</p>
<ul>
<li>
<p>whitespace, such as <code>‘’</code>, tabulator, or newline characters,</p>
</li>
<li>
<p>letters <code>‘a’</code> to <code>‘z’</code>, <code>‘A’</code> to <code>‘Z’</code>,</p>
</li>
<li>
<p>digits <code>‘0’</code> to <code>‘9’</code>,</p>
</li>
<li>
<p>the delimiter characters</p>
<p><code>.   ,   ;   (   )   {   }   [   ]   \   &quot;   ’</code></p>
</li>
<li>
<p>operator characters, such as <code>‘#’</code> <code>‘+’</code>, <code>‘:’</code>. Essentially, these are printable characters which are in none of the character sets above.</p>
</li>
</ul>
<p><strong>Lexemes</strong>:</p>
<pre><code>ident   = letter {letter | digit}
        | operator { operator }
        | ident ’_’ ident
literal = “as in Java”
</code></pre><p><strong>Literals</strong> are as in Java. They deﬁne <strong>numbers</strong>, <strong>characters</strong>, <strong>strings</strong>, or <strong>boolean</strong> values.Examples of literals as <code>0</code>, <code>1.0e10</code>, <code>’x’</code>, <code>&quot;he said &quot;hi!&quot;&quot;</code>, or <code>true</code>.</p>
<p><strong>Identiﬁers</strong> can be of two forms. They <strong>either start with a letter</strong>, which is followed by a (possibly empty) sequence of letters or symbols, <strong>or</strong> they <strong>start with an operator character</strong>, which is followed by a (possibly empty) sequence of operator characters. Both forms of identiﬁers <strong>may contain underscore characters ‘_’.</strong> Furthermore, an underscore character may be followed by either sort of identiﬁer. Hence, the following are all legal identiﬁers:</p>
<p><code>   x     Room10a     +     --     foldl_:     +_vector</code></p>
<p>It follows from this rule that subsequent operator-identiﬁers need to be <strong>separated by whitespace</strong>. For instance, the input <code>x+-y</code> is parsed as the three token sequence <code>x</code>, <code>+-</code>, <code>y.</code> If we want to express the sum of x with the negated value of y, we need to add at least one space, e.g. <code>x+ -y</code>.</p>
<p>The <strong><code>$</code></strong> character is reserved for compiler-generated identiﬁers; it should not be used in source programs. The following are reserved words, they may not be used as identiﬁers:</p>
<pre><code>abstract case catch class def do else extends false final finally for if implicit import match new null object override package private protected requires return sealed super this throw trait try true type val var while with yield
_   :   =   =&gt;   &lt;-   &lt;:   &lt;%   &gt;:     #    @ 
</code></pre><p><strong>Types:</strong></p>
<pre><code>Type         = SimpleType | FunctionType
FunctionType = SimpleType ’=&gt;’ Type | ’(’ [Types] ’)’ ’=&gt;’ Type
SimpleType   = Byte | Short | Char | Int | Long | Float | Double | Boolean | Unit | String
Types        = Type {‘,’ Type}
</code></pre><p>Types can be:</p>
<ul>
<li>
<p>number types <strong>Byte</strong>, <strong>Short</strong>, <strong>Char</strong>, <strong>Int</strong>, <strong>Long</strong>, <strong>Float</strong> and <strong>Double</strong> (these are as in Java),</p>
</li>
<li>
<p>the type <strong>Boolean</strong> with values <strong>true</strong> and <strong>false</strong>,</p>
</li>
<li>
<p>the type Unit with the only value (),</p>
</li>
<li>
<p>the type <strong>String</strong>,</p>
</li>
<li>
<p><strong>function types</strong> such as (Int, Int) =&gt; Int or String =&gt; Int =&gt; String.
<strong>Expressions:</strong></p>
</li>
</ul>
<pre><code>Expr  = InfixExpr | FunctionExpr | if ’(’ Expr ’)’ Expr else Expr
InfixExpr  = PrefixExpr | InfixExpr Operator InfixExpr
Operator  = ident
PrefixExpr  = [’+’ | ’-’ | ’!’ | ’~’ ] SimpleExpr
SimpleExpr  = ident | literal | SimpleExpr ’.’ ident | Block
FunctionExpr = (Bindings | Id) ’=&gt;’ Expr
Bindings  = ‘(’ Binding {‘,’ Binding} ‘)’
Binding  = ident [’:’ Type]
Block  = ’{’ {Def ’;’} Expr ’}’
</code></pre><p>Expressions can be:</p>
<ul>
<li>identiﬁers such as <code>x</code>, <code>isGoodEnough</code>, <code>*</code>, or <code>+-</code>,</li>
<li>literals, such as <code>0</code>, <code>1.0</code>, or <code>&quot;abc&quot;</code>,</li>
<li><strong>ﬁeld and method selections</strong>, such as <code>System.out.println</code>,</li>
<li>function applications, such as <code>sqrt(x)</code>,</li>
<li>operator applications, such as <code>-x</code> or <code>y + x</code>,</li>
<li>conditionals, such as <strong><code>if</code></strong> (x &lt; 0) -x <strong><code>else</code></strong> x,</li>
<li><strong>blocks</strong>, such as <code>{ val x = abs(y) ; x * 2 }</code>,</li>
<li>anonymous functions, such as <code>x =&gt; x + 1</code> or <code>(x: Int, y: Int) =&gt; x + y</code>.</li>
</ul>
<p><strong>Deﬁnitions:</strong></p>
<pre><code>Def        = FunDef | ValDef
FunDef     = ’def’ ident {’(’ [Parameters] ’)’} [’:’ Type] ’=’ Expr
ValDef     = ’val’ ident [’:’ Type] ’=’ Expr
Parameters = Parameter {’,’ Parameter}
Parameter  = ident ’:’ [’=&gt;’] Type
</code></pre><p>Deﬁnitions can be:</p>
<ul>
<li>function deﬁnitions such as <code>def square(x: Int): Int = x * x</code>,</li>
<li>value deﬁnitions such as <code>val y = square(2)</code>.</li>
</ul>
<h2 id="classes-and-objects">Classes and Objects</h2>
<p>Scala does not have a built-in type of rational numbers, but it is easy to deﬁne one, using a class. Here’s a possible implementation.</p>
<pre><code>class Rational(n: Int, d: Int) {
	private def gcd(x: Int, y: Int): Int = {
		if (x == 0) y
		else if (x &lt; 0) gcd(-x, y)
		else if (y &lt; 0) -gcd(x, -y)
		else gcd(y % x, x)
	}
	private val g = gcd(n, d)
	
	val numer: Int = n/g
	val denom: Int = d/g
	def +(that: Rational) =
		new Rational(numer * that.denom + that.numer * denom,
		             denom * that.denom)
	def -(that: Rational) =
		new Rational(numer * that.denom - that.numer * denom,
		             denom * that.denom)
	def *(that: Rational) =
		new Rational(numer * that.numer, denom * that.denom)
	def /(that: Rational) =
		new Rational(numer * that.denom, denom * that.numer)
}
</code></pre><p>This deﬁnes Rational as a class which takes two constructor arguments n and d, containing the number’s numerator and denominator parts. The class provides ﬁelds which return these parts as well as methods for arithmetic over rational numbers. Each arithmetic method takes as parameter the right operand of the operation. The left operand of the operation is always the rational number of which the method is a member.</p>
<p>Private members. The implementation of rational numbers deﬁnes a private method gcd which computes the greatest common denominator of two integers, as well as a private ﬁeld g which contains the gcd of the constructor arguments. These members are inaccessible outside class Rational. They are used in the implementation of the class to eliminate common factors in the constructor arguments in order to ensure that numerator and denominator are always in normalized form.</p>
<p>Creating and Accessing Objects. As an example of how rational numbers can be used, here’s a program that prints the sum of all numbers 1/i where i ranges from 1 to 10.</p>
<pre><code>var i = 1
var x = new Rational(0, 1)
while (i &lt;= 10) {
	x += new Rational(1, i)
	i += 1
}
println(&quot;&quot; + x.numer + &quot;/&quot; + x.denom)
</code></pre><p>The + takes as left operand a string and as right operand a value of arbitrary type. It returns the result of converting its right operand to a string and appending it to its left operand.</p>
<p>Inheritance and Overriding. Every class in Scala has a superclass which it ex-tends.</p>
<p>If a class does not mention a superclass in its deﬁnition, the root type scala.AnyRef is implicitly assumed (for Java implementations, this type is an alias for java.lang.Object. For instance, class Rational could equivalently be deﬁned as</p>
<pre><code>class Rational(n: Int, d: Int) extends AnyRef {
... // as before
}
</code></pre><p>A class inherits all members from its superclass. It may also redeﬁne (or: override)some inherited members. For instance, class java.lang.Object deﬁnes a method to String which returns a representation of the object as a string:</p>
<pre><code>class Object {
    ...
    def toString: String = ...
}

</code></pre><p>The implementation of toString in Object forms a string consisting of the object’s class name and a number. It makes sense to redeﬁne this method for objects that are rational numbers:</p>
<pre><code>class Rational(n: Int, d: Int) extends AnyRef {
    ... // as before
    override def toString = &quot;&quot; + numer + &quot;/&quot; + denom
}
</code></pre><p>Note that, unlike in Java, redeﬁning deﬁnitions need to be preceded by an override modiﬁer. If class A extends class B, then objects of type A may be used wherever objects of type B are expected. We say in this case that type A conforms to type B. For instance, Rational conforms to AnyRef, so it is legal to assign a Rational value to a variable of type AnyRef:</p>
<pre><code>var x: AnyRef = new Rational(1, 2)
</code></pre><p>Parameterless Methods. Unlike in Java, methods in Scala do not necessarily take a parameter list. An example is the square method below. This method is invoked by simply mentioning its name.</p>
<pre><code>class Rational(n: Int, d: Int) extends AnyRef {
    ... // as before
    def square = new Rational(numernumer, denomdenom)
}
val r = new Rational(3, 4)
println(r.square)
// prints‘‘9/16’’*
</code></pre><p>That is, parameterless methods are accessed just as value ﬁelds such as numer are. The difference between values and parameterless methods lies in their deﬁnition. The right-hand side of a value is evaluated when the object is created, and the value does not change afterwards. A right-hand side of a parameterless method, on the other hand, is evaluated each time the method is called. The uniform access of ﬁelds and parameterless methods gives increased ﬂexibility for the implementer of a class. Often, a ﬁeld in one version of a class becomes a computed value in the next version. Uniform access ensures that clients do not have to be rewritten because of that change.</p>
<p><strong>Abstract Classes.</strong> Consider the task of writing a class for sets of integer numbers with two operations, incl and contains. (s incl x) should return a new set which contains the element x together with all the elements of set s. (s contains x) should return true if the set s contains the element x, and should return false oth- erwise. The interface of such sets is given by:</p>
<pre><code>Classes and Objectsabstract class IntSet {
    def incl(x: Int): IntSet
    def contains(x: Int): Boolean
}
</code></pre><p>IntSet is labeled as an abstract class. This has two consequences. First, abstract classes may have deferred members which are declared but which do not have an implementation. In our case, both incl and contains are such members. Second,because an abstract class might have unimplemented members, no objects of thatclass may be created using new. By contrast, an abstract class may be used as a base class of some other class, which implements the deferred members.</p>
<p><strong>Traits.</strong>  Instead of abstract class one also often uses the keyword trait in Scala.Traits are abstract classes that are meant to be added to some other class. This might be because a trait adds some methods or ﬁelds to an unknown parent class.For instance, a trait Bordered might be used to add a border to a various graphical components. Another usage scenario is where the trait collects signatures of some functionality provided by different classes, much in the way a Java interface would work.</p>
<p>Since IntSet falls in this category, one can alternatively deﬁne it as a trait:</p>
<pre><code>trait IntSet {
    def incl(x: Int): IntSet
    def contains(x: Int): Boolean
}
</code></pre><p><strong>Implementing Abstract Classes.</strong> Let’s say, we plan to implement sets as binary trees. There are two possible forms of trees. A tree for the empty set, and a tree consisting of an integer and two subtrees. Here are their implementations.</p>
<pre><code>class EmptySet extends IntSet {
    def contains(x: Int): Boolean = false
    def incl(x: Int): IntSet = new NonEmptySet(x, new EmptySet, new EmptySet)
}
class NonEmptySet(elem: Int, left: IntSet, right: IntSet) extends IntSet {
    def contains(x: Int): Boolean =
        if (x &lt; elem) left contains x
        else if (x &gt; elem) right contains x
        else true
    def incl(x: Int): IntSet =
        if (x &lt; elem) new NonEmptySet(elem, left incl x, right)
        else if (x &gt; elem) new NonEmptySet(elem, left, right incl x)
        else this
}
</code></pre><p>Both EmptySet and NonEmptySet extend class IntSet. This implies that types EmptySet and NonEmptySet conform to type IntSet – a value of type EmptySet or NonEmptySet may be used wherever a value of type IntSet is required.</p>
<p>Exercise 6.0.1 Write methods union and intersection to form the union and in- tersection between two sets.</p>
<p>Exercise 6.0.2 Add a method
def excl(x: Int)</p>
<p>to return the given set without the element x. To accomplish this, it is useful to also implement a test method for sets.
def isEmpty: Boolean</p>
<p><strong>Dynamic Binding.</strong> Object-oriented languages (Scala included) use dynamic dis- patch for method invocations. That is, the code invoked for a method call depends on the run-time type of the object which contains the method. For example, con- sider the expression s contains 7 where s is a value of declared type s: IntSet. Which code for contains is executed depends on the type of value of s at run-time. If it is an EmptySet value, it is the implementation of contains in class EmptySet that is executed, and analogously for NonEmptySet values. This behavior is a direct consequence of our substitution model of evaluation. For instance,</p>
<pre><code>   (new EmptySet).contains(7)
-&gt;      (by replacing contains by its body in class EmptySet)
   false
</code></pre><p>Or,</p>
<pre><code>   new NonEmptySet(7, new EmptySet, new EmptySet).contains(1)
-&gt;      (by replacing contains by its body in class NonEmptySet)
   if (1 &lt; 7) new EmptySet contains 1
   else if (1 &gt; 7) new EmptySet contains 1
   else true
-&gt;     (by rewriting the conditional)
   new EmptySet contains 1
-&gt;       (by replacing contains by its body in class EmptySet)
   false .
</code></pre><p>Dynamic method dispatch is analogous to higher-order function calls. In both cases, the identity of code to be executed is known only at run-time. This similarity is not just superﬁcial. Indeed, Scala represents every function value as an object(see Section 8.6).</p>
<p><strong>Objects.</strong> In the previous implementation of integer sets, empty sets were ex-pressed with new EmptySet; so a new object was created every time an empty setvalue was required. We could have avoided unnecessary object creations by deﬁn-ing a value empty once and then using this value instead of every occurrence ofnew EmptySet. For example:</p>
<pre><code>val EmptySetVal = new EmptySet
</code></pre><p>One problem with this approach is that a value deﬁnition such as the one above isnot a legal top-level deﬁnition in Scala; it has to be part of another class or object.Also, the deﬁnition of class EmptySet now seems a bit of an overkill – why deﬁnea class of objects, if we are only interested in a single object of this class? A moredirect approach is to use an object deﬁnition. Here is a more streamlined alternativedeﬁnition of the empty set:</p>
<pre><code>object EmptySet extends IntSet {
    def contains(x: Int): Boolean = false
    def incl(x: Int): IntSet = new NonEmptySet(x, EmptySet, EmptySet)
}
</code></pre><p>The syntax of an object deﬁnition follows the syntax of a class deﬁnition; it hasan optional extends clause as well as an optional body. As is the case for classes,the extends clause deﬁnes inherited members of the object whereas the body de-ﬁnes overriding or new members. However, an object deﬁnition deﬁnes a single object only it is not possible to create other objects with the same structure using new. Therefore, object deﬁnitions also lack constructor parameters, which might be present in class deﬁnitions.</p>
<p>Object deﬁnitions can appear anywhere in a Scala program; including at top-level.Since there is no ﬁxed execution order of top-level entities in Scala, one might ask exactly when the object deﬁned by an object deﬁnition is created and initialized.The answer is that the object is created the ﬁrst time one of its members is accessed.This strategy is called lazy evaluation.</p>
<p><strong>Standard Classes</strong>. Scala is a pure object-oriented language. This means that every value in Scala can be regarded as an object. In fact, even primitive types such as int or boolean are not treated specially. They are deﬁned as type aliases of Scala classesin module Predef:</p>
<ul>
<li>type boolean = scala.Boolean</li>
<li>type int = scala.Int</li>
<li>type long = scala.Long</li>
<li>&hellip;</li>
</ul>
<p>For efﬁciency, the compiler usually represents values of type scala.Int by 32 bit integers, values of type scala.Boolean by Java’s booleans, etc. But it converts these specialized representations to objects when required, for instance when a primitive Int value is passed to a function with a parameter of type AnyRef. Hence, the special representation of primitive values is just an optimization, it does not change the meaning of a program.</p>
<p>Here is a speciﬁcation of class Boolean.</p>
<pre><code>package scala
	abstract class Boolean {
	def &amp;&amp; (x: =&gt; Boolean): Boolean
	def || (x: =&gt; Boolean): Boolean
	def !                 : Boolean 

	def == (x: Boolean)  : Boolean
	def != (x: Boolean)  : Boolean
	def &lt; (x: Boolean)   : Boolean
	def &gt; (x: Boolean)   : Boolean
	def &lt;= (x: Boolean)  : Boolean
	def &gt;= (x: Boolean)  : Boolean
}
</code></pre><p>Booleans can be deﬁned using only classes and objects, without reference to a built- in type of booleans or numbers. A possible implementation of class Boolean is given below. This is not the actual implementation in the standard Scala library. For efﬁciency reasons the standard implementation uses built-in booleans.</p>
<pre><code>package scala
abstract class Boolean {
	def ifThenElse(thenpart: =&gt; Boolean, elsepart: =&gt; Boolean)
	def &amp;&amp; (x: =&gt; Boolean): Boolean = ifThenElse(x, false)
	def || (x: =&gt; Boolean): Boolean = ifThenElse(true, x)
	def !
	: Boolean = ifThenElse(false, true)
	def == (x: Boolean)
	: Boolean = ifThenElse(x, x.!)
	Classes and Objectsdef != (x: Boolean)
	def &lt; (x: Boolean)
	def &gt; (x: Boolean)
	def &lt;= (x: Boolean)
	def &gt;= (x: Boolean)
	: Boolean = ifThenElse(x.!, x)
	: Boolean = ifThenElse(false, x)
	: Boolean = ifThenElse(x.!, false)
	: Boolean = ifThenElse(x, true)
	: Boolean = ifThenElse(true, x.!)
}
case object True extends Boolean {
	def ifThenElse(t: =&gt; Boolean, e: =&gt; Boolean) = t
}
case object False extends Boolean {
	def ifThenElse(t: =&gt; Boolean, e: =&gt; Boolean) = e
}
</code></pre><p>Here is a partial speciﬁcation of class Int.</p>
<pre><code>package scala
abstract class Int extends AnyVal {
	def toLong: Long
	def toFloat: Float
	def toDouble: Double
	def + (that: Double): Double
	def + (that: Float): Float
	def + (that: Long): Long
	def + (that: Int): Int	// analogous for -, *, /, %

	def &lt;&lt; (cnt: Int): Int  	// analogous for &gt;&gt;, &gt;&gt;&gt;

	def &amp; (that: Long): Long
	def &amp; (that: Int): Int   	// analogous for |, ^

	def == (that: Double): Boolean
	def == (that: Float): Boolean
	def == (that: Long): Boolean   // analogous for !=, &lt;, &gt;, &lt;=, &gt;=
}
</code></pre><p>Class Int can in principle also be implemented using just objects and classes, with-out reference to a built in type of integers. To see how, we consider a slightly simpler problem, namely how to implement a type Nat of natural (i.e. non-negative) numbers. Here is the deﬁnition of an abstract class Nat:</p>
<pre><code>abstract class Nat {
	def isZero: Boolean
	def predecessor: Nat
	def successor: Nat
	def + (that: Nat): Nat
	def - (that: Nat): Nat
}
</code></pre><p>To implement the operations of class Nat, we deﬁne a sub-object Zero and a sub- class Succ (for successor). Each number N is represented as N applications of the Succ constructor to Zero:</p>
<p>The implementation of the Zero object is straightforward:</p>
<pre><code>object Zero extends Nat {
	def isZero: Boolean = true
	def predecessor: Nat = error(&quot;negative number&quot;)
	def successor: Nat = new Succ(Zero)
	def + (that: Nat): Nat = that
	def - (that: Nat): Nat = if (that.isZero) Zero
	                  else error(&quot;negative number&quot;)
}
</code></pre><p>The implementation of the predecessor and subtraction functions on Zero throws an Error exception, which aborts the program with the given error message. Here is the implementation of the successor class:</p>
<pre><code>class Succ(x: Nat) extends Nat {
	def isZero: Boolean = false
	def predecessor: Nat = x
	def successor: Nat = new Succ(this)
	def + (that: Nat): Nat = x + that.successor
	def - (that: Nat): Nat = if (that.isZero) this
		              else x - that.predecessor
}
</code></pre><p>Note the implementation of method successor. To create the successor of a num- ber, we need to pass the object itself as an argument to the Succ constructor. The object itself is referenced by the reserved name this. The implementations of + and - each contain a recursive call with the constructor argument as receiver. The recursion will terminate once the receiver is the Zero object (which is guaranteed to happen eventually because of the way numbers are formed).</p>
<p><strong>Exercise 6.0.3</strong> Write an implementation Integer of integer numbers The imple- mentation should support all operations of class Nat while adding two methods</p>
<pre><code>def isPositive: Boolean
def negate: Integer
</code></pre><p>The ﬁrst method should return true if the number is positive. The second method should negate the number. Do not use any of Scala’s standard numeric classes inyour implementation. (Hint: There are two possible ways to implement Integer.One can either make use the existing implementation of Nat, representing an inte-ger as a natural number and a sign. Or one can generalize the given implementation of Nat to Integer, using the three subclasses Zero for 0, Succ for positive numbers and Pred for negative numbers.)</p>
<p><strong>Language Elements Introduced In This Chapter</strong></p>
<p>Types:</p>
<pre><code>Type      = ... | ident
</code></pre><p>Types can now be arbitrary identiﬁers which represent classes.</p>
<p><strong>Expressions:</strong></p>
<pre><code>Expr = ... | Expr ’.’ ident | ’new’ Expr | ’this’
</code></pre><p>An expression can now be an object creation, or a selection E.m of a member m froman object-valued expression E, or it can be the reserved name <strong>this</strong>.</p>
<p><strong>Deﬁnitions and Declarations:</strong></p>
<pre><code>Def = FunDef | ValDef | ClassDef | TraitDef | ObjectDef
ClassDef = [’abstract’] ’class’ ident [’(’ [Parameters] ’)’]
           [’extends’ Expr] ['{' {TemplateDef} '}']
TraitDef = ’trait’ ident [’extends’ Expr] ['{' {TemplateDef} '}']
ObjectDef = ’object’ ident [’extends’ Expr] ['{' {ObjectDef} '}']
TemplateDef = [Modifier] (Def | Dcl)
ObjectDef = [Modifier] Def
Modifier = ’private’ | ’override’
Dcl = FunDcl | ValDcl
FunDcl = ’def’ ident {’(’ [Parameters] ’)’} ’:’ Type
ValDcl = ’val’ ident ’:’ Type
</code></pre><p>A deﬁnition can now be a class, trait or object deﬁnition such as</p>
<pre><code>class C(params) extends B { defs }
trait T extends B { defs }
object O extends B { defs }

</code></pre><p>The deﬁnitions defs in a class, trait or object may be preceded by modiﬁers <strong>private</strong> or <strong>override</strong>.</p>
<p>Abstract classes and traits may also contain declarations. These introduce <strong>deferred</strong> functions or values with their types, but do not give an implementation. Deferred members have to be implemented in subclasses before objects of an abstract class- or trait can be created.</p>
<h2 id="case-classes-and-pattern-matching">Case Classes and Pattern Matching</h2>
<p>Say, we want to write an interpreter for arithmetic expressions. To keep things sim- ple initially, we restrict ourselves to just numbers and + operations. Such expres- sions can be represented as a class hierarchy, with an abstract base class Expr as the root, and two subclasses Number and Sum. Then, an expression 1 + (3 + 7) would be represented as</p>
<pre><code>new Sum(new Number(1), new Sum(new Number(3), new Number(7)))
</code></pre><p>Now, an evaluator of an expression like this needs to know of what form it is (either Sum or Number) and also needs to access the components of the expression. The following implementation provides all necessary methods.</p>
<pre><code>abstract class Expr {
	def isNumber: Boolean
	def isSum: Boolean
	def numValue: Int
	def leftOp: Expr
	def rightOp: Expr
}
class Number(n: Int) extends Expr {
	def isNumber: Boolean = true
	def isSum: Boolean = false
	def numValue: Int = n
	def leftOp: Expr = error(&quot;Number.leftOp&quot;)
	def rightOp: Expr = error(&quot;Number.rightOp&quot;)
}
class Sum(e1: Expr, e2: Expr) extends Expr {
	def isNumber: Boolean = false
	def isSum: Boolean = true
	def numValue: Int = error(&quot;Sum.numValue&quot;)
	def leftOp: Expr = e1
	def rightOp: Expr = e2
}

</code></pre><p>With these classiﬁcation and access methods, writing an evaluator function is simple:</p>
<pre><code>def eval(e: Expr): Int = {
    if (e.isNumber) e.numValue
    else if (e.isSum) eval(e.leftOp) + eval(e.rightOp)
    else error(&quot;unrecognized expression kind&quot;)
}
</code></pre><p>However, deﬁning all these methods in classes Sum and Number is rather tedious.Furthermore, the problem becomes worse when we want to add new forms of expressions. For instance, consider adding a new expression form Prod for products.Not only do we have to implement a new class Prod, with all previous classiﬁcation and access methods; we also have to introduce a new abstract method isProduct in class Expr and implement that method in subclasses Number, Sum, and Prod. Havingto modify existing code when a system grows is always problematic, since it introduces versioning and maintenance problems.</p>
<p>The promise of object-oriented programming is that such modiﬁcations should beunnecessary, because they can be avoided by re-using existing, unmodiﬁed codethrough inheritance. Indeed, a more object-oriented decomposition of our prob-lem solves the problem. The idea is to make the “high-level” operation eval amethod of each expression class, instead of implementing it as a function outsidethe expression class hierarchy, as we have done before. Because eval is now a mem-ber of all expression nodes, all classiﬁcation and access methods become superﬂu-ous, and the implementation is simpliﬁed considerably:</p>
<pre><code>abstract class Expr {
	def eval: Int
}
class Number(n: Int) extends Expr {
	def eval: Int = n
}
class Sum(e1: Expr, e2: Expr) extends Expr {
	def eval: Int = e1.eval + e2.eval
}
</code></pre><p>Furthermore, adding a new Prod class does not entail any changes to existing code:</p>
<pre><code>class Prod(e1: Expr, e2: Expr) extends Expr {
	def eval: Int = e1.eval * e2.eval
}
</code></pre><p>The conclusion we can draw from this example is that object-oriented decomposition is the technique of choice for constructing systems that should be extensible with new types of data. But there is also another possible way we might want to ex- tend the expression example. We might want to add new operations on expressions. For instance, we might want to add an operation that pretty-prints an expression tree to standard output. If we have deﬁned all classiﬁcation and access methods, such an operation can easily be written as an external function. Here is an example:</p>
<pre><code>def print(e: Expr) {
	if (e.isNumber) Console.print(e.numValue)
	else if (e.isSum) {
		Console.print(&quot;(&quot;)
		print(e.leftOp)
		Console.print(&quot;+&quot;)
		print(e.rightOp)
		Console.print(&quot;)&quot;)
	} else error(&quot;unrecognized expression kind&quot;)
}

</code></pre><p>However, if we had opted for an object-oriented decomposition of expressions, we would need to add a new print procedure to each class:</p>
<pre><code>abstract class Expr {
	def eval: Int
		def print
}
class Number(n: Int) extends Expr {
	def eval: Int = n
	def print { Console.print(n) }
	}
class Sum(e1: Expr, e2: Expr) extends Expr {
	def eval: Int = e1.eval + e2.eval
	def print {
		Console.print(&quot;(&quot;)
		print(e1)
		Console.print(&quot;+&quot;)
		print(e2)
		Console.print(&quot;)&quot;)
	}
}
</code></pre><p>Hence, classical object-oriented decomposition requires modiﬁcation of all existing classes when a system is extended with new operations.</p>
<p>As yet another way we might want to extend the interpreter, consider expression simpliﬁcation. For instance, we might want to write a function which rewrites expressions of the form a * b + a * c to a * (b + c). This operation requires inspection of more than a single node of the expression tree at the same time. Hence,it cannot be implemented by a method in each expression kind, unless that method can also inspect other nodes. So we are forced to have classiﬁcation and access methods in this case. This seems to bring us back to square one, with all the problems of verbosity and extensibility.</p>
<p>Taking a closer look, one observes that the only purpose of the classiﬁcation andaccess functions is to reverse the data construction process. They let us determine,ﬁrst, which sub-class of an abstract base class was used and, second, what were theconstructor arguments. Since this situation is quite common, Scala has a way toautomate it with case classes.</p>
<h3 id="71-case-classes-and-case-objects">7.1 Case Classes and Case Objects</h3>
<p>Case classes and case objects are deﬁned like a normal classes or objects, except thatthe deﬁnition is preﬁxed with the modiﬁer case. For instance, the deﬁnitions</p>
<pre><code>abstract class Expr
case class Number(n: Int) extends Expr
case class Sum(e1: Expr, e2: Expr) extends Expr
</code></pre><p>introduce Number and Sum as case classes. The case modiﬁer in front of a class orobject deﬁnition has the following effects.</p>
<ol>
<li>
<p>Case classes implicitly come with a constructor function, with the same nameas the class. In our example, the two functions</p>
<pre><code>def Number(n: Int) = new Number(n)
def Sum(e1: Expr, e2: Expr) = new Sum(e1, e2)
</code></pre><p>would be added. Hence, one can now construct expression trees a bit more concisely, as in</p>
<pre><code>Sum(Sum(Number(1), Number(2)), Number(3))
</code></pre></li>
<li>
<p>Case classes and case objects implicitly come with implementations of methods toString, equals and hashCode, which override the methods with the same name in class AnyRef. The implementation of these methods takes in each case the structure of a member of a case class into account. The <code>toString</code> method represents an expression tree the way it was constructed.So,</p>
<pre><code>Sum(Number(1), Number(2)) == Sum(Number(1), Number(2))
</code></pre><p>will yield true. If Sum or Number were not case classes, the same expression would be false, since the standard implementation of equals in class AnyRef always treats objects created by different constructor calls as being differ- ent. The hashCode method follows the same principle as other two meth- ods. It computes a hash code from the case class constructor name and the hash codes of the constructor arguments, instead of from the object’s address, which is what the as the default implementation of hashCode does.</p>
</li>
<li>
<p>Case classes implicitly come with nullary accessor methods which retrieve the constructor arguments. In our example, Number would obtain an accessor method</p>
<pre><code>def n: Int
</code></pre><p>which returns the constructor parameter n, whereas Sum would obtain two accessor methods</p>
<pre><code>def e1: Expr, e2: Expr
</code></pre><p>Hence, if for a value s of type Sum, say, one can now write s.e1, to access the left operand. However, for a value e of type Expr, the term e.e1 would be illegal since e1 is deﬁned in Sum; it is not a member of the base class Expr. So, how do we determine the constructor and access constructor arguments for values whose static type is the base class Expr? This is solved by the fourth and ﬁnal particularity of case classes.</p>
</li>
<li>
<p>Case classes allow the constructions of patterns which refer to the case class constructor.</p>
</li>
</ol>
<h3 id="72-pattern-matching">7.2 Pattern Matching</h3>
<p>Pattern matching is a generalization of C or Java’s switch statement to class hier- archies. Instead of a switch statement, there is a standard method match, which is deﬁned in Scala’s root class Any, and therefore is available for all objects. The match method takes as argument a number of cases. For instance, here is an implementation of eval using pattern matching.</p>
<pre><code>def eval(e: Expr): Int = e match {
	case Number(n) =&gt; n
	case Sum(l, r) =&gt; eval(l) + eval(r)
}
</code></pre><p>In this example, there are two cases. Each case associates a pattern with an expression. Patterns are matched against the selector values e. The ﬁrst pattern in our example, Number(n), matches all values of the form Number(v), where v is an arbitrary value. In that case, the pattern variable n is bound to the value v. Similarly, the pattern Sum(l, r) matches all selector values of form Sum(v1, v2) and binds the pattern variables l and r to v1 and v2, respectively.</p>
<p>In general, patterns are built from</p>
<ul>
<li>Case class constructors, e.g. Number, Sum, whose arguments are again patterns,• pattern variables, e.g. n, e1, e2,</li>
<li>the “wildcard” pattern _,</li>
<li>literals, e.g. 1, true, &ldquo;abc&rdquo;,</li>
<li>constant identiﬁers, e.g. MAXINT, EmptySet.</li>
</ul>
<p>Pattern variables always start with a lower-case letter, so that they can be distinguished from constant identiﬁers, which start with an upper case letter. Each variable name may occur only once in a pattern. For instance, Sum(x, x) would be illegal as a pattern, since the pattern variable x occurs twice in it.</p>
<p><strong>Meaning of Pattern Matching.</strong> A pattern matching expression</p>
<pre><code>e match { case p1 =&gt; e1 ... case pn =&gt; en }
</code></pre><p>matches the patterns p1, &hellip;, pn in the order they are written against the selectorvalue e.</p>
<ul>
<li>
<p>A constructor pattern C (p1, &hellip;, pn) matches all values that are of type C (or asubtype thereof) and that have been constructed with C-arguments matchingpatterns p1, &hellip;, pn.</p>
</li>
<li>
<p>A variable pattern x matches any value and binds the variable name to thatvalue.</p>
</li>
<li>
<p>The wildcard pattern ‘_’ matches any value but does not bind a name to thatvalue.</p>
</li>
<li>
<p>A constant pattern C matches a value which is equal (in terms of ==) to C.</p>
</li>
</ul>
<p>The pattern matching expression rewrites to the right-hand-side of the ﬁrst case whose pattern matches the selector value. References to pattern variables are re- placed by corresponding constructor arguments. If none of the patterns matches, the pattern matching expression is aborted with a MatchError exception.</p>
<p><strong>Example 7.2.1</strong> Our substitution model of program evaluation extends quite naturally to pattern matching, For instance, here is how eval applied to a simple expression is re-written:</p>
<pre><code>    eval(Sum(Number(1), Number(2)))

-&gt;           (by rewriting the application)
    Sum(Number(1), Number(2)) match {
	   case Number(n) =&gt; n
	   case Sum(e1, e2) =&gt; eval(e1) + eval(e2)
    }
-&gt;           (by rewriting the pattern match)
    eval(Number(1)) + eval(Number(2))
-&gt;           (by rewriting the ﬁrst application)
    Number(1) match {
		case Number(n) =&gt; n
		case Sum(e1, e2) =&gt; eval(e1) + eval(e2)
	} + eval(Number(2))
-&gt;           (by rewriting the pattern match)
     1 + eval(Number(2))
-&gt;∗  1 + 2 -&gt; 3
</code></pre><p><strong>Pattern Matching and Methods.</strong> In the previous example, we have used pattern matching in a function which was deﬁned outside the class hierarchy over which it matches. Of course, it is also possible to deﬁne a pattern matching function in that class hierarchy itself. For instance, we could have deﬁned eval is a method of the base class Expr, and still have used pattern matching in its implementation:</p>
<pre><code>abstract class Expr {
	def eval: Int = this match {
		case Number(n) =&gt; n
		case Sum(e1, e2) =&gt; e1.eval + e2.eval
	}
}
</code></pre><p>Exercise 7.2.2 Consider the following deﬁnitions representing trees of integers.These deﬁnitions can be seen as an alternative representation of IntSet:</p>
<pre><code>abstract class IntTree
case object EmptyTree extends IntTree
case class Node(elem: Int, left: IntTree, right: IntTree) extends IntTree
</code></pre><p>Complete the following implementations of function contains and insert forIntTree’s.</p>
<pre><code>def contains(t: IntTree, v: Int): Boolean = t match { ...
	...
}
def insert(t: IntTree, v: Int): IntTree = t match { ...
	...
}
</code></pre><p><strong>Pattern Matching Anonymous Functions.</strong> So far, case-expressions always ap-peared in conjunction with a match operation. But it is also possible to use case-expressions by themselves. A block of case-expressions such as</p>
<pre><code>{ case P1 =&gt; E1 ... case Pn =&gt; En }
</code></pre><p>is seen by itself as a function which matches its arguments against the patternsP1, &hellip;, Pn, and produces the result of one of E1, &hellip;, En. (If no pattern matches, thefunction would throw a MatchError exception instead). In other words, the expres-sion above is seen as a shorthand for the anonymous function</p>
<pre><code>(x =&gt; x match { case P1 =&gt; E1 ... case Pn =&gt; En })
</code></pre><p>where x is a fresh variable which is not used otherwise in the expression.</p>
<h2 id="generic-types-and-methods">Generic Types and Methods</h2>
<p>Classes in Scala can have type parameters. We demonstrate the use of type parame- ters with functional stacks as an example. Say, we want to write a data type of stacks of integers, with methods push, top, pop, and isEmpty. This is achieved by the fol- lowing class hierarchy:</p>
<pre><code>abstract class IntStack {
	def push(x: Int): IntStack = new IntNonEmptyStack(x, this)
	def isEmpty: Boolean
	def top: Int
	def pop: IntStack
}
class IntEmptyStack extends IntStack {
	def isEmpty = true
	def top = error(&quot;EmptyStack.top&quot;)
	def pop = error(&quot;EmptyStack.pop&quot;)
}
class IntNonEmptyStack(elem: Int, rest: IntStack) extends IntStack {
	def isEmpty = false
	def top = elem
	def pop = rest
}
</code></pre><p>Of course, it would also make sense to deﬁne an abstraction for a stack of Strings. To do that, one could take the existing abstraction for <code>IntStack</code>, rename it to <code>StringStack</code> and at the same time rename all occurrences of type Int to String. A better way, which does not entail code duplication, is to parameterize the stack deﬁnitions with the element type. Parameterization lets us generalize from a speciﬁc instance of a problem to a more general one. So far, we have used parameterization only for values, but it is available also for types. To arrive at a generic version of Stack, we equip it with a type parameter.</p>
<pre><code>abstract class Stack[A] {
	def push(x: A): Stack[A] = new NonEmptyStackA
	def isEmpty: Boolean
	def top: A
	def pop: Stack[A]
}
class EmptyStack[A] extends Stack[A] {
	def isEmpty = true
	def top = error(&quot;EmptyStack.top&quot;)
	def pop = error(&quot;EmptyStack.pop&quot;)
}
class NonEmptyStackA extends Stack[A] {
	def isEmpty = false
	def top = elem
	def pop = rest
}
</code></pre><p>In the deﬁnitions above, ‘A’ is a type parameter of class Stack and its subclasses.Type parameters are arbitrary names; they are enclosed in brackets instead of parentheses, so that they can be easily distinguished from value parameters. Here is an example how the generic classes are used:</p>
<pre><code>val x = new EmptyStack[Int]
val y = x.push(1).push(2)
println(y.pop.top)
</code></pre><p>The ﬁrst line creates a new empty stack of Int’s. Note the actual type argument[Int] which replaces the formal type parameter A.
It is also possible to parameterize methods with types. As an example, here is ageneric method which determines whether one stack is a preﬁx of another.</p>
<pre><code>def isPrefixA: Boolean = {
	p.isEmpty ||
	p.top == s.top &amp;&amp; isPrefixA
}
</code></pre><p>The method parameters are called polymorphic. Generic methods are also called <strong>polymorphic</strong>. The term comes from the Greek, where it means “having many forms”.To apply a polymorphic method such as isPrefix, we pass type parameters as wellas value parameters to it. For instance,</p>
<pre><code>val s1 = new EmptyStack[String].push(&quot;abc&quot;)
val s2 = new EmptyStack[String].push(&quot;abx&quot;).push(s1.top)
println(isPrefixString)
</code></pre><p><strong>Local Type Inference.</strong> Passing type parameters such as [Int] or [String] all the time can become tedious in applications where generic functions are used a lot. Quite often, the information in a type parameter is redundant, because the correct parameter type can also be determined by inspecting the function’s value parame- ters or expected result type. Taking the expression isPrefixString as an example, we know that its value parameters are both of type Stack[String], so we can deduce that the type parameter must be String. Scala has a fairly powerful type inferencer which allows one to omit type parameters to polymorphic functions and constructors in situations like these. In the example above, one could have writ- ten isPrefix(s1, s2) and the missing type argument [String] would have been inserted by the type inferencer.</p>
<h3 id="81-type-parameter-bounds">8.1 Type Parameter Bounds</h3>
<p>Now that we know how to make classes generic it is natural to generalize some of the earlier classes we have written. For instance class IntSet could be generalized to sets with arbitrary element types. Let’s try. The abstract class for generic sets is easily written.</p>
<pre><code>abstract class Set[A] {
	def incl(x: A): Set[A]
	def contains(x: A): Boolean
}
</code></pre><p>However, if we still want to implement sets as binary search trees, we encounter a problem. The contains and incl methods both compare elements using methods &lt; and &gt;. For IntSet this was OK, since type Int has these two methods. But for an arbitrary type parameter a, we cannot guarantee this. Therefore, the previous implementation of, say, contains would generate a compiler error.</p>
<pre><code>def contains(x: Int): Boolean =
	if (x &lt; elem) left contains x
		^ &lt; not a member of type A.
</code></pre><p>One way to solve the problem is to restrict the legal types that can be substituted for type A to only those types that contain methods &lt; and &gt; of the correct types. There is a trait Ordered[A] in the standard class library Scala which represents values which are comparable (via &lt; and &gt;) to values of type A. This trait is deﬁned as follows:</p>
<pre><code>/** A class for totally ordered data. */
trait Ordered[A] {
   /** Result of comparing ‘this’ with operand ‘that’.
	* returns ‘x’ where
	* x &lt; 0     iff    this &lt; that
	* x == 0    iff    this == that 
	* x &gt; 0    iff    this &gt; that
	*/
	def compare(that: A): Int
	def &lt; (that: A): Boolean = (this compare that) &lt; 0
	def &gt; (that: A): Boolean = (this compare that) &gt; 0
	def &lt;= (that: A): Boolean = (this compare that) &lt;= 0
	def &gt;= (that: A): Boolean = (this compare that) &gt;= 0
	def compareTo(that: A): Int = compare(that)
}
</code></pre><p>We can enforce the comparability of a type by demanding that the type is a subtype of Ordered. This is done by giving an upper bound to the type parameter of Set:</p>
<pre><code>trait Set[A &lt;: Ordered[A]] {
    def incl(x: A): Set[A]
    def contains(x: A): Boolean
}
</code></pre><p>The parameter declaration A &lt;: Ordered[A] introduces A as a type parameter which must be a subtype of Ordered[A], i.e. its values must be comparable to values of the same type.</p>
<p>With this restriction, we can now implement the rest of the generic set abstraction as we did in the case of IntSets before.</p>
<pre><code>class EmptySet[A &lt;: Ordered[A]] extends Set[A] {
	def contains(x: A): Boolean = false
	def incl(x: A): Set[A] = new NonEmptySet(x, new EmptySet[A], new EmptySet[A])}
class NonEmptySet[A &lt;: Ordered[A]]
			(elem: A, left: Set[A], right: Set[A]) extends Set[A] {
	def contains(x: A): Boolean =
		if (x &lt; elem) left contains x
		else if (x &gt; elem) right contains x
		else true
	def incl(x: A): Set[A] =
		if (x &lt; elem) new NonEmptySet(elem, left incl x, right)
		else if (x &gt; elem) new NonEmptySet(elem, left, right incl x)
		else this
}
</code></pre><p>Note that we have left out in the object creations <code>new NonEmptySet(...)</code>. In the same way as for polymorphic methods, missing type arguments in constructor calls are inferred from value arguments and/or the ex-the type argument pected result type. Here is an example that uses the generic set abstraction. Let’s ﬁrst create a subclass of Ordered, like this:</p>
<pre><code>case class Num(value: Double) extends Ordered[Num] {
	def compare(that: Num): Int =
		if (this.value &lt; that.value) -1
		else if (this.value &gt; that.value) 1
		else 0
}
</code></pre><p>Then:</p>
<pre><code>val s = new EmptySet[Num].incl(Num(1.0)).incl(Num(2.0))
s.contains(Num(1.5))
</code></pre><p>This is OK, as type Num implements the trait Ordered[Num]. However, the following example is in error.</p>
<pre><code>val s = new EmptySet[java.io.File]
                    ^ java.io.File does not conform to type
                    parameter bound Ordered[java.io.File].
</code></pre><p>One probem with type parameter bounds is that they require forethought: if we had not declared Num a subclass of Ordered, we would not have been able to use Num elements in sets. By the same token, types inherited from Java, such as Int, Double, or String are not subclasses of Ordered, so values of these types cannot be used as set elements. A more ﬂexible design, which admits elements of these types, uses view bounds in- stead of the plain type bounds we have seen so far. The only change this entails in the example above is in the type parameters:</p>
<pre><code>trait Set[A &lt;% Ordered[A]] ...
class EmptySet[A &lt;% Ordered[A]] ...
class NonEmptySet[A &lt;% Ordered[A]] ...
</code></pre><p>View bounds &lt;% are weaker than plain bounds &lt;:: A view bounded type parameter clause [A &lt;% T] only speciﬁes that the bounded type A must be convertible to the bound type T, using an implicit conversion.</p>
<p>The Scala library predeﬁnes implicit conversions for a number of types, including the primitive types and String. Therefore, the redesign set abstraction can be in- stantiated with these types as well. More explanations on implicit conversions and view bounds are given in Section 15.</p>
<h3 id="82-variance-annotations">8.2 Variance Annotations</h3>
<p>The combination of type parameters and subtyping poses some interesting ques-tions. For instance, should Stack[String] be a subtype of Stack[AnyRef]? Intu-itively, this seems OK, since a stack of Strings is a special case of a stack of AnyRefs.More generally, if T is a subtype of type S then Stack[T] should be a subtype ofStack[S]. This property is called co-variant subtyping.</p>
<p>In Scala, generic types have by default non-variant subtyping. That is, with Stackdeﬁned as above, stacks with different element types would never be in a subtyperelation. However, we can enforce co-variant subtyping of stacks by changing the ﬁrst line of the deﬁnition of class Stack as follows.</p>
<pre><code>class Stack[+A] {
</code></pre><p>Preﬁxing a formal type parameter with a + indicates that subtyping is covariant inthat parameter. Besides +, there is also a preﬁx - which indicates contra-variantsubtyping. If Stack was deﬁned class Stack[-A] &hellip;, then T a subtype of type Swould imply that Stack[S] is a subtype of Stack[T] (which in the case of stackswould be rather surprising!).</p>
<p>In a purely functional world, all types could be co-variant. However, the situationchanges once we introduce mutable data. Consider the case of arrays in Java or.NET. Such arrays are represented in Scala by a generic class Array. Here is a partialdeﬁnition of this class.</p>
<pre><code>class Array[A] {
	def apply(index: Int): A
	def update(index: Int, elem: A)
}
</code></pre><p>The class above deﬁnes the way Scala arrays are seen from Scala user programs. The Scala compiler will map this abstraction to the underlying arrays of the host system in most cases where this possible.</p>
<p>In Java, arrays are indeed covariant; that is, for reference types T and S, if T is a sub-type of S, then also Array[T] is a subtype of Array[S]. This might seem natural butleads to safety problems that require special runtime checks. Here is an example:</p>
<pre><code>val x = new ArrayString
val y: Array[Any] = x
y(0) = new Rational(1, 2) // this is syntactic sugar for
// y.update(0, new Rational(1, 2))
</code></pre><p>In the ﬁrst line, a new array of strings is created. In the second line, this array is bound to a variable y, of type Array[Any]. Assuming arrays are covariant, this is OK,since Array[String] is a subtype of Array[Any]. Finally, in the last line a rational number is stored in the array. This is also OK, since type Rational is a subtype of the element type Any of the array y. We thus end up storing a rational number in an array of strings, which clearly violates type soundness.</p>
<p>Java solves this problem by introducing a run-time check in the third line which tests whether the stored element is compatible with the element type with which the array was created. We have seen in the example that this element type is not necessarily the static element type of the array being updated. If the test fails, an ArrayStoreException is raised.</p>
<p>Scala solves this problem instead statically, by disallowing the second line at compile-time, because arrays in Scala have non-variant subtyping. This raises the question how a Scala compiler veriﬁes that variance annotations are correct. If we had simply declared arrays co-variant, how would the potential problem have been detected?</p>
<p>Scala uses a conservative approximation to verify soundness of variance annota- tions. A covariant type parameter of a class may only appear in co-variant posi- tions inside the class. Among the co-variant positions are the types of values in the class, the result types of methods in the class, and type arguments to other covariant types. Not co-variant are types of formal method parameters. Hence, the following class deﬁnition would have been rejected</p>
<pre><code>class Array[+A] {
	def apply(index: Int): A
	def update(index: Int, elem: A)
	                             ^ covariant type parameter A
	                             appears in contravariant position.
}
</code></pre><p>So far, so good. Intuitively, the compiler was correct in rejecting the update procedure in a co-variant class because update potentially changes state, and therefore undermines the soundness of co-variant subtyping. However, there are also methods which do not mutate state, but where a type pa- rameter still appears contra-variantly. An example is push in type Stack. Again the Scala compiler will reject the deﬁnition of this method for co-variant stacks.</p>
<pre><code>class Stack[+A] {
	def push(x: A): Stack[A] =
                ^ covariant type parameter A
                appears in contravariant position.
</code></pre><p>This is a pity, because, unlike arrays, stacks are purely functional data structures and therefore should enable co-variant subtyping. However, there is a a way to solve the problem by using a polymorphic method with a lower type parameter bound.</p>
<h3 id="83-lower-bounds">8.3 Lower Bounds</h3>
<p>We have seen upper bounds for type parameters. In a type parameter declarationsuch as T &lt;: U, the type parameter T is restricted to range only over subtypes of typeU. Symmetrical to this are lower bounds in Scala. In a type parameter declarationT &gt;: S, the type parameter T is restricted to range only over supertypes of type S.(One can also combine lower and upper bounds, as in T &gt;: S &lt;: U.)</p>
<p>Using lower bounds, we can generalize the push method in Stack as follows.</p>
<pre><code>class Stack[+A] {
	def pushB &gt;: A: Stack[B] = new NonEmptyStack(x, this)
</code></pre><p>Technically, this solves our variance problem since now the type parameter A ap-pears no longer as a parameter type of method push. Instead, it appears as lowerbound for another type parameter of a method, which is classiﬁed as a co-variantposition. Hence, the Scala compiler accepts the new deﬁnition of push.</p>
<p>In fact, we have not only solved the technical variance problem but also have gen-eralized the deﬁnition of push. Before, we were required to push only elements withtypes that conform to the declared element type of the stack. Now, we can push alsoelements of a supertype of this type, but the type of the returned stack will changeaccordingly. For instance, we can now push an AnyRef onto a stack of Strings, butthe resulting stack will be a stack of AnyRefs instead of a stack of Strings!</p>
<p>In summary, one should not hesitate to add variance annotations to your data struc-tures, as this yields rich natural subtyping relationships. The compiler will detectpotential soundness problems. Even if the compiler’s approximation is too conser-vative, as in the case of method push of class Stack, this will often suggest a usefulgeneralization of the contested method.</p>
<h3 id="84-least-types">8.4 Least Types</h3>
<p>Scala does not allow one to parameterize objects with types. That’s why we originally deﬁned a generic class EmptyStack[A], even though a single value denoting empty stacks of arbitrary type would do. For co-variant stacks, however, one canuse the following idiom:</p>
<pre><code>object EmptyStack extends Stack[Nothing] { ... }
</code></pre><p>The bottom type Nothing contains no value, so the type Stack[Nothing] expresses the fact that an EmptyStack contains no elements. Furthermore, Nothing is a sub-type of all other types. Hence, for co-variant stacks, Stack[Nothing] is a subtype ofStack[T], for any other type T. This makes it possible to use a single empty stackobject in user code. For instance:</p>
<pre><code>val s = EmptyStack.push(&quot;abc&quot;).push(new AnyRef())
</code></pre><p>Let’s analyze the type assignment for this expression in detail. The EmptyStack ob- ject is of type Stack[Nothing], which has a method</p>
<pre><code>pushB &gt;: Nothing: Stack[B] .
</code></pre><p>Local type inference will determine that the type parameter B should be instanti- ated to String in the application EmptyStack.push(&ldquo;abc&rdquo;). The result type of that application is hence Stack[String], which in turn has a method</p>
<pre><code class="language-\" data-lang="\">pushB &gt;: String: Stack[B] .
</code></pre><p>The ﬁnal part of the value deﬁnition above is the application of this method to new AnyRef(). Local type inference will determine that the type parameter b should this time be instantiated to AnyRef, with result type Stack[AnyRef]. Hence, the type assigned to value s is Stack[AnyRef]. Besides Nothing, which is a subtype of every other type, there is also the type Null, which is a subtype of scala.AnyRef, and every class derived from it. The null lit- eral in Scala is the only value of that type. This makes null compatible with every reference type, but not with a value type such as Int. We conclude this section with the complete improved deﬁnition of stacks. Stacks have now co-variant subtyping, the push method has been generalized, and the empty stack is represented by a single object.</p>
<pre><code>abstract class Stack[+A] {
	def pushB &gt;: A: Stack[B] = new NonEmptyStack(x, this)
	def isEmpty: Boolean
	def top: A
	def pop: Stack[A]
}
object EmptyStack extends Stack[Nothing] {
	def isEmpty = true
	def top = error(&quot;EmptyStack.top&quot;)
	def pop = error(&quot;EmptyStack.pop&quot;)
}
class NonEmptyStack+A extends Stack[A] {
	def isEmpty = false
	def top = elem
	def pop = rest
}
</code></pre><p>Many classes in the Scala library are generic. We now present two commonly used families of generic classes, tuples and functions. The discussion of another common class, lists, is deferred to the next chapter.</p>
<h3 id="85-tuples">8.5 Tuples</h3>
<p>Generic Types and MethodsSometimes, a function needs to return more than one result. For instance, take thefunction divmod which returns the integer quotient and rest of two given integerarguments. Of course, one can deﬁne a class to hold the two results of divmod, as in:</p>
<pre><code>case class TwoInts(first: Int, second: Int)
def divmod(x: Int, y: Int): TwoInts = new TwoInts(x / y, x % y)
</code></pre><p>However, having to deﬁne a new class for every possible pair of result types is verytedious. In Scala one can use instead a generic class Tuple2, which is deﬁned asfollows:</p>
<pre><code>package scala
case class Tuple2[A, B](_1: A, _2: B)
</code></pre><p>With Tuple2, the divmod method can be written as follows.</p>
<pre><code>def divmod(x: Int, y: Int) = new Tuple2[Int, Int](x / y, x % y)
</code></pre><p>As usual, type parameters to constructors can be omitted if they are deducible fromvalue arguments. There exist also tuple classes for every other number of elements(the current Scala implementation limits this to tuples of some reasonable numberof elements).</p>
<p>How are elements of tuples accessed? Since tuples are case classes, there are twopossibilities. One can either access a tuple’s ﬁelds using the names of the construc-tor parameters _i , as in the following example:</p>
<pre><code>val xy = divmod(x, y)
println(&quot;quotient: &quot; + xy.1 + &quot;, rest: &quot; + xy.2)
</code></pre><p>Or one uses pattern matching on tuples, as in the following example:</p>
<pre><code>divmod(x, y) match {
    case Tuple2(n, d) =&gt;
    	println(&quot;quotient: &quot; + n + &quot;, rest: &quot; + d)
}

</code></pre><p>Note that type parameters are never used in patterns; it would have been illegal towrite <code>case Tuple2[Int, Int](n, d)</code>.</p>
<p>Tuples are so convenient that Scala deﬁnes special syntax for them. To form atuple with n elements x1, &hellip;, xn one can write (x1, &hellip;, xn). This is equivalent toTuplen(x1, &hellip;, xn). The (&hellip;) syntax works equivalently for types and for patterns.With that tuple syntax, the divmod example is written as follows:</p>
<pre><code>def divmod(x: Int, y: Int): (Int, Int) = (x / y, x % y)

divmod(x, y) match {
	case (n, d) =&gt; println(&quot;quotient: &quot; + n + &quot;, rest: &quot; + d)
}

</code></pre><h3 id="86-functions">8.6 Functions</h3>
<p>Scala is a functional language in that functions are ﬁrst-class values. Scala is also an object-oriented language in that every value is an object. It follows that functions are objects in Scala. For instance, a function from type String to type Int is represented as an instance of the trait Function1[String, Int]. The Function1 trait is deﬁned as follows.</p>
<pre><code>package scala
trait Function1[-A, +B] {
    def apply(x: A): B
}
</code></pre><p>Besides Function1, there are also deﬁnitions of for functions of all other arities (the current implementation implements this only up to a reasonable limit). That is, there is one deﬁnition for each possible number of function parameters. Scala’s function type syntax (T1, &hellip;, Tn) =&gt; S is simply an abbreviation for the parame- terized type Functionn[T1, &hellip;, Tn,S] . Scala uses the same syntax f (x) for function application, no matter whether f is a method or a function object. This is made possible by the following convention: A function application f (x) where f is an object (as opposed to a method) is taken to be a shorthand for f .apply(x). Hence, the apply method of a function type is inserted automatically where this is necessary. That’s also why we deﬁned array subscripting in Section 8.2 by an apply method. For any array a, the subscript operation a(i) is taken to be a shorthand for a.apply(i). Functions are an example where a contra-variant type parameter declaration is use- ful. For example, consider the following code:</p>
<pre><code>val f: (AnyRef =&gt; Int) = x =&gt; x.hashCode()
val g: (String =&gt; Int) = f
g(&quot;abc&quot;)
</code></pre><p>It’s sound to bind the value g of type String =&gt; Int to f, which is of type AnyRef =&gt; Int. Indeed, all one can do with function of type String =&gt; Int is pass it a string in order to obtain an integer. Clearly, the same works for function f: If we pass it a string (or any other object), we obtain an integer. This demonstrates that function subtyping is contra-variant in its argument type whereas it is covariant in its result type. In short, S ⇒ T is a subtype of $S^{'}$ ⇒ $T^{'}$ , provided $S^{'}$  is a subtype of S and T is a subtype of $T^{'}$.</p>
<p><strong>Example 8.6.1</strong> Consider the Scala code</p>
<pre><code>val plus1: (Int =&gt; Int) = (x: Int) =&gt; x + 1
plus1(2)
</code></pre><p>This is expanded into the following object code.</p>
<pre><code>val plus1: Function1[Int, Int] = new Function1[Int, Int] {
	def apply(x: Int): Int = x + 1
}
plus1.apply(2)
</code></pre><p>Here, the object creation new Function1[Int, Int]{ &hellip; } represents an instanceof an anonymous class. It combines the creation of a new Function1 object with an implementation of the apply method (which is abstract in Function1). Equivalently,but more verbosely, one could have used a local class:</p>
<pre><code>val plus1: Function1[Int, Int] = {
	class Local extends Function1[Int, Int] {
		def apply(x: Int): Int = x + 1
	}
	new Local: Function1[Int, Int]
}
plus1.apply(2)
</code></pre><h2 id="lists">Lists</h2>
<p>Lists are an important data structure in many Scala programs. A list containing the</p>
<p>elements x1, . . . , xn is written List(x1, &hellip;, xn). Examples are:</p>
<p>val fruit = List(&ldquo;apples&rdquo;, &ldquo;oranges&rdquo;, &ldquo;pears&rdquo;)</p>
<p>val nums = List(1, 2, 3, 4)</p>
<p>val diag3 = List(List(1, 0, 0), List(0, 1, 0), List(0, 0, 1))</p>
<p>val empty = List()</p>
<ul>
<li>
<p>Lists are similar to arrays in languages such as C or Java, but there are also three</p>
</li>
<li>
<p>important differences. First, lists are immutable. That is, elements of a list cannot</p>
</li>
<li>
<p>be changed by assignment. Second, lists have a recursive structure, whereas arrays</p>
</li>
<li>
<p>are ﬂat. Third, lists support a much richer set of operations than arrays usually do.</p>
</li>
</ul>
<h3 id="91-using-lists">9.1 Using Lists</h3>
<ul>
<li>
<p>The List type. Like arrays, lists are homogeneous. That is, the elements of a list all</p>
</li>
<li>
<p>have the same type. The type of a list with elements of type T is written List[T]</p>
</li>
<li>
<p>(compare to T[] in Java).</p>
</li>
</ul>
<p>val fruit: List[String]</p>
<p>val nums : List[Int]</p>
<p>val diag3: List[List[Int]] = List(List(1, 0, 0), List(0, 1, 0), List(0, 0, 1))val empty: List[Int]</p>
<p>= List(&ldquo;apples&rdquo;, &ldquo;oranges&rdquo;, &ldquo;pears&rdquo;)</p>
<p>= List(1, 2, 3, 4)</p>
<p>= List()</p>
<ul>
<li>
<p>List constructors. All lists are built from two more fundamental constructors, Nil</p>
</li>
<li>
<p>and :: (pronounced “cons”). Nil represents an empty list. The inﬁx operator ::</p>
</li>
<li>
<p>expresses list extension. That is, x :: xs represents a list whose ﬁrst element is x,</p>
</li>
<li>
<p>which is followed by (the elements of) list xs. Hence, the list values above could also</p>
</li>
</ul>
<p>Listshave been deﬁned as follows (in fact their previous deﬁnition is simply syntacticsugar for the deﬁnitions below).</p>
<p>= 1 :: (2 :: (3 :: (4 :: Nil)))</p>
<p>val fruit = &ldquo;apples&rdquo; :: (&ldquo;oranges&rdquo; :: (&ldquo;pears&rdquo; :: Nil))</p>
<p>val nums</p>
<p>val diag3 = (1 :: (0 :: (0 :: Nil))) ::</p>
<p>(0 :: (1 :: (0 :: Nil))) ::</p>
<p>(0 :: (0 :: (1 :: Nil))) :: Nil</p>
<p>val empty = Nil</p>
<p>The ‘::’ operation associates to the right:</p>
<p>A :: B :: C is interpreted asA :: (B :: C). Therefore, we can drop the parentheses in the deﬁnitions above.For instance, we can write shorter</p>
<p>val nums = 1 :: 2 :: 3 :: 4 :: Nil</p>
<p>Basic operations on lists. All operations on lists can be expressed in terms of thefollowing three:</p>
<p>head</p>
<p>tail</p>
<p>isEmpty</p>
<p>returns the ﬁrst element of a list,</p>
<p>returns the list consisting of all elements except the</p>
<p>ﬁrst element,</p>
<p>returns true iff the list is empty</p>
<p>These operations are deﬁned as methods of list objects. So we invoke them by se-lecting from the list that’s operated on. Examples:</p>
<p>= true</p>
<p>empty.isEmpty</p>
<p>= false</p>
<p>fruit.isEmpty</p>
<p>fruit.head</p>
<p>= &ldquo;apples&rdquo;</p>
<p>fruit.tail.head = &ldquo;oranges&rdquo;</p>
<p>diag3.head</p>
<p>= List(1, 0, 0)</p>
<p>The head and tail methods are deﬁned only for non-empty lists. When selectedfrom an empty list, they throw an exception.</p>
<p>As an example of how lists can be processed, consider sorting the elements of a listof numbers into ascending order. One simple way to do so is insertion sort, whichworks as follows: To sort a non-empty list with ﬁrst element x and rest xs, sort theremainder xs and insert the element x at the right position in the result. Sorting anempty list will yield the empty list. Expressed as Scala code:</p>
<p>def isort(xs: List[Int]): List[Int] =</p>
<p>if (xs.isEmpty) Nil</p>
<p>else insert(xs.head, isort(xs.tail))</p>
<p>Exercise 9.1.1 Provide an implementation of the missing function insert.</p>
<ul>
<li>
<p>9.2 Deﬁnition of class List I: First Order Methods</p>
</li>
<li>
<p>List patterns.</p>
</li>
</ul>
<p>In fact, :: is deﬁned as a case class in Scala’s standard library.</p>
<ul>
<li>
<p>Hence, it is possible to decompose lists by pattern matching, using patterns com-</p>
</li>
<li>
<p>posed from the Nil and :: constructors. For instance, isort can be written alterna-</p>
</li>
<li>
<p>tively as follows.</p>
</li>
</ul>
<p>def isort(xs: List[Int]): List[Int] = xs match {</p>
<p>case List() =&gt; List()</p>
<p>case x :: xs1 =&gt; insert(x, isort(xs1))</p>
<p>}</p>
<ul>
<li>where</li>
</ul>
<p>def insert(x: Int, xs: List[Int]): List[Int] = xs match {</p>
<p>case List() =&gt; List(x)</p>
<p>case y :: ys =&gt; if (x &lt;= y) x :: xs else y :: insert(x, ys)</p>
<p>}</p>
<h3 id="92-deﬁnition-of-class-list-i-first-order-methods">9.2 Deﬁnition of class List I: First Order Methods</h3>
<ul>
<li>
<p>Lists are not built in in Scala; they are deﬁned by an abstract class List, which comes</p>
</li>
<li>
<p>with two subclasses for :: and Nil. In the following we present a tour through class</p>
</li>
<li>
<p>List.</p>
</li>
</ul>
<p>package scala</p>
<p>abstract class List[+A] {</p>
<ul>
<li>
<p>List is an abstract class, so one cannot deﬁne elements by calling the empty List</p>
</li>
<li>
<p>constructor (e.g. by new List). The class has a type parameter a. It is co-variant</p>
</li>
<li>
<p>in this parameter, which means that List[S] &lt;: List[T] for all types S and T such</p>
</li>
<li>
<p>that S &lt;: T. The class is situated in the package scala. This is a package containing</p>
</li>
<li>
<p>the most important standard classes of Scala. List deﬁnes a number of methods,</p>
</li>
<li>
<p>which are explained in the following.</p>
</li>
<li>
<p>Decomposing lists. First, there are the three basic methods isEmpty, head, tail.</p>
</li>
<li>
<p>Their implementation in terms of pattern matching is straightforward:</p>
</li>
</ul>
<p>def isEmpty: Boolean = this match {</p>
<p>case Nil =&gt; true</p>
<p>case x :: xs =&gt; false</p>
<p>}</p>
<p>def head: A = this match {</p>
<p>case Nil =&gt; error(&ldquo;Nil.head&rdquo;)</p>
<p>case x :: xs =&gt; x</p>
<p>}</p>
<p>def tail: List[A] = this match {</p>
<p>Lists}</p>
<p>case Nil =&gt; error(&ldquo;Nil.tail&rdquo;)</p>
<p>case x :: xs =&gt; xs</p>
<p>The next function computes the length of a list.</p>
<p>def length: Int = this match {</p>
<p>case Nil =&gt; 0</p>
<p>case x :: xs =&gt; 1 + xs.length</p>
<p>}</p>
<p>Exercise 9.2.1 Design a tail-recursive version of length.</p>
<p>The next two functions are the complements of head and tail.</p>
<p>def last: A</p>
<p>def init: List[A]</p>
<p>xs.last returns the last element of list xs, whereas xs.init returns all elements ofxs except the last. Both functions have to traverse the entire list, and are thus lessefﬁcient than their head and tail analogues. Here is the implementation of last.</p>
<p>def last: A = this match {</p>
<p>=&gt; error(&ldquo;Nil.last&rdquo;)</p>
<p>case Nil</p>
<p>case x :: Nil =&gt; x</p>
<p>case x :: xs =&gt; xs.last</p>
<p>}</p>
<p>The implementation of init is analogous.</p>
<p>The next three functions return a preﬁx of the list, or a sufﬁx, or both.</p>
<p>def take(n: Int): List[A] =</p>
<p>if (n == 0 || isEmpty) Nil else head :: tail.take(n-1)</p>
<p>def drop(n: Int): List[A] =</p>
<p>if (n == 0 || isEmpty) this else tail.drop(n-1)</p>
<p>def split(n: Int): (List[A], List[A]) = (take(n), drop(n))</p>
<p>(xs take n) returns the ﬁrst n elements of list xs, or the whole list, if its length issmaller than n. (xs drop n) returns all elements of xs except the n ﬁrst ones. Fi-nally, (xs split n) returns a pair consisting of the lists resulting from xs take nand xs drop n.</p>
<p>The next function returns an element at a given index in a list. It is thus analogousto array subscripting. Indices start at 0.</p>
<ul>
<li>9.2 Deﬁnition of class List I: First Order Methods</li>
</ul>
<p>def apply(n: Int): A = drop(n).head</p>
<ul>
<li>
<p>The apply method has a special meaning in Scala. An object with an apply method</p>
</li>
<li>
<p>can be applied to arguments as if it was a function. For instance, to pick the 3’rd</p>
</li>
<li>
<p>element of a list xs, one can write either xs.apply(3) or xs(3) – the latter expression</p>
</li>
<li>
<p>expands into the ﬁrst.</p>
</li>
<li>
<p>With take and drop, we can extract sublists consisting of consecutive elements of</p>
</li>
<li>
<p>the original list. To extract the sublist xsm, &hellip;, xsn−1 of a list xs, use:</p>
</li>
</ul>
<p>xs.drop(m).take(n - m)</p>
<ul>
<li>
<p>Zipping lists. The next function combines two lists into a list of pairs. Given two</p>
</li>
<li>
<p>lists</p>
</li>
</ul>
<p>xs = List(x1, &hellip;, xn)</p>
<p>ys = List(y1, &hellip;, yn)</p>
<p>, and</p>
<p>,</p>
<ul>
<li>
<p>xs zip ys constructs the list List((x1, y1), &hellip;, (xn, yn)). If the two lists have</p>
</li>
<li>
<p>different lengths, the longer one of the two is truncated. Here is the deﬁnition of zip</p>
</li>
<li>
<p>– note that it is a polymorphic method.</p>
</li>
</ul>
<p>def zip[B](that: List[B]): List[(a,b)] =</p>
<p>if (this.isEmpty || that.isEmpty) Nil</p>
<p>else (this.head, that.head) :: (this.tail zip that.tail)</p>
<ul>
<li>
<p>Consing lists.. Like any inﬁx operator, :: is also implemented as a method of an</p>
</li>
<li>
<p>object. In this case, the object is the list that is extended. This is possible, because</p>
</li>
<li>
<p>operators ending with a ‘:’ character are treated specially in Scala. All such opera-</p>
</li>
<li>
<p>tors are treated as methods of their right operand. E.g.,</p>
</li>
</ul>
<p>x :: y = y.::(x)</p>
<p>whereas</p>
<p>x + y = x.+(y)</p>
<ul>
<li>
<p>Note, however, that operands of a binary operation are in each case evaluated from</p>
</li>
<li>
<p>left to right. So, if D and E are expressions with possible side-effects, D :: E is</p>
</li>
<li>
<p>translated to {val x = D; E.::(x)} in order to maintain the left-to-right order of</p>
</li>
<li>
<p>operand evaluation.</p>
</li>
<li>
<p>Another difference between operators ending in a ‘:’ and other operators concerns</p>
</li>
<li>
<p>their associativity. Operators ending in ‘:’ are right-associative, whereas other op-</p>
</li>
<li>
<p>erators are left-associative. E.g.,</p>
</li>
</ul>
<p>x :: y :: z = x :: (y :: z) whereas</p>
<p>x + y + z = (x + y) + z</p>
<ul>
<li>The deﬁnition of :: as a method in class List is as follows:</li>
</ul>
<p>Listsdef ::[B &gt;: A](x: B): List[B] = new scala.::(x, this)</p>
<p>Note that :: is deﬁned for all elements x of type B and lists of type List[A] such thatthe type B of x is a supertype of the list’s element type A. The result is in this case a listof B’s. This is expressed by the type parameter B with lower bound A in the signatureof ::.</p>
<p>Concatenating lists. An operation similar to :: is list concatenation, written ‘:::’.The result of (xs ::: ys) is a list consisting of all elements of xs, followed by allelements of ys. Because it ends in a colon, ::: is right-associative and is consideredas a method of its right-hand operand. Therefore,</p>
<p>xs ::: ys ::: zs =</p>
<p>=</p>
<p>xs ::: (ys ::: zs)</p>
<p>zs.:::(ys).:::(xs)</p>
<p>Here is the implementation of the ::: method:</p>
<p>def :::[B &gt;: A](prefix: List[B]): List[B] = prefix match {</p>
<p>case Nil =&gt; this</p>
<p>case p :: ps =&gt; this.:::(ps).::(p)</p>
<p>}</p>
<p>Reversing lists. Another useful operation is list reversal. There is a methodreverse in List to that effect. Let’s try to give its implementation:</p>
<p>def reverse[A](xs: List[A]): List[A] = xs match {</p>
<p>case Nil =&gt; Nil</p>
<p>case x :: xs =&gt; reverse(xs) ::: List(x)</p>
<p>}</p>
<p>This implementation has the advantage of being simple, but it is not very efﬁcient.Indeed, one concatenation is executed for every element in the list. List concatena-tion takes time proportional to the length of its ﬁrst operand. Therefore, the com-plexity of reverse(xs) is</p>
<p>n + (n − 1)+ &hellip;+ 1 = n(n + 1)/2</p>
<p>where n is the length of xs. Can reverse be implemented more efﬁciently? We willsee later that there exists another implementation which has only linear complexity.</p>
<h3 id="93-example-merge-sort">9.3 Example: Merge sort</h3>
<p>The insertion sort presented earlier in this chapter is simple to formulate, but alsonot very efﬁcient. It’s average complexity is proportional to the square of the length- 9.3 Example: Merge sort</p>
<ul>
<li>
<p>of the input list. We now design a program to sort the elements of a list which is</p>
</li>
<li>
<p>more efﬁcient than insertion sort. A good algorithm for this is merge sort, which</p>
</li>
<li>
<p>works as follows.</p>
</li>
<li>
<p>First, if the list has zero or one elements, it is already sorted, so one returns the</p>
</li>
<li>
<p>list unchanged. Longer lists are split into two sub-lists, each containing about half</p>
</li>
<li>
<p>the elements of the original list. Each sub-list is sorted by a recursive call to the sort</p>
</li>
<li>
<p>function, and the resulting two sorted lists are then combined in a merge operation.</p>
</li>
<li>
<p>For a general implementation of merge sort, we still have to specify the type of list</p>
</li>
<li>
<p>elements to be sorted, as well as the function to be used for the comparison of el-</p>
</li>
<li>
<p>ements. We obtain a function of maximal generality by passing these two items as</p>
</li>
<li>
<p>parameters. This leads to the following implementation.</p>
</li>
</ul>
<p>def msort[A](less: (A, A) =&gt; Boolean)(xs: List[A]): List[A] = {</p>
<p>def merge(xs1: List[A], xs2: List[A]): List[A] =</p>
<p>if (xs1.isEmpty) xs2</p>
<p>else if (xs2.isEmpty) xs1</p>
<p>else if (less(xs1.head, xs2.head)) xs1.head :: merge(xs1.tail, xs2)</p>
<p>else xs2.head :: merge(xs1, xs2.tail)</p>
<p>val n = xs.length/2</p>
<p>if (n == 0) xs</p>
<p>else merge(msort(less)(xs take n), msort(less)(xs drop n))</p>
<p>}</p>
<ul>
<li>
<p>The complexity of msort is O(N log (N )), where N is the length of the input list. To</p>
</li>
<li>
<p>see why, note that splitting a list in two and merging two sorted lists each take time</p>
</li>
<li>
<p>proportional to the length of the argument list(s). Each recursive call of msort halves</p>
</li>
<li>
<p>the number of elements in its input, so there are O(log (N )) consecutive recursive</p>
</li>
<li>
<p>calls until the base case of lists of length 1 is reached. However, for longer lists each</p>
</li>
<li>
<p>call spawns off two further calls. Adding everything up we obtain that at each of</p>
</li>
<li>
<p>the O(log (N )) call levels, every element of the original lists takes part in one split</p>
</li>
<li>
<p>operation and in one merge operation. Hence, every call level has a total cost pro-</p>
</li>
<li>
<p>portional to O(N ). Since there are O(log (N )) call levels, we obtain an overall cost</p>
</li>
<li>
<p>of O(N log (N )). That cost does not depend on the initial distribution of elements</p>
</li>
<li>
<p>in the list, so the worst case cost is the same as the average case cost. This makes</p>
</li>
<li>
<p>merge sort an attractive algorithm for sorting lists.</p>
</li>
<li>
<p>Here is an example how msort is used.</p>
</li>
</ul>
<p>msort((x: Int, y: Int) =&gt; x &lt; y)(List(5, 7, 1, 3))</p>
<ul>
<li>
<p>The deﬁnition of msort is curried, to make it easy to specialize it with particular</p>
</li>
<li>
<p>comparison functions. For instance,</p>
</li>
</ul>
<p>val intSort = msort((x: Int, y: Int) =&gt; x &lt; y)</p>
<p>val reverseSort = msort((x: Int, y: Int) =&gt; x &gt; y)</p>
<p>Lists</p>
<h3 id="94-deﬁnition-of-class-list-ii-higher-order-methods">9.4 Deﬁnition of class List II: Higher-Order Methods</h3>
<p>The examples encountered so far show that functions over lists often have similarstructures. We can identify several patterns of computation over lists, like:</p>
<p>• transforming every element of a list in some way.</p>
<p>• extracting from a list all elements satisfying a criterion.</p>
<p>• combine the elements of a list using some operator.</p>
<p>Functional programming languages enable programmers to write general functionswhich implement patterns like this by means of higher order functions. We nowdiscuss a set of commonly used higher-order functions, which are implemented asmethods in class List.</p>
<p>Mapping over lists. A common operation is to transform each element of a listand then return the lists of results. For instance, to scale each element of a list by agiven factor.</p>
<p>def scaleList(xs: List[Double], factor: Double): List[Double] = xs match {case Nil =&gt; xs</p>
<p>case x :: xs1 =&gt; x * factor :: scaleList(xs1, factor)</p>
<p>}</p>
<p>This pattern can be generalized to the map method of class List:</p>
<p>abstract class List[A] { &hellip;</p>
<p>def map[B](f: A =&gt; B): List[B] = this match {</p>
<p>case Nil =&gt; this</p>
<p>case x :: xs =&gt; f(x) :: xs.map(f)</p>
<p>}</p>
<p>Using map, scaleList can be more concisely written as follows.</p>
<p>def scaleList(xs: List[Double], factor: Double) =</p>
<p>xs map (x =&gt; x * factor)</p>
<p>As another example, consider the problem of returning a given column of a matrixwhich is represented as a list of rows, where each row is again a list. This is done bythe following function column.</p>
<p>def column[A](xs: List[List[A]], index: Int): List[A] =</p>
<p>xs map (row =&gt; row(index))</p>
<p>Closely related to map is the foreach method, which applies a given function to allelements of a list, but does not construct a list of results. The function is thus appliedonly for its side effect. foreach is deﬁned as follows.</p>
<ul>
<li>9.4 Deﬁnition of class List II: Higher-Order Methods</li>
</ul>
<p>def foreach(f: A =&gt; Unit) {</p>
<p>this match {</p>
<p>case Nil =&gt; ()</p>
<p>case x :: xs =&gt; f(x); xs.foreach(f)</p>
<p>}</p>
<p>}</p>
<ul>
<li>This function can be used for printing all elements of a list, for instance:</li>
</ul>
<p>xs foreach (x =&gt; println(x))</p>
<ul>
<li>
<p>Exercise 9.4.1 Consider a function which squares all elements of a list and re-</p>
</li>
<li>
<p>turns a list with the results. Complete the following two equivalent deﬁnitions of</p>
</li>
<li>
<p>squareList.</p>
</li>
</ul>
<p>def squareList(xs: List[Int]): List[Int] = xs match {</p>
<p>case List() =&gt; ??</p>
<p>case y :: ys =&gt; ??</p>
<p>}</p>
<p>def squareList(xs: List[Int]): List[Int] =</p>
<p>xs map ??</p>
<ul>
<li>
<p>Filtering Lists. Another common operation selects from a list all elements fulﬁll-</p>
</li>
<li>
<p>ing a given criterion. For instance, to return a list of all positive elements in some</p>
</li>
<li>
<p>given lists of integers:</p>
</li>
</ul>
<p>def posElems(xs: List[Int]): List[Int] = xs match {</p>
<p>case Nil =&gt; xs</p>
<p>case x :: xs1 =&gt; if (x &gt; 0) x :: posElems(xs1) else posElems(xs1)</p>
<p>}</p>
<ul>
<li>This pattern is generalized to the filter method of class List:</li>
</ul>
<p>def filter(p: A =&gt; Boolean): List[A] = this match {</p>
<p>case Nil =&gt; this</p>
<p>case x :: xs =&gt; if (p(x)) x :: xs.filter(p) else xs.filter(p)</p>
<p>}</p>
<ul>
<li>Using filter, posElems can be more concisely written as follows.</li>
</ul>
<p>def posElems(xs: List[Int]): List[Int] =</p>
<p>xs filter (x =&gt; x &gt; 0)</p>
<ul>
<li>
<p>An operation related to ﬁltering is testing whether all elements of a list satisfy a cer-</p>
</li>
<li>
<p>tain condition. Dually, one might also be interested in the question whether there</p>
</li>
</ul>
<p>Listsexists an element in a list that satisﬁes a certain condition. These operations areembodied in the higher-order functions forall and exists of class List.</p>
<p>def forall(p: A =&gt; Boolean): Boolean =</p>
<p>isEmpty || (p(head) &amp;&amp; (tail forall p))</p>
<p>def exists(p: A =&gt; Boolean): Boolean =</p>
<p>!isEmpty &amp;&amp; (p(head) || (tail exists p))</p>
<p>To illustrate the use of forall, consider the question of whether a number if prime.Remember that a number n is prime of it can be divided without remainder onlyby one and itself. The most direct translation of this deﬁnition would test that ndivided by all numbers from 2 up to and excluding itself gives a non-zero remainder.This list of numbers can be generated using a function List.range which is deﬁnedin object List as follows.</p>
<p>package scala</p>
<p>object List { &hellip;</p>
<p>def range(from: Int, end: Int): List[Int] =</p>
<p>if (from &gt;= end) Nil else from :: range(from + 1, end)</p>
<p>For example, List.range(2, n) generates the list of all integers from 2 up to andexcluding n. The function isPrime can now simply be deﬁned as follows.</p>
<p>def isPrime(n: Int) =</p>
<p>List.range(2, n) forall (x =&gt; n % x != 0)</p>
<p>We see that the mathematical deﬁnition of prime-ness has been translated directlyinto Scala code.</p>
<p>Exercise: Deﬁne forall and exists in terms of filter.</p>
<p>Folding and Reducing Lists. Another common operation is to combine the ele-ments of a list with some operator. For instance:</p>
<p>sum(List(x1, &hellip;, xn))</p>
<p>product(List(x1, &hellip;, xn))</p>
<p>= 0 + x1 + &hellip; + xn</p>
<p>= 1 * x1 * &hellip; * xn</p>
<p>Of course, we can implement both functions with a recursive scheme:</p>
<p>def sum(xs: List[Int]): Int = xs match {</p>
<p>case Nil =&gt; 0</p>
<p>case y :: ys =&gt; y + sum(ys)</p>
<p>}</p>
<p>def product(xs: List[Int]): Int = xs match {</p>
<p>case Nil =&gt; 1</p>
<p>case y :: ys =&gt; y * product(ys)</p>
<p>}</p>
<ul>
<li>
<p>9.4 Deﬁnition of class List II: Higher-Order Methods</p>
</li>
<li>
<p>But we can also use the generalization of this program scheme embodied in the</p>
</li>
<li>
<p>reduceLeft method of class List. This method inserts a given binary operator be-</p>
</li>
<li>
<p>tween adjacent elements of a given list. E.g.</p>
</li>
</ul>
<p>List(x1, &hellip;, xn).reduceLeft(op) = (&hellip;(x1 op x2) op &hellip; ) op xn</p>
<ul>
<li>Using reduceLeft, we can make the common pattern in sum and product apparent:</li>
</ul>
<p>def sum(xs: List[Int])</p>
<p>= (0 :: xs) reduceLeft {(x, y) =&gt; x + y}</p>
<p>def product(xs: List[Int]) = (1 :: xs) reduceLeft {(x, y) =&gt; x * y}</p>
<ul>
<li>Here is the implementation of reduceLeft.</li>
</ul>
<p>def reduceLeft(op: (A, A) =&gt; A): A = this match {</p>
<p>case Nil</p>
<p>case x :: xs =&gt; (xs foldLeft x)(op)</p>
<p>=&gt; error(&ldquo;Nil.reduceLeft&rdquo;)</p>
<p>}</p>
<p>def foldLeft[B](z: B)(op: (B, A) =&gt; B): B = this match {</p>
<p>case Nil =&gt; z</p>
<p>case x :: xs =&gt; (xs foldLeft op(z, x))(op)</p>
<p>}</p>
<p>}</p>
<ul>
<li>
<p>We see that the reduceLeft method is deﬁned in terms of another generally use-</p>
</li>
<li>
<p>ful method, foldLeft. The latter takes as additional parameter an accumulator z,</p>
</li>
<li>
<p>which is returned when foldLeft is applied on an empty list. That is,</p>
</li>
</ul>
<p>(List(x1, &hellip;, xn) foldLeft z)(op)</p>
<p>= (&hellip;(z op x1) op &hellip; ) op xn</p>
<ul>
<li>The sum and product methods can be deﬁned alternatively using foldLeft:</li>
</ul>
<p>def sum(xs: List[Int])</p>
<p>= (xs foldLeft 0) {(x, y) =&gt; x + y}</p>
<p>def product(xs: List[Int]) = (xs foldLeft 1) {(x, y) =&gt; x * y}</p>
<ul>
<li>
<p>FoldRight and ReduceRight. Applications of foldLeft and reduceLeft expand to</p>
</li>
<li>
<p>left-leaning trees.</p>
</li>
</ul>
<p>. They have duals foldRight and reduceRight, which produce</p>
<ul>
<li>right-leaning trees.</li>
</ul>
<p>= x1 op ( &hellip; (xn−1 op xn)&hellip;)</p>
<p>List(x1, &hellip;, xn).reduceRight(op)</p>
<p>(List(x1, &hellip;, xn) foldRight acc)(op) = x1 op ( &hellip; (xn op acc)&hellip;)</p>
<ul>
<li>These are deﬁned as follows.</li>
</ul>
<p>def reduceRight(op: (A, A) =&gt; A): A = this match {</p>
<p>case Nil =&gt; error(&ldquo;Nil.reduceRight&rdquo;)</p>
<p>case x :: Nil =&gt; x</p>
<p>case x :: xs =&gt; op(x, xs.reduceRight(op))</p>
<p>Lists}</p>
<p>def foldRight[B](z: B)(op: (A, B) =&gt; B): B = this match {</p>
<p>case Nil =&gt; z</p>
<p>case x :: xs =&gt; op(x, (xs foldRight z)(op))</p>
<p>}</p>
<p>Class List deﬁnes also two symbolic abbreviations for foldLeft and foldRight:</p>
<p>def /:[B](z: B)(f: (B, A) =&gt; B): B = foldLeft(z)(f)</p>
<p>def :[B](z: B)(f: (A, B) =&gt; B): B = foldRight(z)(f)</p>
<p>The method names picture the left/right leaning trees of the fold operations by for-ward or backward slashes. The : points in each case to the list argument whereasthe end of the slash points to the accumulator (or: zero) argument z. That is,</p>
<p>(z /: List(x1, &hellip;, xn))(op) = (&hellip;(z op x1) op &hellip; ) op xn</p>
<p>(List(x1, &hellip;, xn) :\ z)(op) = x1 op ( &hellip; (xn op z)&hellip;)</p>
<p>For associative and commutative operators, /: and :\ are equivalent (even thoughthere may be a difference in efﬁciency).</p>
<p>Exercise 9.4.2 Consider the problem of writing a function flatten, which takes alist of element lists as arguments. The result of flatten should be the concatenationof all element lists into a single list. Here is an implementation of this method interms of :.</p>
<p>def flatten[A](xs: List[List[A]]): List[A] =</p>
<p>(xs :\ (Nil: List[A])) {(x, xs) =&gt; x ::: xs}</p>
<p>Consider replacing the body of flatten by</p>
<p>((Nil: List[A]) /: xs) ((xs, x) =&gt; xs ::: x)</p>
<p>What would be the difference in asymptotic complexity between the two versionsof flatten?</p>
<p>In fact flatten is predeﬁned together with a set of other userful function in an ob-ject called List in the standatd Scala library. It can be accessed from user programby calling List.flatten. Note that flatten is not a method of class List – it wouldnot make sense there, since it applies only to lists of lists, not to all lists in general.</p>
<p>List Reversal Again. We have seen in Section 9.2 an implementation of methodreverse whose run-time was quadratic in the length of the list to be reversed. Wenow develop a new implementation of reverse, which has linear cost. The idea isto use a foldLeft operation based on the following program scheme.</p>
<p>class List[+A] { &hellip;</p>
<ul>
<li>9.4 Deﬁnition of class List II: Higher-Order Methods</li>
</ul>
<p>def reverse: List[A] = (z? /: this)(op?)</p>
<ul>
<li>It only remains to ﬁll in the z? and op? parts. Let’s try to deduce them from examples.</li>
</ul>
<p>Nil</p>
<p>= Nil.reverse</p>
<p>= (z /: Nil)(op)</p>
<p>= (Nil foldLeft z)(op)</p>
<p>= z</p>
<p>// by specification</p>
<p>// by the template for reverse</p>
<p>// by the definition of /:</p>
<p>// by definition of foldLeft</p>
<ul>
<li>
<p>Hence, z? must be Nil. To deduce the second operand, let’s study reversal of a list</p>
</li>
<li>
<p>of length one.</p>
</li>
</ul>
<p>List(x)</p>
<p>= List(x).reverse</p>
<p>= (Nil /: List(x))(op)</p>
<p>= (List(x) foldLeft Nil)(op) // by the definition of /:</p>
<p>= op(Nil, x)</p>
<p>// by definition of foldLeft</p>
<p>// by specification</p>
<p>// by the template for reverse, with z = Nil- Hence, op(Nil, x) equals List(x), which is the same as x :: Nil. This suggests</p>
<ul>
<li>
<p>to take as op the :: operator with its operands exchanged. Hence, we arrive at the</p>
</li>
<li>
<p>following implementation for reverse, which has linear complexity.</p>
</li>
</ul>
<p>def reverse: List[A] =</p>
<p>((Nil: List[A]) /: this) {(xs, x) =&gt; x :: xs}</p>
<ul>
<li>
<p>(Remark: The type annotation of Nil is necessary to make the type inferencer work.)</p>
</li>
<li>
<p>Exercise 9.4.3 Fill in the missing expressions to complete the following deﬁnitions</p>
</li>
<li>
<p>of some basic list-manipulation operations as fold operations.</p>
</li>
</ul>
<p>def mapFun[A, B](xs: List[A], f: A =&gt; B): List[B] =</p>
<p>(xs :\ List<a href="">B</a>){ ?? }</p>
<p>def lengthFun[A](xs: List[A]): int =</p>
<p>(0 /: xs){ ?? }</p>
<ul>
<li>
<p>Nested Mappings. We can employ higher-order list processing functions to ex-</p>
</li>
<li>
<p>press many computations that are normally expressed as nested loops in imperative</p>
</li>
<li>
<p>languages.</p>
</li>
<li>
<p>As an example, consider the following problem: Given a positive integer n, ﬁnd all</p>
</li>
<li>
<p>pairs of positive integers i and j , where 1 ≤ j &lt; i &lt; n such that i + j is prime. For</p>
</li>
</ul>
<p>instance, if n = 7, the pairs are</p>
<p>i</p>
<p>j</p>
<p>i + j</p>
<p>2 3 4 4 5 6 6</p>
<p>1 2 1 3 2 1 5</p>
<p>3 5 5 7 7 7 11</p>
<p>ListsA natural way to solve this problem consists of two steps. In a ﬁrst step, one gener-ates the sequence of all pairs (i , j ) of integers such that 1 ≤ j &lt; i &lt; n. In a secondstep one then ﬁlters from this sequence all pairs (i , j ) such that i + j is prime.</p>
<p>Looking at the ﬁrst step in more detail, a natural way to generate the sequence ofpairs consists of three sub-steps. First, generate all integers between 1 and n for i .</p>
<p>Second, for each integer i between 1 and n, generate the list of pairs (i ,1) up to(i ,i − 1). This can be achieved by a combination of range and map:</p>
<p>List.range(1, i) map (x =&gt; (i, x))</p>
<p>Finally, combine all sublists using foldRight with :::. Putting everything togethergives the following expression:</p>
<p>List.range(1, n)</p>
<p>.map(i =&gt; List.range(1, i).map(x =&gt; (i, x)))</p>
<p>.foldRight(List<a href="">(Int, Int)</a>) {(xs, ys) =&gt; xs ::: ys}</p>
<p>.filter(pair =&gt; isPrime(pair._1 + pair._2))</p>
<p>Flattening Maps. The combination of mapping and then concatenating sublistsresulting from the map is so common that we there is a special method for it in classList:</p>
<p>abstract class List[+A] { &hellip;</p>
<p>def flatMap[B](f: A =&gt; List[B]): List[B] = this match {</p>
<p>case Nil =&gt; Nil</p>
<p>case x :: xs =&gt; f(x) ::: (xs flatMap f)</p>
<p>}</p>
<p>}</p>
<p>With flatMap, the pairs-whose-sum-is-prime expression could have been writtenmore concisely as follows.</p>
<p>List.range(1, n)</p>
<p>.flatMap(i =&gt; List.range(1, i).map(x =&gt; (i, x)))</p>
<p>.filter(pair =&gt; isPrime(pair._1 + pair._2))</p>
<h3 id="95-summary">9.5 Summary</h3>
<p>This chapter has introduced lists as a fundamental data structure in programming.</p>
<p>Since lists are immutable, they are a common data type in functional programming</p>
<p>languages. They have a role comparable to arrays in imperative languages. How-</p>
<p>ever, the access patterns between arrays and lists are quite different. Where array</p>
<p>accessing is always done by indexing, this is much less common for lists. We have</p>
<p>seen that scala.List deﬁnes a method called apply for indexing however this oper-</p>
<p>ation is much more costly than in the case of arrays (linear as opposed to constant</p>
<p>time). Instead of indexing, lists are usually traversed recursively, where recursion</p>
<p>steps are usually based on a pattern match over the traversed list. There is also a</p>
<p>rich set of higher-order combinators which allow one to instantiate a set of prede-</p>
<p>ﬁned patterns of computations over lists.</p>
<p>Chapter 10</p>
<h2 id="for-comprehensions">For-Comprehensions</h2>
<p>The last chapter demonstrated that higher-order functions such as map, flatMap,</p>
<p>filter provide powerful constructions for dealing with lists. But sometimes the</p>
<p>level of abstraction required by these functions makes a program hard to under-</p>
<p>stand.</p>
<p>To help understandability, Scala has a special notation which simpliﬁes common</p>
<p>patterns of applications of higher-order functions. This notation builds a bridge</p>
<p>between set-comprehensions in mathematics and for-loops in imperative lan-</p>
<p>guages such as C or Java. It also closely resembles the query notation of relational</p>
<p>databases.</p>
<p>As a ﬁrst example, say we are given a list persons of persons with name and age ﬁelds.</p>
<p>To print the names of all persons in the sequence which are aged over 20, one can</p>
<p>write:</p>
<p>for (p &lt;- persons if p.age &gt; 20) yield p.name</p>
<ul>
<li>
<p>This is equivalent to the following expression , which uses higher-order functions</p>
</li>
<li>
<p>filter and map:</p>
</li>
</ul>
<p>persons filter (p =&gt; p.age &gt; 20) map (p =&gt; p.name)</p>
<ul>
<li>
<p>The for-comprehension looks a bit like a for-loop in imperative languages, except</p>
</li>
<li>
<p>that it constructs a list of the results of all iterations.</p>
</li>
<li>
<p>Generally, a for-comprehension is of the form</p>
</li>
</ul>
<p>for ( s ) yield e</p>
<ul>
<li>
<p>Here, s is a sequence of generators, deﬁnitions and ﬁlters. A generator is of the form</p>
</li>
<li>
<p>val x &lt;- e, where e is a list-valued expression. It binds x to successive values in the</p>
</li>
<li>
<p>list. A deﬁnition is of the form val x = e. It introduces x as a name for the value of e</p>
</li>
<li>
<p>in the rest of the comprehension. A ﬁlter is an expression f of type Boolean. It omits</p>
</li>
</ul>
<p>For-Comprehensionsfrom consideration all bindings for which f is false. The sequence s starts in eachcase with a generator. If there are several generators in a sequence, later generatorsvary more rapidly than earlier ones.</p>
<p>The sequence s may also be enclosed in braces instead of parentheses, in whichcase the semicolons between generators, deﬁnitions and ﬁlters can be omitted.</p>
<p>Here are two examples that show how for-comprehensions are used. First, let’s redoan example of the previous chapter: Given a positive integer n, ﬁnd all pairs ofpositive integers i and j , where 1 ≤ j &lt; i &lt; n such that i + j is prime. With a for-comprehension this problem is solved as follows:</p>
<p>for { i &lt;- List.range(1, n)</p>
<p>j &lt;- List.range(1, i)</p>
<p>if isPrime(i+j) } yield {i, j}</p>
<p>This is arguably much clearer than the solution using map, flatMap and filter thatwe have developed previously.</p>
<p>As a second example, consider computing the scalar product of two vectors xs andys. Using a for-comprehension, this can be written as follows.</p>
<p>sum(for ((x, y) &lt;- xs zip ys) yield x * y)</p>
<h3 id="101-the-n-queens-problem">10.1 The N-Queens Problem</h3>
<p>For-comprehensions are especially useful for solving combinatorial puzzles. An ex-ample of such a puzzle is the 8-queens problem: Given a standard chess-board,place 8 queens such that no queen is in check from any other (a queen can checkanother piece if they are on the same column, row, or diagonal). We will now de-velop a solution to this problem, generalizing it to chess-boards of arbitrary size.Hence, the problem is to place n queens on a chess-board of size n × n.</p>
<p>To solve this problem, note that we need to place a queen in each row. So we couldplace queens in successive rows, each time checking that a newly placed queen isnot in check from any other queens that have already been placed. In the course ofthis search, it might arrive that a queen to be placed in row k would be in check inall ﬁelds of that row from queens in row 1 to k − 1. In that case, we need to abortthat part of the search in order to continue with a different conﬁguration of queensin columns 1 to k − 1.</p>
<p>This suggests a recursive algorithm. Assume that we have already generated all so-lutions of placing k − 1 queens on a board of size n× n. We can represent each suchsolution by a list of length k − 1 of column numbers (which can range from 1 ton). We treat these partial solution lists as stacks, where the column number of thequeen in row k − 1 comes ﬁrst in the list, followed by the column number of thequeen in row k − 2, etc. The bottom of the stack is the column number of the queen- 10.2 Querying with For-Comprehensions</p>
<ul>
<li>
<p>placed in the ﬁrst row of the board. All solutions together are then represented as a</p>
</li>
<li>
<p>list of lists, with one element for each solution.</p>
</li>
<li>
<p>Now, to place the k’the queen, we generate all possible extensions of each previous</p>
</li>
<li>
<p>solution by one more queen. This yields another list of solution lists, this time of</p>
</li>
<li>
<p>length k. We continue the process until we have reached solutions of the size of the</p>
</li>
<li>
<p>chess-board n. This algorithmic idea is embodied in function placeQueens below:</p>
</li>
</ul>
<p>def queens(n: Int): List[List[Int]] = {</p>
<p>def placeQueens(k: Int): List[List[Int]] =</p>
<p>if (k == 0) List(List())</p>
<p>else for { queens &lt;- placeQueens(k - 1)</p>
<p>column &lt;- List.range(1, n + 1)</p>
<p>if isSafe(column, queens, 1) } yield column :: queens</p>
<p>placeQueens(n)</p>
<p>}</p>
<ul>
<li>Exercise 10.1.1 Write the function</li>
</ul>
<p>def isSafe(col: Int, queens: List[Int], delta: Int): Boolean</p>
<ul>
<li>
<p>which tests whether a queen in the given column col is safe with respect to the</p>
</li>
<li>
<p>queens already placed. Here, delta is the difference between the row of the queen</p>
</li>
<li>
<p>to be placed and the row of the ﬁrst queen in the list.</p>
</li>
</ul>
<h3 id="102-querying-with-for-comprehensions">10.2 Querying with For-Comprehensions</h3>
<ul>
<li>
<p>The for-notation is essentially equivalent to common operations of database query</p>
</li>
<li>
<p>languages. For instance, say we are given a database books, represented as a list of</p>
</li>
<li>
<p>books, where Book is deﬁned as follows.</p>
</li>
</ul>
<p>case class Book(title: String, authors: List[String])</p>
<ul>
<li>Here is a small example database:</li>
</ul>
<p>val books: List[Book] = List(</p>
<p>Book(&ldquo;Structure and Interpretation of Computer Programs&rdquo;,</p>
<p>List(&ldquo;Abelson, Harold&rdquo;, &ldquo;Sussman, Gerald J.&quot;)),</p>
<p>Book(&ldquo;Principles of Compiler Design&rdquo;,</p>
<p>List(&ldquo;Aho, Alfred&rdquo;, &ldquo;Ullman, Jeffrey&rdquo;)),</p>
<p>Book(&ldquo;Programming in Modula-2&rdquo;,</p>
<p>List(&ldquo;Wirth, Niklaus&rdquo;)),</p>
<p>Book(&ldquo;Introduction to Functional Programming&rdquo;),</p>
<p>List(&ldquo;Bird, Richard&rdquo;)),</p>
<p>Book(&ldquo;The Java Language Specification&rdquo;,</p>
<p>List(&ldquo;Gosling, James&rdquo;, &ldquo;Joy, Bill&rdquo;, &ldquo;Steele, Guy&rdquo;, &ldquo;Bracha, Gilad&rdquo;)))For-ComprehensionsThen, to ﬁnd the titles of all books whose author’s last name is “Ullman”:</p>
<p>for (b &lt;- books; a &lt;- b.authors if a startsWith &ldquo;Ullman&rdquo;)</p>
<p>yield b.title</p>
<p>(Here, startsWith is a method in java.lang.String). Or, to ﬁnd the titles of allbooks that have the string “Program” in their title:</p>
<p>for (b &lt;- books if (b.title indexOf &ldquo;Program&rdquo;) &gt;= 0)</p>
<p>yield b.title</p>
<p>Or, to ﬁnd the names of all authors that have written at least two books in thedatabase.</p>
<p>for (b1 &lt;- books; b2 &lt;- books if b1 != b2;</p>
<p>a1 &lt;- b1.authors; a2 &lt;- b2.authors if a1 == a2)</p>
<p>yield a1</p>
<p>The last solution is not yet perfect, because authors will appear several times in thelist of results. We still need to remove duplicate authors from result lists. This canbe achieved with the following function.</p>
<p>def removeDuplicates[A](xs: List[A]): List[A] =</p>
<p>if (xs.isEmpty) xs</p>
<p>else xs.head :: removeDuplicates(xs.tail filter (x =&gt; x != xs.head))</p>
<p>Note that the last expression in method removeDuplicates can be equivalently ex-pressed using a for-comprehension.</p>
<p>xs.head :: removeDuplicates(for (x &lt;- xs.tail if x != xs.head) yield x)</p>
<h3 id="103-translation-of-for-comprehensions">10.3 Translation of For-Comprehensions</h3>
<p>Every for-comprehension can be expressed in terms of the three higher-order func-tions map, flatMap and filter. Here is the translation scheme, which is also usedby the Scala compiler.</p>
<p>• A simple for-comprehension</p>
<p>for (x &lt;- e) yield e’</p>
<p>is translated to</p>
<p>e.map(x =&gt; e’)</p>
<p>• A for-comprehension</p>
<ul>
<li>10.3 Translation of For-Comprehensions</li>
</ul>
<p>for (x &lt;- e if f; s) yield e’</p>
<p>where f is a ﬁlter and s is a (possibly empty) sequence of generators or ﬁlters</p>
<p>is translated to</p>
<p>for (x &lt;- e.filter(x =&gt; f); s) yield e’</p>
<p>and then translation continues with the latter expression.</p>
<p>• A for-comprehension</p>
<p>for (x &lt;- e; y &lt;- e’; s) yield e’’</p>
<p>where s is a (possibly empty) sequence of generators or ﬁlters is translated to</p>
<p>e.flatMap(x =&gt; for (y &lt;- e’; s) yield e’’)</p>
<p>and then translation continues with the latter expression.</p>
<ul>
<li>For instance, taking our &ldquo;pairs of integers whose sum is prime&rdquo; example:</li>
</ul>
<p>for { i &lt;- range(1, n)</p>
<p>j &lt;- range(1, i)</p>
<p>if isPrime(i+j)</p>
<p>} yield {i, j}</p>
<ul>
<li>Here is what we get when we translate this expression:</li>
</ul>
<p>range(1, n)</p>
<p>.flatMap(i =&gt;</p>
<p>range(1, i)</p>
<p>.filter(j =&gt; isPrime(i+j))</p>
<p>.map(j =&gt; (i, j)))</p>
<ul>
<li>
<p>Conversely, it would also be possible to express functions map, flatMap and filter</p>
</li>
<li>
<p>using for-comprehensions. Here are the three functions again, this time imple-</p>
</li>
<li>
<p>mented using for-comprehensions.</p>
</li>
</ul>
<p>object Demo {</p>
<p>def map[A, B](xs: List[A], f: A =&gt; B): List[B] =</p>
<p>for (x &lt;- xs) yield f(x)</p>
<p>def flatMap[A, B](xs: List[A], f: A =&gt; List[B]): List[B] =</p>
<p>for (x &lt;- xs; y &lt;- f(x)) yield y</p>
<p>def filter[A](xs: List[A], p: A =&gt; Boolean): List[A] =</p>
<p>for (x &lt;- xs if p(x)) yield x</p>
<p>}</p>
<p>For-ComprehensionsNot surprisingly, the translation of the for-comprehension in the body of Demo.mapwill produce a call to map in class List. Similarly, Demo.flatMap and Demo.filtertranslate to flatMap and filter in class List.</p>
<p>Exercise 10.3.1 Deﬁne the following function in terms of for.</p>
<p>def flatten[A](xss: List[List[A]]): List[A] =</p>
<p>(xss :\ (Nil: List[A])) ((xs, ys) =&gt; xs ::: ys)</p>
<p>Exercise 10.3.2 Translate</p>
<p>for (b &lt;- books; a &lt;- b.authors if a startsWith &ldquo;Bird&rdquo;) yield b.title</p>
<p>for (b &lt;- books if (b.title indexOf &ldquo;Program&rdquo;) &gt;= 0) yield b.title</p>
<p>to higher-order functions.</p>
<h3 id="104-for-loops">10.4 For-Loops</h3>
<p>For-comprehensions resemble for-loops in imperative languages, except that theyproduce a list of results. Sometimes, a list of results is not needed but we wouldstill like the ﬂexibility of generators and ﬁlters in iterations over lists. This is madepossible by a variant of the for-comprehension syntax, which expresses for-loops:</p>
<p>for ( s ) e</p>
<p>This construct is the same as the standard for-comprehension syntax except thatthe keyword yield is missing. The for-loop is executed by executing the expressione for each element generated from the sequence of generators and ﬁlters s.</p>
<p>As an example, the following expression prints out all elements of a matrix repre-sented as a list of lists:</p>
<p>for (xs &lt;- xss) {</p>
<p>for (x &lt;- xs) print(x + &ldquo;\t&rdquo;)</p>
<p>println()</p>
<p>}</p>
<p>The translation of for-loops to higher-order methods of class List is similar tothe translation of for-comprehensions, but is simpler. Where for-comprehensionstranslate to map and flatMap, for-loops translate in each case to foreach.</p>
<h3 id="105-generalizing-for">10.5 Generalizing For</h3>
<p>We have seen that the translation of for-comprehensions only relies on the presenceof methods map, flatMap, and filter. Therefore it is possible to apply the same- 10.5 Generalizing For</p>
<ul>
<li>
<p>notation to generators that produce objects other than lists; these objects only have</p>
</li>
<li>
<p>to support the three key functions map, flatMap, and filter.</p>
</li>
<li>
<p>The standard Scala library has several other abstractions that support these three</p>
</li>
<li>
<p>methods and with them support for-comprehensions. We will encounter some of</p>
</li>
<li>
<p>them in the following chapters. As a programmer you can also use this principle to</p>
</li>
<li>
<p>enable for-comprehensions for types you deﬁne – these types just need to support</p>
</li>
<li>
<p>methods map, flatMap, and filter.</p>
</li>
<li>
<p>There are many examples where this is useful: Examples are database interfaces,</p>
</li>
<li>
<p>XML trees, or optional values.</p>
</li>
<li>
<p>One caveat:</p>
</li>
</ul>
<p>It is not assured automatically that the result translating a for-</p>
<ul>
<li>
<p>comprehension is well-typed. To ensure this, the types of map, flatMap and filter</p>
</li>
<li>
<p>have to be essentially similar to the types of these methods in class List.</p>
</li>
<li>
<p>To make this precise, assume you have a parameterized class C[A] for which you</p>
</li>
<li>
<p>want to enable for-comprehensions. Then C should deﬁne map, flatMap and filter</p>
</li>
<li>
<p>with the following types:</p>
</li>
</ul>
<p>def map[B](f: A =&gt; B): C[B]</p>
<p>def flatMap[B](f: A =&gt; C[B]): C[B]</p>
<p>def filter(p: A =&gt; Boolean): C[A]</p>
<ul>
<li>
<p>It would be attractive to enforce these types statically in the Scala compiler, for</p>
</li>
<li>
<p>instance by requiring that any type supporting for-comprehensions implements a</p>
</li>
<li>
<p>standard trait with these methods 1. The problem is that such a standard trait would</p>
</li>
<li>
<p>have to abstract over the identity of the class C, for instance by taking C as a type pa-</p>
</li>
<li>
<p>rameter. Note that this parameter would be a type constructor, which gets applied</p>
</li>
<li>
<p>to several different types in the signatures of methods map and flatMap. Unfortu-</p>
</li>
<li>
<p>nately, the Scala type system is too weak to express this construct, since it can han-</p>
</li>
<li>
<p>dle only type parameters which are fully applied types.</p>
</li>
</ul>
<p>1In the programming language Haskell, which has similar constructs, this abstraction is called a</p>
<p>“monad with zero”</p>
<p>Chapter 11</p>
<h2 id="mutable-state">Mutable State</h2>
<p>Most programs we have presented so far did not have side-effects 1. Therefore, the</p>
<p>notion of time did not matter. For a program that terminates, any sequence of ac-</p>
<p>tions would have led to the same result! This is also reﬂected by the substitution</p>
<p>model of computation, where a rewrite step can be applied anywhere in a term,</p>
<p>and all rewritings that terminate lead to the same solution. In fact, this conﬂuence</p>
<p>property is a deep result in λ-calculus, the theory underlying functional program-</p>
<p>ming.</p>
<p>In this chapter, we introduce functions with side effects and study their behavior.</p>
<p>We will see that as a consequence we have to fundamentally modify up the substi-</p>
<p>tution model of computation which we employed so far.</p>
<h3 id="111-stateful-objects">11.1 Stateful Objects</h3>
<ul>
<li>
<p>We normally view the world as a set of objects, some of which have state that</p>
</li>
<li>
<p>changes over time. Normally, state is associated with a set of variables that can be</p>
</li>
<li>
<p>changed in the course of a computation. There is also a more abstract notion of</p>
</li>
<li>
<p>state, which does not refer to particular constructs of a programming language: An</p>
</li>
<li>
<p>object has state (or: is stateful) if its behavior is inﬂuenced by its history.</p>
</li>
<li>
<p>For instance, a bank account object has state, because the question “can I withdraw</p>
</li>
<li>
<p>100 CHF?” might have different answers during the lifetime of the account.</p>
</li>
<li>
<p>In Scala, all mutable state is ultimately built from variables. A variable deﬁnition is</p>
</li>
<li>
<p>written like a value deﬁnition, but starts with var instead of val. For instance, the</p>
</li>
<li>
<p>following two deﬁnitions introduce and initialize two variables x and count.</p>
</li>
</ul>
<p>var x: String = &ldquo;abc&rdquo;</p>
<p>1We ignore here the fact that some of our program printed to standard output, which technically</p>
<ul>
<li>is a side effect.</li>
</ul>
<p>var count = 111</p>
<p>Mutable StateLike a value deﬁnition, a variable deﬁnition associates a name with a value. But inthe case of a variable deﬁnition, this association may be changed later by an assign-ment. Such assignments are written as in C or Java. Examples:</p>
<p>x = &ldquo;hello&rdquo;</p>
<p>count = count + 1</p>
<p>In Scala, every deﬁned variable has to be initialized at the point of its deﬁnition.For instance, the statement var x: Int; is not regarded as a variable deﬁnition,because the initializer is missing2. If one does not know, or does not care about, theappropriate initializer, one can use a wildcard instead. I.e.</p>
<p>val x: T = _</p>
<p>will initialize x to some default value (null for reference types, false for booleans,and the appropriate version of 0 for numeric value types).</p>
<p>Real-world objects with state are represented in Scala by objects that have variablesas members. For instance, here is a class that represents bank accounts.</p>
<p>class BankAccount {</p>
<p>private var balance = 0</p>
<p>def deposit(amount: Int) {</p>
<p>if (amount &gt; 0) balance += amount</p>
<p>}</p>
<p>def withdraw(amount: Int): Int =</p>
<p>if (0 &lt; amount &amp;&amp; amount &lt;= balance) {</p>
<p>balance -= amount</p>
<p>balance</p>
<p>} else error(&ldquo;insufficient funds&rdquo;)</p>
<p>}</p>
<p>The class deﬁnes a variable balance which contains the current balance of an ac-count. Methods deposit and withdraw change the value of this variable throughassignments. Note that balance is private in class BankAccount – hence it can notbe accessed directly outside the class.</p>
<p>To create bank-accounts, we use the usual object creation notation:</p>
<p>val myAccount = new BankAccount</p>
<p>2If a statement like this appears in a class, it is instead regarded as a variable declaration, whichintroduces abstract access methods for the variable, but does not associate these methods with apiece of state.</p>
<ul>
<li>
<p>11.1 Stateful Objects</p>
</li>
<li>
<p>Example 11.1.1 Here is a scalaint session that deals with bank accounts.</p>
</li>
</ul>
<p>scala&gt; :l bankaccount.scala</p>
<p>Loading bankaccount.scala&hellip;</p>
<p>defined class BankAccount</p>
<p>scala&gt; val account = new BankAccount</p>
<p>account: BankAccount = BankAccount$class@1797795</p>
<p>scala&gt; account deposit 50</p>
<p>unnamed0: Unit = ()</p>
<p>scala&gt; account withdraw 20</p>
<p>unnamed1: Int = 30</p>
<p>scala&gt; account withdraw 20</p>
<p>unnamed2: Int = 10</p>
<p>scala&gt; account withdraw 15</p>
<p>java.lang.Error: insufficient funds</p>
<p>at scala.Predef$error(Predef.scala:74)</p>
<p>at BankAccount$class.withdraw(<!-- raw HTML omitted -->:14)</p>
<p>at <!-- raw HTML omitted -->(<!-- raw HTML omitted -->:5)</p>
<p>scala&gt;</p>
<ul>
<li>
<p>The example shows that applying the same operation (withdraw 20) twice to an</p>
</li>
<li>
<p>account yields different results. So, clearly, accounts are stateful objects.</p>
</li>
<li>
<p>Sameness and Change. Assignments pose new problems in deciding when two</p>
</li>
<li>
<p>expressions are “the same”. If assignments are excluded, and one writes</p>
</li>
</ul>
<p>val x = E; val y = E</p>
<ul>
<li>
<p>where E is some arbitrary expression, then x and y can reasonably be assumed to be</p>
</li>
<li>
<p>the same. I.e. one could have equivalently written</p>
</li>
</ul>
<p>val x = E; val y = x</p>
<ul>
<li>
<p>(This property is usually called referential transparency). But once we admit assign-</p>
</li>
<li>
<p>ments, the two deﬁnition sequences are different. Consider:</p>
</li>
</ul>
<p>val x = new BankAccount; val y = new BankAccount</p>
<ul>
<li>
<p>To answer the question whether x and y are the same, we need to be more pre-</p>
</li>
<li>
<p>cise what “sameness” means. This meaning is captured in the notion of operational</p>
</li>
<li>
<p>equivalence, which, somewhat informally, is stated as follows.</p>
</li>
<li>
<p>Suppose we have two deﬁnitions of x and y. To test whether x and y deﬁne the same</p>
</li>
<li>
<p>value, proceed as follows.</p>
</li>
</ul>
<p>• Execute the deﬁnitions followed by an arbitrary sequence S of operations that</p>
<p>involve x and y. Observe the results (if any).</p>
<p>Mutable State• Then, execute the deﬁnitions with another sequence S’ which results from Sby renaming all occurrences of y in S to x.</p>
<p>• If the results of running S’ are different, then surely x and y are different.</p>
<p>• On the other hand, if all possible pairs of sequences {S, S’} yield the sameresults, then x and y are the same.</p>
<p>In other words, operational equivalence regards two deﬁnitions x and y as deﬁningthe same value, if no possible experiment can distinguish between x and y. An ex-periment in this context are two version of an arbitrary program which use either xor y.</p>
<p>Given this deﬁnition, let’s test whether</p>
<p>val x = new BankAccount; val y = new BankAccount</p>
<p>deﬁnes values x and y which are the same. Here are the deﬁnitions again, followedby a test sequence:</p>
<blockquote>
<p>val x = new BankAccount</p>
</blockquote>
<blockquote>
<p>val y = new BankAccount</p>
</blockquote>
<blockquote>
<p>x deposit 30</p>
</blockquote>
<blockquote>
<p>y withdraw 20</p>
</blockquote>
<p>java.lang.RuntimeException: insufficient funds</p>
<p>Now, rename all occurrences of y in that sequence to x. We get:</p>
<blockquote>
<p>val x = new BankAccount</p>
</blockquote>
<blockquote>
<p>val y = new BankAccount</p>
</blockquote>
<blockquote>
<p>x deposit 30</p>
</blockquote>
<blockquote>
<p>x withdraw 20</p>
</blockquote>
<p>Since the ﬁnal results are different, we have established that x and y are not thesame. On the other hand, if we deﬁne</p>
<p>val x = new BankAccount; val y = x</p>
<p>then no sequence of operations can distinguish between x and y, so x and y are thesame in this case.</p>
<p>Assignment and the Substitution Model. These examples show that our previoussubstitution model of computation cannot be used anymore. After all, under thismodel we could always replace a value name by its deﬁning expression. For instancein</p>
<ul>
<li>11.2 Imperative Control Structures</li>
</ul>
<p>val x = new BankAccount; val y = x</p>
<ul>
<li>
<p>the x in the deﬁnition of y could be replaced by new BankAccount. But we have seen</p>
</li>
<li>
<p>that this change leads to a different program. So the substitution model must be</p>
</li>
<li>
<p>invalid, once we add assignments.</p>
</li>
</ul>
<h3 id="112-imperative-control-structures">11.2 Imperative Control Structures</h3>
<ul>
<li>
<p>Scala has the while and do-while loop constructs known from the C and Java lan-</p>
</li>
<li>
<p>guages. There is also a single branch if which leaves out the else-part as well as a</p>
</li>
<li>
<p>return statement which aborts a function prematurely. This makes it possible to</p>
</li>
<li>
<p>program in a conventional imperative style. For instance, the following function,</p>
</li>
<li>
<p>which computes the n’th power of a given parameter x, is implemented using while</p>
</li>
<li>
<p>and single-branch if.</p>
</li>
</ul>
<p>def power(x: Double, n: Int): Double = {</p>
<p>var r = 1.0</p>
<p>var i = n</p>
<p>var j = 0</p>
<p>while (j &lt; 32) {</p>
<p>r = r * r</p>
<p>if (i &lt; 0)</p>
<p>r *= x</p>
<p>i = i &laquo; 1</p>
<p>j += 1</p>
<p>}</p>
<p>r</p>
<p>}</p>
<ul>
<li>
<p>These imperative control constructs are in the language for convenience. They</p>
</li>
<li>
<p>could have been left out, as the same constructs can be implemented using just</p>
</li>
<li>
<p>functions. As an example, let’s develop a functional implementation of the while</p>
</li>
<li>
<p>loop. whileLoop should be a function that takes two parameters: a condition, of</p>
</li>
<li>
<p>type Boolean, and a command, of type Unit. Both condition and command need</p>
</li>
<li>
<p>to be passed by-name, so that they are evaluated repeatedly for each loop iteration.</p>
</li>
<li>
<p>This leads to the following deﬁnition of whileLoop.</p>
</li>
</ul>
<p>def whileLoop(condition: =&gt; Boolean)(command: =&gt; Unit) {</p>
<p>if (condition) {</p>
<p>command; whileLoop(condition)(command)</p>
<p>} else ()</p>
<p>}</p>
<ul>
<li>Note that whileLoop is tail recursive, so it operates in constant stack space.</li>
</ul>
<p>Mutable StateExercise 11.2.1 Write a function repeatLoop, which should be applied as follows:</p>
<p>repeatLoop { command } ( condition )</p>
<p>Is there also a way to obtain a loop syntax like the following?</p>
<p>repeatLoop { command } until ( condition )</p>
<p>Some other control constructs known from C and Java are missing in Scala: Thereare no break and continue jumps for loops. There are also no for-loops in the Javasense – these have been replaced by the more general for-loop construct discussedin Section 10.4.</p>
<h3 id="113-extended-example-discrete-event-simulation">11.3 Extended Example: Discrete Event Simulation</h3>
<p>We now discuss an example that demonstrates how assignments and higher-orderfunctions can be combined in interesting ways. We will build a simulator for digitalcircuits.</p>
<p>The example is taken from Abelson and Sussman’s book [ASS96]. We augmenttheir basic (Scheme-) code by an object-oriented structure which allows code-reusethrough inheritance. The example also shows how discrete event simulation pro-grams in general are structured and built.</p>
<p>We start with a little language to describe digital circuits. A digital circuit is builtfrom wires and function boxes. Wires carry signals which are transformed by func-tion boxes. We will represent signals by the booleans true and false.</p>
<p>Basic function boxes (or: gates) are:</p>
<p>• An inverter, which negates its signal</p>
<p>• An and-gate, which sets its output to the conjunction of its input.</p>
<p>• An or-gate, which sets its output to the disjunction of its input.</p>
<p>Other function boxes can be built by combining basic ones.</p>
<p>Gates have delays, so an output of a gate will change only some time after its inputschange.</p>
<p>A Language for Digital Circuits. We describe the elements of a digital circuit bythe following set of Scala classes and functions.</p>
<p>First, there is a class Wire for wires. We can construct wires as follows.</p>
<p>val a = new Wire</p>
<p>val b = new Wire</p>
<p>val c = new Wire</p>
<ul>
<li>
<p>11.3 Extended Example: Discrete Event Simulation</p>
</li>
<li>
<p>Second, there are procedures</p>
</li>
</ul>
<p>def inverter(input: Wire, output: Wire)</p>
<p>def andGate(a1: Wire, a2: Wire, output: Wire)</p>
<p>def orGate(o1: Wire, o2: Wire, output: Wire)</p>
<ul>
<li>
<p>which “make” the basic gates we need (as side-effects). More complicated function</p>
</li>
<li>
<p>boxes can now be built from these. For instance, to construct a half-adder, we can</p>
</li>
<li>
<p>deﬁne:</p>
</li>
</ul>
<p>def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) {</p>
<p>val d = new Wire</p>
<p>val e = new Wire</p>
<p>orGate(a, b, d)</p>
<p>andGate(a, b, c)</p>
<p>inverter(c, e)</p>
<p>andGate(d, e, s)</p>
<p>}</p>
<ul>
<li>This abstraction can itself be used, for instance in deﬁning a full adder:</li>
</ul>
<p>def fullAdder(a: Wire, b: Wire, cin: Wire, sum: Wire, cout: Wire) {</p>
<p>val s = new Wire</p>
<p>val c1 = new Wire</p>
<p>val c2 = new Wire</p>
<p>halfAdder(a, cin, s, c1)</p>
<p>halfAdder(b, s, sum, c2)</p>
<p>orGate(c1, c2, cout)</p>
<p>}</p>
<ul>
<li>
<p>Class Wire and functions inverter, andGate, and orGate represent thus a little lan-</p>
</li>
<li>
<p>guage in which users can deﬁne digital circuits. We now give implementations of</p>
</li>
<li>
<p>this class and these functions, which allow one to simulate circuits. These imple-</p>
</li>
<li>
<p>mentations are based on a simple and general API for discrete event simulation.</p>
</li>
<li>
<p>The Simulation API. Discrete event simulation performs user-deﬁned actions at</p>
</li>
<li>
<p>speciﬁed times. An action is represented as a function which takes no parameters</p>
</li>
<li>
<p>and returns a Unit result:</p>
</li>
</ul>
<p>type Action = () =&gt; Unit</p>
<ul>
<li>
<p>The time is simulated; it is not the actual “wall-clock” time.</p>
</li>
<li>
<p>A concrete simulation will be done inside an object which inherits from the abstract</p>
</li>
<li>
<p>Simulation class. This class has the following signature:</p>
</li>
</ul>
<p>abstract class Simulation {</p>
<p>}</p>
<p>def currentTime: Int</p>
<p>def afterDelay(delay: Int, action: =&gt; Action)</p>
<p>def run()</p>
<p>Mutable StateHere, currentTime returns the current simulated time as an integer number,afterDelay schedules an action to be performed at a speciﬁed delay aftercurrentTime, and run runs the simulation until there are no further actions to beperformed.</p>
<p>The Wire Class. A wire needs to support three basic actions.</p>
<p>getSignal: Boolean returns the current signal on the wire.</p>
<p>setSignal(sig: Boolean) sets the wire’s signal to sig.</p>
<p>addAction(p: Action) attaches the speciﬁed procedure p to the actions ofthe wire. All attached action procedures will be executed every time the signalof a wire changes.</p>
<p>Here is an implementation of the Wire class:</p>
<p>class Wire {</p>
<p>private var sigVal = false</p>
<p>private var actions: List[Action] = List()</p>
<p>def getSignal = sigVal</p>
<p>def setSignal(s: Boolean) =</p>
<p>if (s != sigVal) {</p>
<p>sigVal = s</p>
<p>actions.foreach(action =&gt; action())</p>
<p>}</p>
<p>def addAction(a: Action) {</p>
<p>actions = a :: actions; a()</p>
<p>}</p>
<p>}</p>
<p>Two private variables make up the state of a wire. The variable sigVal represents thecurrent signal, and the variable actions represents the action procedures currentlyattached to the wire.</p>
<p>The Inverter Class. We implement an inverter by installing an action on its inputwire, namely the action which puts the negated input signal onto the output sig-nal. The action needs to take effect at InverterDelay simulated time units after theinput changes. This suggests the following implementation:</p>
<p>def inverter(input: Wire, output: Wire) {</p>
<ul>
<li>11.3 Extended Example: Discrete Event Simulation</li>
</ul>
<p>def invertAction() {</p>
<p>val inputSig = input.getSignal</p>
<p>afterDelay(InverterDelay) { output setSignal !inputSig }</p>
<p>}</p>
<p>input addAction invertAction</p>
<p>}</p>
<ul>
<li>
<p>The And-Gate Class. And-gates are implemented analogously to inverters. The</p>
</li>
<li>
<p>action of an andGate is to output the conjunction of its input signals. This should</p>
</li>
<li>
<p>happen at AndGateDelay simulated time units after any one of its two inputs</p>
</li>
<li>
<p>changes. Hence, the following implementation:</p>
</li>
</ul>
<p>def andGate(a1: Wire, a2: Wire, output: Wire) {</p>
<p>def andAction() {</p>
<p>val a1Sig = a1.getSignal</p>
<p>val a2Sig = a2.getSignal</p>
<p>afterDelay(AndGateDelay) { output setSignal (a1Sig &amp; a2Sig) }</p>
<p>}</p>
<p>a1 addAction andAction</p>
<p>a2 addAction andAction</p>
<p>}</p>
<ul>
<li>
<p>Exercise 11.3.1 Write the implementation of orGate.</p>
</li>
<li>
<p>Exercise 11.3.2 Another way is to deﬁne an or-gate by a combination of inverters</p>
</li>
<li>
<p>and and gates. Deﬁne a function orGate in terms of andGate and inverter. What is</p>
</li>
<li>
<p>the delay time of this function?</p>
</li>
<li>
<p>The Simulation Class. Now, we just need to implement class Simulation, and we</p>
</li>
<li>
<p>are done. The idea is that we maintain inside a Simulation object an agenda of</p>
</li>
<li>
<p>actions to perform. The agenda is represented as a list of pairs of actions and the</p>
</li>
<li>
<p>times they need to be run. The agenda list is sorted, so that earlier actions come</p>
</li>
<li>
<p>before later ones.</p>
</li>
</ul>
<p>abstract class Simulation {</p>
<p>case class WorkItem(time: Int, action: Action)</p>
<p>private type Agenda = List[WorkItem]</p>
<p>private var agenda: Agenda = List()</p>
<ul>
<li>There is also a private variable curtime to keep track of the current simulated time.</li>
</ul>
<p>private var curtime = 0</p>
<p>Mutable StateAn application of the method afterDelay(delay, block) inserts the elementWorkItem(currentTime + delay, () =&gt; block) into the agenda list at the appro-priate place.</p>
<p>private def insert(ag: Agenda, item: WorkItem): Agenda =</p>
<p>if (ag.isEmpty || item.time &lt; ag.head.time) item :: ag</p>
<p>else ag.head :: insert(ag.tail, item)</p>
<p>def afterDelay(delay: Int)(block: =&gt; Unit) {</p>
<p>val item = WorkItem(currentTime + delay, () =&gt; block)</p>
<p>agenda = insert(agenda, item)</p>
<p>}</p>
<p>An application of the run method removes successive elements from the agenda andperforms their actions. It continues until the agenda is empty:</p>
<p>private def next() {</p>
<p>agenda match {</p>
<p>case WorkItem(time, action) :: rest =&gt;</p>
<p>agenda = rest; curtime = time; action()</p>
<p>case List() =&gt;</p>
<p>}</p>
<p>}</p>
<p>def run() {</p>
<p>afterDelay(0) { println(&quot;*** simulation started ***&quot;) }</p>
<p>while (!agenda.isEmpty) next()</p>
<p>}</p>
<p>Running the Simulator. To run the simulator, we still need a way to inspectchanges of signals on wires. To this purpose, we write a function probe.</p>
<p>def probe(name: String, wire: Wire) {</p>
<p>wire addAction { () =&gt;</p>
<p>println(name + &quot; &quot; + currentTime + &quot; new_value = &quot; + wire.getSignal)}</p>
<p>}</p>
<p>Now, to see the simulator in action, let’s deﬁne four wires, and place probes on twoof them:</p>
<p>scala&gt; val input1, input2, sum, carry = new Wire</p>
<p>scala&gt; probe(&ldquo;sum&rdquo;, sum)</p>
<p>sum 0 new_value = false</p>
<ul>
<li>11.4 Summary</li>
</ul>
<p>scala&gt; probe(&ldquo;carry&rdquo;, carry)</p>
<p>carry 0 new_value = false</p>
<ul>
<li>Now let’s deﬁne a half-adder connecting the wires:</li>
</ul>
<p>scala&gt; halfAdder(input1, input2, sum, carry)</p>
<ul>
<li>
<p>Finally, set one after another the signals on the two input wires to true and run the</p>
</li>
<li>
<p>simulation.</p>
</li>
</ul>
<p>scala&gt; input1 setSignal true; run</p>
<p>*** simulation started ***</p>
<p>sum 8 new_value = true</p>
<p>scala&gt; input2 setSignal true; run</p>
<p>carry 11 new_value = true</p>
<p>sum 15 new_value = false</p>
<h3 id="114-summary">11.4 Summary</h3>
<p>We have seen in this chapter the constructs that let us model state in Scala – these</p>
<p>are variables, assignments, and imperative control structures. State and Assign-</p>
<p>ment complicate our mental model of computation. In particular, referential trans-</p>
<p>parency is lost. On the other hand, assignment gives us new ways to formulate pro-</p>
<p>grams elegantly. As always, it depends on the situation whether purely functional</p>
<p>programming or programming with assignments works best.</p>
<p>Chapter 12</p>
<h2 id="computing-with-streams">Computing with Streams</h2>
<p>The previous chapters have introduced variables, assignment and stateful objects.</p>
<p>We have seen how real-world objects that change with time can be modeled by</p>
<p>changing the state of variables in a computation. Time changes in the real world</p>
<p>thus are modeled by time changes in program execution. Of course, such time</p>
<p>changes are usually stretched out or compressed, but their relative order is the</p>
<p>same. This seems quite natural, but there is a also price to pay: Our simple and pow-</p>
<p>erful substitution model for functional computation is no longer applicable once we</p>
<p>introduce variables and assignment.</p>
<p>Is there another way? Can we model state change in the real world using only im-</p>
<p>mutable functions? Taking mathematics as a guide, the answer is clearly yes: A</p>
<p>time-changing quantity is simply modeled by a function f(t) with a time parame-</p>
<p>ter t. The same can be done in computation. Instead of overwriting a variable with</p>
<p>successive values, we represent all these values as successive elements in a list. So,</p>
<p>a mutable variable var x: T gets replaced by an immutable value val x: List[T].</p>
<p>In a sense, we trade space for time – the different values of the variable now all exist</p>
<p>concurrently as different elements of the list. One advantage of the list-based view</p>
<p>is that we can “time-travel”, i.e. view several successive values of the variable at the</p>
<p>same time. Another advantage is that we can make use of the powerful library of list</p>
<p>processing functions, which often simpliﬁes computation. For instance, consider</p>
<p>the imperative way to compute the sum of all prime numbers in an interval:</p>
<p>def sumPrimes(start: Int, end: Int): Int = {</p>
<p>var i = start</p>
<p>var acc = 0</p>
<p>while (i &lt; end) {</p>
<p>if (isPrime(i)) acc += i</p>
<p>i += 1</p>
<p>}</p>
<p>acc</p>
<p>}</p>
<p>Computing with StreamsNote that the variable i “steps through” all values of the interval [start .. end-1].A more functional way is to represent the list of values of variable i directly asrange(start, end). Then the function can be rewritten as follows.</p>
<p>def sumPrimes(start: Int, end: Int) =</p>
<p>sum(range(start, end) filter isPrime)</p>
<p>No contest which program is shorter and clearer! However, the functional programis also considerably less efﬁcient since it constructs a list of all numbers in the in-terval, and then another one for the prime numbers. Even worse from an efﬁciencypoint of view is the following example:</p>
<p>To ﬁnd the second prime number between 1000 and 10000:</p>
<p>range(1000, 10000) filter isPrime at 1</p>
<p>Here, the list of all numbers between 1000 and 10000 is constructed. But most ofthat list is never inspected!</p>
<p>However, we can obtain efﬁcient execution for examples like these by a trick:</p>
<p>Avoid computing the tail of a sequence unless that tail is actually neces-</p>
<p>sary for the computation.</p>
<p>We deﬁne a new class for such sequences, which is called Stream.</p>
<p>Streams are created using the constant empty and the constructor cons, which areboth deﬁned in module scala.Stream. For instance, the following expression con-structs a stream with elements 1 and 2:</p>
<p>Stream.cons(1, Stream.cons(2, Stream.empty))</p>
<p>As another example, here is the analogue of List.range, but returning a streaminstead of a list:</p>
<p>def range(start: Int, end: Int): Stream[Int] =</p>
<p>if (start &gt;= end) Stream.empty</p>
<p>else Stream.cons(start, range(start + 1, end))</p>
<p>(This function is also deﬁned as given above in module Stream). Even thoughStream.range and List.range look similar, their execution behavior is completelydifferent:</p>
<p>Stream.range immediately returns with a Stream object whose ﬁrst element isstart. All other elements are computed only when they are demanded by callingthe tail method (which might be never at all).</p>
<p>Streams are accessed just as lists. Similarly to lists, the basic access methods areisEmpty, head and tail. For instance, we can print all elements of a stream as fol-lows.</p>
<p>def print(xs: Stream[A]) {</p>
<p>if (!xs.isEmpty) { Console.println(xs.head); print(xs.tail) }</p>
<p>}</p>
<ul>
<li>
<p>Streams also support almost all other methods deﬁned on lists (see below for where</p>
</li>
<li>
<p>their methods sets differ). For instance, we can ﬁnd the second prime number be-</p>
</li>
<li>
<p>tween 1000 and 10000 by applying methods filter and apply on an interval stream:</p>
</li>
</ul>
<p>Stream.range(1000, 10000) filter isPrime at 1</p>
<p>The difference to the previous list-based implementation is that now we do not</p>
<p>needlessly construct and test for primality any numbers beyond 1013.</p>
<p>Consing and appending streams. Two methods in class List which are not sup-</p>
<p>ported by class Stream are :: and :::. The reason is that these methods are dis-</p>
<p>patched on their right-hand side argument, which means that this argument needs</p>
<p>to be evaluated before the method is called. For instance, in the case of x :: xs</p>
<p>on lists, the tail xs needs to be evaluated before :: can be called and the new list</p>
<p>can be constructed. This does not work for streams, where we require that the tail</p>
<p>of a stream should not be evaluated until it is demanded by a tail operation. The</p>
<p>argument why list-append ::: cannot be adapted to streams is analogous.</p>
<p>Instead of x :: xs, one uses Stream.cons(x, xs) for constructing a stream with</p>
<p>ﬁrst element x and (unevaluated) rest xs. Instead of xs ::: ys, one uses the opera-</p>
<p>tion xs append ys.</p>
<p>Chapter 13</p>
<h2 id="iterators">Iterators</h2>
<p>Iterators are the imperative version of streams. Like streams, iterators describe po-</p>
<p>tentially inﬁnite lists. However, there is no data-structure which contains the el-</p>
<p>ements of an iterator. Instead, iterators allow one to step through the sequence,</p>
<p>using two abstract methods next and hasNext.</p>
<p>trait Iterator[+A] {</p>
<p>def hasNext: Boolean</p>
<p>def next: A</p>
<ul>
<li>
<p>Method next returns successive elements. Method hasNext indicates whether there</p>
</li>
<li>
<p>are still more elements to be returned by next. Iterators also support some other</p>
</li>
<li>
<p>methods, which are explained later.</p>
</li>
<li>
<p>As an example, here is an application which prints the squares of all numbers from</p>
</li>
<li>
<p>1 to 100.</p>
</li>
</ul>
<p>val it: Iterator[Int] = Iterator.range(1, 100)</p>
<p>while (it.hasNext) {</p>
<p>val x = it.next</p>
<p>println(x * x)</p>
<p>}</p>
<h3 id="131-iterator-methods">13.1 Iterator Methods</h3>
<ul>
<li>
<p>Iterators support a rich set of methods besides next and hasNext, which is described</p>
</li>
<li>
<p>in the following. Many of these methods mimic a corresponding functionality in</p>
</li>
<li>
<p>lists.</p>
</li>
</ul>
<p>IteratorsAppend. Method append constructs an iterator which resumes with the given iter-ator it after the current iterator has ﬁnished.</p>
<p>def append[B &gt;: A](that: Iterator[B]): Iterator[B] = new Iterator[B] {def hasNext = Iterator.this.hasNext || that.hasNext</p>
<p>def next = if (Iterator.this.hasNext) Iterator.this.next else that.next}</p>
<p>The terms Iterator.this.next and Iterator.this.hasNext in the deﬁnition ofappend call the corresponding methods as they are deﬁned in the enclosingIterator class. If the Iterator preﬁx to this would have been missing, hasNextand next would have called recursively the methods being deﬁned in the result ofappend, which is not what we want.</p>
<p>Map, FlatMap, Foreach. Method map constructs an iterator which returns all ele-ments of the original iterator transformed by a given function f.</p>
<p>def map[B](f: A =&gt; B): Iterator[B] = new Iterator[B] {</p>
<p>def hasNext = Iterator.this.hasNext</p>
<p>def next = f(Iterator.this.next)</p>
<p>}</p>
<p>Method flatMap is like method map, except that the transformation function f nowreturns an iterator. The result of flatMap is the iterator resulting from appendingtogether all iterators returned from successive calls of f.</p>
<p>def flatMap[B](f: A =&gt; Iterator[B]): Iterator[B] = new Iterator[B] {</p>
<p>private var cur: Iterator[B] = Iterator.empty</p>
<p>def hasNext: Boolean =</p>
<p>if (cur.hasNext) true</p>
<p>else if (Iterator.this.hasNext) { cur = f(Iterator.this.next); hasNext }else false</p>
<p>def next: B =</p>
<p>if (cur.hasNext) cur.next</p>
<p>else if (Iterator.this.hasNext) { cur = f(Iterator.this.next); next }else error(&ldquo;next on empty iterator&rdquo;)</p>
<p>}</p>
<p>Closely related to map is the foreach method, which applies a given function to allelements of an iterator, but does not construct a list of results</p>
<p>def foreach(f: A =&gt; Unit): Unit =</p>
<p>while (hasNext) { f(next) }</p>
<ul>
<li>
<p>13.1 Iterator Methods</p>
</li>
<li>
<p>Filter. Method filter constructs an iterator which returns all elements of the</p>
</li>
<li>
<p>original iterator that satisfy a criterion p.</p>
</li>
</ul>
<p>def filter(p: A =&gt; Boolean) = new BufferedIterator[A] {</p>
<p>private val source =</p>
<p>Iterator.this.buffered</p>
<p>private def skip =</p>
<p>{ while (source.hasNext &amp;&amp; !p(source.head)) { source.next } }</p>
<p>def hasNext: Boolean =</p>
<p>{ skip; source.hasNext }</p>
<p>def next: A =</p>
<p>{ skip; source.next }</p>
<p>def head: A =</p>
<p>{ skip; source.head }</p>
<p>}</p>
<ul>
<li>
<p>In fact, filter returns instances of a subclass of iterators which are “buffered”. A</p>
</li>
<li>
<p>BufferedIterator object is an iterator which has in addition a method head. This</p>
</li>
<li>
<p>method returns the element which would otherwise have been returned by next,</p>
</li>
<li>
<p>but does not advance beyond that element. Hence, the element returned by head</p>
</li>
<li>
<p>is returned again by the next call to head or next. Here is the deﬁnition of the</p>
</li>
<li>
<p>BufferedIterator trait.</p>
</li>
</ul>
<p>trait BufferedIterator[+A] extends Iterator[A] {</p>
<p>def head: A</p>
<p>}</p>
<ul>
<li>
<p>Since map, flatMap, filter, and foreach exist for iterators, it follows that for-</p>
</li>
<li>
<p>comprehensions and for-loops can also be used on iterators. For instance, the ap-</p>
</li>
<li>
<p>plication which prints the squares of numbers between 1 and 100 could have equiv-</p>
</li>
<li>
<p>alently been expressed as follows.</p>
</li>
</ul>
<p>for (i &lt;- Iterator.range(1, 100))</p>
<p>println(i * i)</p>
<ul>
<li>
<p>Zip. Method zip takes another iterator and returns an iterator consisting of pairs</p>
</li>
<li>
<p>of corresponding elements returned by the two iterators.</p>
</li>
</ul>
<p>def zip[B](that: Iterator[B]) = new Iterator[(A, B)] {</p>
<p>def hasNext = Iterator.this.hasNext &amp;&amp; that.hasNext</p>
<p>def next = (Iterator.this.next, that.next)</p>
<p>}</p>
<p>}</p>
<p>Iterators</p>
<h3 id="132-constructing-iterators">13.2 Constructing Iterators</h3>
<p>Concrete iterators need to provide implementations for the two abstract methodsnext and hasNext in class Iterator. The simplest iterator is Iterator.empty whichalways returns an empty sequence:</p>
<p>object Iterator {</p>
<p>object empty extends Iterator[Nothing] {</p>
<p>def hasNext = false</p>
<p>def next = error(&ldquo;next on empty iterator&rdquo;)</p>
<p>}</p>
<p>A more interesting iterator enumerates all elements of an array. This iterator is con-structed by the fromArray method, which is also deﬁned in the object Iterator</p>
<p>def fromArray[A](xs: Array[A]) = new Iterator[A] {</p>
<p>private var i = 0</p>
<p>def hasNext: Boolean =</p>
<p>i &lt; xs.length</p>
<p>def next: A =</p>
<p>if (i &lt; xs.length) { val x = xs(i); i += 1; x }</p>
<p>else error(&ldquo;next on empty iterator&rdquo;)</p>
<p>}</p>
<p>Another iterator enumerates an integer interval. The Iterator.range function re-turns an iterator which traverses a given interval of integer values. It is deﬁned asfollows.</p>
<p>object Iterator {</p>
<p>def range(start: Int, end: Int) = new Iterator[Int] {</p>
<p>private var current = start</p>
<p>def hasNext = current &lt; end</p>
<p>def next = {</p>
<p>val r = current</p>
<p>if (current &lt; end) current += 1</p>
<p>else error(&ldquo;end of iterator&rdquo;)</p>
<p>r</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>All iterators seen so far terminate eventually. It is also possible to deﬁne iteratorsthat go on forever. For instance, the following iterator returns successive integersfrom some start value1.</p>
<p>1Due to the ﬁnite representation of type int, numbers will wrap around at 231.</p>
<ul>
<li>13.3 Using Iterators</li>
</ul>
<p>def from(start: Int) = new Iterator[Int] {</p>
<p>private var last = start - 1</p>
<p>def hasNext = true</p>
<p>def next = { last += 1; last }</p>
<p>}</p>
<h3 id="133-using-iterators">13.3 Using Iterators</h3>
<ul>
<li>
<p>Here are two more examples how iterators are used. First, to print all elements of an</p>
</li>
<li>
<p>array xs: Array[Int], one can write:</p>
</li>
</ul>
<p>Iterator.fromArray(xs) foreach (x =&gt; println(x))</p>
<ul>
<li>Or, using a for-comprehension:</li>
</ul>
<p>for (x &lt;- Iterator.fromArray(xs))</p>
<p>println(x)</p>
<ul>
<li>
<p>As a second example, consider the problem of ﬁnding the indices of all the elements</p>
</li>
<li>
<p>in an array of doubles greater than some limit. The indices should be returned as</p>
</li>
<li>
<p>an iterator. This is achieved by the following expression.</p>
</li>
</ul>
<p>import Iterator._</p>
<p>fromArray(xs)</p>
<p>.zip(from(0))</p>
<p>.filter(case (x, i) =&gt; x &gt; limit)</p>
<p>.map(case (x, i) =&gt; i)</p>
<ul>
<li>Or, using a for-comprehension:</li>
</ul>
<p>import Iterator._</p>
<p>for ((x, i) &lt;- fromArray(xs) zip from(0); x &gt; limit)</p>
<p>yield i</p>
<p>Chapter 14</p>
<h2 id="lazy-values">Lazy Values</h2>
<p>Lazy values provide a way to delay initialization of a value until the ﬁrst time it is</p>
<p>accessed. This may be useful when dealing with values that might not be needed</p>
<p>during execution, and whose computational cost is signifﬁcant. As a ﬁrst example,</p>
<p>let’s consider a database of employees, containing for each employee its manager</p>
<p>and its team.</p>
<p>case class Employee(id: Int,</p>
<p>name: String,</p>
<p>managerId: Int) {</p>
<p>val manager: Employee = Db.get(managerId)</p>
<p>val team: List[Employee] = Db.team(id)</p>
<p>}</p>
<ul>
<li>
<p>The Employee class given above will eagerly initialize all its ﬁelds, loading the whole</p>
</li>
<li>
<p>employee table in memory. This is certainly not optimal, and it can be easily im-</p>
</li>
<li>
<p>proved my making the ﬁelds lazy. This way we delay the database access until it is</p>
</li>
<li>
<p>really needed, if it is ever needed.</p>
</li>
</ul>
<p>case class Employee(id: Int,</p>
<p>name: String,</p>
<p>managerId: Int) {</p>
<p>lazy val manager: Employee = Db.get(managerId)</p>
<p>lazy val team: List[Employee] = Db.team(id)</p>
<p>}</p>
<ul>
<li>
<p>To see what is really happening, we can use this mockup database which shows</p>
</li>
<li>
<p>when records are fetched:</p>
</li>
</ul>
<p>object Db {</p>
<p>val table = Map(1 -&gt; (1, &ldquo;Haruki Murakami&rdquo;, -1),</p>
<p>2 -&gt; (2, &ldquo;Milan Kundera&rdquo;, 1),</p>
<p>Lazy Values3 -&gt; (3, &ldquo;Jeffrey Eugenides&rdquo;, 1),</p>
<p>4 -&gt; (4, &ldquo;Mario Vargas Llosa&rdquo;, 1),</p>
<p>5 -&gt; (5, &ldquo;Julian Barnes&rdquo;, 2))</p>
<p>def team(id: Int) = {</p>
<p>for (rec &lt;- table.values.toList; if rec._3 == id)</p>
<p>yield recToEmployee(rec)</p>
<p>}</p>
<p>def get(id: Int) = recToEmployee(table(id))</p>
<p>private def recToEmployee(rec: (Int, String, Int)) = {</p>
<p>println(&quot;[db] fetching &quot; + rec._1)</p>
<p>Employee(rec._1, rec._2, rec._3)</p>
<p>}</p>
<p>}</p>
<p>The output when running a program that retrieves one employee conﬁrms that thedatabase is only accessed when referring the lazy values.</p>
<p>Another use of lazy values is to resolve the initialization order of applications com-posed of several modules. Before lazy values were introduced, the same effect wasachieved by using object deﬁnitions. As a second example, we consider a compilercomposed of several modules. We look ﬁrst at a simple symbol table that deﬁnes aclass for symbols and two predeﬁned functions.</p>
<p>class Symbols(val compiler: Compiler) {</p>
<p>import compiler.types._</p>
<p>val Add = new Symbol(&ldquo;+&rdquo;, FunType(List(IntType, IntType), IntType))</p>
<p>val Sub = new Symbol(&quot;-&rdquo;, FunType(List(IntType, IntType), IntType))</p>
<p>class Symbol(name: String, tpe: Type) {</p>
<p>override def toString = name + &ldquo;: &quot; + tpe</p>
<p>}</p>
<p>}</p>
<p>The symbols module is parameterized with a Compiler instance, which provides ac-cess to other services, such as the types module. In our example there are only twopredeﬁned functions, addition and subtraction, and their deﬁnitions depend on thetypes module.</p>
<p>class Types(val compiler: Compiler) {</p>
<p>import compiler.symtab._</p>
<p>abstract class Type</p>
<p>case class FunType(args: List[Type], res: Type) extends Type</p>
<p>case class NamedType(sym: Symbol) extends Type</p>
<p>case object IntType extends Type</p>
<p>}</p>
<ul>
<li>
<p>In order to hook the two components together a compiler object is created and</p>
</li>
<li>
<p>passed as an argument to the two components.</p>
</li>
</ul>
<p>class Compiler {</p>
<p>val symtab = new Symbols(this)</p>
<p>val types = new Types(this)</p>
<p>}</p>
<ul>
<li>
<p>Unfortunately, the straight-forward approach fails at runtime because the symtab</p>
</li>
<li>
<p>module needs the types module. In general, the dependency between modules</p>
</li>
<li>
<p>can be complicated and getting the right initialization order is difﬁcult, or even im-</p>
</li>
<li>
<p>possible when there are cycles. The easy ﬁx is to make such ﬁelds lazy and let the</p>
</li>
<li>
<p>compiler ﬁgure out the right order.</p>
</li>
</ul>
<p>class Compiler {</p>
<p>lazy val symtab = new Symbols(this)</p>
<p>lazy val types = new Types(this)</p>
<p>}</p>
<p>Now the two modules are initialized on ﬁrst access, and the compiler may run as</p>
<p>expected.</p>
<p>Syntax</p>
<p>The lazy modiﬁer is allowed only on concrete value deﬁnitions. All typing rules</p>
<p>for value deﬁnitions apply for lazy values as well, with one restriction removed:</p>
<p>recursive local values are allowed.</p>
<p>Chapter 15</p>
<h2 id="implicit-parameters-and-conversions">Implicit Parameters and Conversions</h2>
<p>Implicit parameters and conversions are powerful tools for custimizing existing li-</p>
<p>braries and for creating high-level abstractions. As an example, let’s start with an</p>
<p>abstract class of semi-groups that support an unspeciﬁed add operation.</p>
<p>abstract class SemiGroup[A] {</p>
<p>def add(x: A, y: A): A</p>
<p>}</p>
<ul>
<li>Here’s a subclass Monoid of SemiGroup which adds a unit element.</li>
</ul>
<p>abstract class Monoid[A] extends SemiGroup[A] {</p>
<p>def unit: A</p>
<p>}</p>
<ul>
<li>Here are two implementations of monoids:</li>
</ul>
<p>object stringMonoid extends Monoid[String] {</p>
<p>def add(x: String, y: String): String = x.concat(y)</p>
<p>def unit: String = &quot;&rdquo;</p>
<p>}</p>
<p>object intMonoid extends Monoid[Int] {</p>
<p>def add(x: Int, y: Int): Int = x + y</p>
<p>def unit: Int = 0</p>
<p>}</p>
<ul>
<li>
<p>A sum method, which works over arbitrary monoids, can be written in plain Scala as</p>
</li>
<li>
<p>follows.</p>
</li>
</ul>
<p>def sum[A](xs: List[A])(m: Monoid[A]): A =</p>
<p>Implicit Parameters and Conversionsif (xs.isEmpty) m.unit</p>
<p>else m.add(xs.head, sum(m)(xs.tail)</p>
<p>This sum method can be called as follows:</p>
<p>sum(List(&ldquo;a&rdquo;, &ldquo;bc&rdquo;, &ldquo;def&rdquo;))(stringMonoid)</p>
<p>sum(List(1, 2, 3))(intMonoid)</p>
<p>All this works, but it is not very nice. The problem is that the monoid implementa-tions have to be passed into all code that uses them. We would sometimes wish thatthe system could ﬁgure out the correct arguments automatically, similar to what isdone when type arguments are inferred. This is what implicit parameters provide.Implicit Parameters: The Basics</p>
<p>In Scala 2 there is a new implicit keyword that can be used at the beginning of aparameter list. Syntax:</p>
<p>ParamClauses ::= {‘(’ [Param {‘,’ Param}] ’)’}</p>
<p>[‘(’ implicit Param {‘,’ Param} ‘)’]</p>
<p>If the keyword is present, it makes all parameters in the list implicit. For instance,the following version of sum has m as an implicit parameter.</p>
<p>def sum[A](xs: List[A])(implicit m: Monoid[A]): A =</p>
<p>if (xs.isEmpty) m.unit</p>
<p>else m.add(xs.head, sum(xs.tail))</p>
<p>As can be seen from the example, it is possible to combine normal and implicitparameters. However, there may only be one implicit parameter list for a method orconstructor, and it must come last.</p>
<p>implicit can also be used as a modiﬁer for deﬁnitions and declarations. Examples:implicit object stringMonoid extends Monoid[String] {</p>
<p>def add(x: String, y: String): String = x.concat(y)</p>
<p>def unit: String = &quot;&rdquo;</p>
<p>}</p>
<p>implicit object intMonoid extends Monoid[Int] {</p>
<p>def add(x: Int, y: Int): Int = x + y</p>
<p>def unit: Int = 0</p>
<p>}</p>
<p>The principal idea behind implicit parameters is that arguments for them can be leftout from a method call. If the arguments corresponding to an implicit parametersection are missing, they are inferred by the Scala compiler.</p>
<ul>
<li>
<p>The actual arguments that are eligible to be passed to an implicit parameter are all</p>
</li>
<li>
<p>identiﬁers X that can be accessed at the point of the method call without a preﬁx</p>
</li>
<li>
<p>and that denote an implicit deﬁnition or parameter.</p>
</li>
<li>
<p>If there are several eligible arguments which match the implicit parameter’s type,</p>
</li>
<li>
<p>the Scala compiler will chose a most speciﬁc one, using the standard rules of static</p>
</li>
<li>
<p>overloading resolution. For instance, assume the call</p>
</li>
</ul>
<p>sum(List(1, 2, 3))</p>
<ul>
<li>
<p>in a context where stringMonoid and intMonoid are visible. We know that the formal</p>
</li>
<li>
<p>type parameter a of sum needs to be instantiated to int. The only eligible value</p>
</li>
<li>
<p>which matches the implicit formal parameter type Monoid[Int] is intMonoid so this</p>
</li>
<li>
<p>object will be passed as implicit parameter.</p>
</li>
<li>
<p>This discussion also shows that implicit parameters are inferred after any type ar-</p>
</li>
<li>
<p>guments are inferred.</p>
</li>
<li>
<p>Implicit Conversions</p>
</li>
<li>
<p>Say you have an expression E of type T which is expected to type S. T does not con-</p>
</li>
<li>
<p>form to S and is not convertible to S by some other predeﬁned conversion. Then the</p>
</li>
<li>
<p>Scala compiler will try to apply as last resort an implicit conversion I (E). Here, I is</p>
</li>
<li>
<p>an identiﬁer denoting an implicit deﬁnition or parameter that is accessible without</p>
</li>
<li>
<p>a preﬁx at the point of the conversion, that can be applied to arguments of type T</p>
</li>
<li>
<p>and whose result type conforms to the expected type S.</p>
</li>
<li>
<p>Implicit conversions can also be applied in member selections. Given a selection</p>
</li>
<li>
<p>E.x where x is not a member of the type E, the Scala compiler will try to insert an</p>
</li>
<li>
<p>implicit conversion I (E).x, so that x is a member of I (E).</p>
</li>
<li>
<p>Here is an example of an implicit conversion function that converts integers into</p>
</li>
<li>
<p>instances of class scala.Ordered:</p>
</li>
</ul>
<p>implicit def int2ordered(x: Int): Ordered[Int] = new Ordered[Int] {</p>
<p>def compare(y: Int): Int =</p>
<p>if (x &lt; y) -1</p>
<p>else if (x &gt; y) 1</p>
<p>else 0</p>
<p>}</p>
<ul>
<li>
<p>View Bounds</p>
</li>
<li>
<p>View bounds are convenient syntactic sugar for implicit parameters. Consider for</p>
</li>
<li>
<p>instance a generic sort method:</p>
</li>
</ul>
<p>def sort[A &lt;% Ordered[A]](xs: List[A]): List[A] =</p>
<p>if (xs.isEmpty || xs.tail.isEmpty) xs</p>
<p>else {</p>
<p>Implicit Parameters and Conversionsval {ys, zs} = xs.splitAt(xs.length / 2)</p>
<p>merge(ys, zs)</p>
<p>}</p>
<p>The view bounded type parameter [a &lt;% Ordered[a]] expresses that sort is ap-plicable to lists of type a such that there exists an implicit conversion from a toOrdered[a]. The deﬁnition is treated as a shorthand for the following method sig-nature with an implicit parameter:</p>
<p>def sort[A](xs: List[A])(implicit c: A =&gt; Ordered[A]): List[A] = &hellip;</p>
<p>(Here, the parameter name c is chosen arbitrarily in a way that does not collide withother names in the program.)</p>
<p>As a more detailed example, consider the merge method that comes with the sortmethod above:</p>
<p>def merge[A &lt;% Ordered[A]](xs: List[A], ys: List[A]): List[A] =</p>
<p>if (xs.isEmpty) ys</p>
<p>else if (ys.isEmpty) xs</p>
<p>else if (xs.head &lt; ys.head) xs.head :: merge(xs.tail, ys)</p>
<p>else if ys.head :: merge(xs, ys.tail)</p>
<p>After expanding view bounds and inserting implicit conversions, this method im-plementation becomes:</p>
<p>def merge[A](xs: List[A], ys: List[A])</p>
<p>(implicit c: A =&gt; Ordered[A]): List[A] =</p>
<p>if (xs.isEmpty) ys</p>
<p>else if (ys.isEmpty) xs</p>
<p>else if (c(xs.head) &lt; ys.head) xs.head :: merge(xs.tail, ys)</p>
<p>else if ys.head :: merge(xs, ys.tail)(c)</p>
<p>The last two lines of this method deﬁnition illustrate two different uses of the im-plicit parameter c. It is applied in a conversion in the condition of the second to lastline, and it is passed as implicit argument in the recursive call to merge on the lastline.</p>
<p>Chapter 16</p>
<h2 id="hindleymilner-type-inference">Hindley/Milner Type Inference</h2>
<p>This chapter demonstrates Scala’s data types and pattern matching by developing a</p>
<p>type inference system in the Hindley/Milner style [Mil78]. The source language for</p>
<p>the type inferencer is lambda calculus with a let construct called Mini-ML. Abstract</p>
<p>syntax trees for the Mini-ML are represented by the following data type of Terms.</p>
<p>abstract class Term {}</p>
<p>case class Var(x: String) extends Term {</p>
<p>override def toString = x</p>
<p>}</p>
<p>case class Lam(x: String, e: Term) extends Term {</p>
<p>override def toString = &ldquo;(\&rdquo; + x + &ldquo;.&rdquo; + e + &ldquo;)&rdquo;</p>
<p>}</p>
<p>case class App(f: Term, e: Term) extends Term {</p>
<p>override def toString = &ldquo;(&rdquo; + f + &quot; &quot; + e + &ldquo;)&rdquo;</p>
<p>}</p>
<p>case class Let(x: String, e: Term, f: Term) extends Term {</p>
<p>override def toString = &ldquo;let &quot; + x + &quot; = &quot; + e + &quot; in &quot; + f</p>
<p>}</p>
<ul>
<li>
<p>There are four tree constructors: Var for variables, Lam for function abstractions, App</p>
</li>
<li>
<p>for function applications, and Let for let expressions. Each case class overrides the</p>
</li>
<li>
<p>toString method of class Any, so that terms can be printed in legible form.</p>
</li>
<li>
<p>We next deﬁne the types that are computed by the inference system.</p>
</li>
</ul>
<p>sealed abstract class Type {}</p>
<p>case class Tyvar(a: String) extends Type {</p>
<p>override def toString = a</p>
<p>}</p>
<p>case class Arrow(t1: Type, t2: Type) extends Type {</p>
<p>override def toString = &ldquo;(&rdquo; + t1 + &ldquo;-&gt;&rdquo; + t2 + &ldquo;)&rdquo;</p>
<p>}</p>
<p>Hindley/Milner Type Inferencecase class Tycon(k: String, ts: List[Type]) extends Type {</p>
<p>override def toString =</p>
<p>k + (if (ts.isEmpty) &quot;&rdquo; else ts.mkString(&quot;[&rdquo;, &ldquo;,&rdquo;, &ldquo;]&quot;))</p>
<p>}</p>
<p>There are three type constructors: Tyvar for type variables, Arrow for function typesand Tycon for type constructors such as Boolean or List. Type constructors have ascomponent a list of their type parameters. This list is empty for type constants suchas Boolean. Again, the type constructors implement the toString method in orderto display types legibly.</p>
<p>Note that Type is a sealed class. This means that no subclasses or data constructorsthat extend Type can be formed outside the sequence of deﬁnitions in which Type isdeﬁned. This makes Type a closed algebraic data type with exactly three alternatives.By contrast, type Term is an open algebraic type for which further alternatives can bedeﬁned.</p>
<p>The main parts of the type inferencer are contained in object typeInfer. We startwith a utility function which creates fresh type variables:</p>
<p>object typeInfer {</p>
<p>private var n: Int = 0</p>
<p>def newTyvar(): Type = { n += 1; Tyvar(&ldquo;a&rdquo; + n) }</p>
<p>We next deﬁne a class for substitutions. A substitution is an idempotent functionfrom type variables to types. It maps a ﬁnite number of type variables to some types,and leaves all other type variables unchanged. The meaning of a substitution isextended point-wise to a mapping from types to types. We also extend the meaningof substitution to environments, which are deﬁned later.</p>
<p>abstract class Subst extends Function1[Type,Type] {</p>
<p>def lookup(x: Tyvar): Type</p>
<p>def apply(t: Type): Type = t match {</p>
<p>case tv @ Tyvar(a) =&gt; val u = lookup(tv); if (t == u) t else apply(u)case Arrow(t1, t2) =&gt; Arrow(apply(t1), apply(t2))</p>
<p>case Tycon(k, ts) =&gt; Tycon(k, ts map apply)</p>
<p>}</p>
<p>def apply(env: Env): Env = env.map({ case (x, TypeScheme(tyvars, tpe)) =&gt;// assumes tyvars don’t occur in this substitution</p>
<p>(x, TypeScheme(tyvars, apply(tpe)))</p>
<p>})</p>
<p>def extend(x: Tyvar, t: Type) = new Subst {</p>
<p>def lookup(y: Tyvar): Type = if (x == y) t else Subst.this.lookup(y)}</p>
<p>}</p>
<p>val emptySubst = new Subst { def lookup(t: Tyvar): Type = t }</p>
<ul>
<li>
<p>We represent substitutions as functions, of type Type =&gt; Type. This is achieved by</p>
</li>
<li>
<p>making class Subst inherit from the unary function type Function1[Type, Type]1.</p>
</li>
<li>
<p>To be an instance of this type, a substitution s has to implement an apply method</p>
</li>
<li>
<p>that takes a Type as argument and yields another Type as result. A function applica-</p>
</li>
<li>
<p>tion s(t) is then interpreted as s.apply(t).</p>
</li>
<li>
<p>The lookup method is abstract in class Subst. There are two concrete forms of sub-</p>
</li>
<li>
<p>stitutions which differ in how they implement this method. One form is deﬁned by</p>
</li>
<li>
<p>the emptySubst value, the other is deﬁned by the extend method in class Subst.</p>
</li>
<li>
<p>The next data type describes type schemes, which consist of a type and a list of</p>
</li>
<li>
<p>names of type variables which appear universally quantiﬁed in the type scheme. For</p>
</li>
<li>
<p>instance, the type scheme ∀a∀b.a→b would be represented in the type checker as:</p>
</li>
</ul>
<p>TypeScheme(List(Tyvar(&ldquo;a&rdquo;), Tyvar(&ldquo;b&rdquo;)), Arrow(Tyvar(&ldquo;a&rdquo;), Tyvar(&ldquo;b&rdquo;))) .</p>
<ul>
<li>
<p>The class deﬁnition of type schemes does not carry an extends clause; this means</p>
</li>
<li>
<p>that type schemes extend directly class AnyRef. Even though there is only one pos-</p>
</li>
<li>
<p>sible way to construct a type scheme, a case class representation was chosen since</p>
</li>
<li>
<p>it offers convenient ways to decompose an instance of this type into its parts.</p>
</li>
</ul>
<p>case class TypeScheme(tyvars: List[Tyvar], tpe: Type) {</p>
<p>def newInstance: Type = {</p>
<p>(emptySubst /: tyvars) ((s, tv) =&gt; s.extend(tv, newTyvar())) (tpe)</p>
<p>}</p>
<p>}</p>
<ul>
<li>
<p>Type scheme objects come with a method newInstance, which returns the type con-</p>
</li>
<li>
<p>tained in the scheme after all universally type variables have been renamed to fresh</p>
</li>
<li>
<p>variables. The implementation of this method folds (with /:) the type scheme’s</p>
</li>
<li>
<p>type variables with an operation which extends a given substitution s by renaming</p>
</li>
<li>
<p>a given type variable tv to a fresh type variable. The resulting substitution renames</p>
</li>
<li>
<p>all type variables of the scheme to fresh ones. This substitution is then applied to</p>
</li>
<li>
<p>the type part of the type scheme.</p>
</li>
<li>
<p>The last type we need in the type inferencer is Env, a type for environments, which</p>
</li>
<li>
<p>associate variable names with type schemes. They are represented by a type alias</p>
</li>
<li>
<p>Env in module typeInfer:</p>
</li>
</ul>
<p>type Env = List[(String, TypeScheme)]</p>
<p>1 The class inherits the function type as a mixin rather than as a direct superclass. This is because</p>
<ul>
<li>
<p>in the current Scala implementation, the Function1 type is a Java interface, which cannot be used as</p>
</li>
<li>
<p>a direct superclass of some other class.</p>
</li>
</ul>
<p>Hindley/Milner Type InferenceThere are two operations on environments. The lookup function returns the typescheme associated with a given name, or null if the name is not recorded in theenvironment.</p>
<p>def lookup(env: Env, x: String): TypeScheme = env match {</p>
<p>case List() =&gt; null</p>
<p>case (y, t) :: env1 =&gt; if (x == y) t else lookup(env1, x)</p>
<p>}</p>
<p>The gen function turns a given type into a type scheme, quantifying over all typevariables that are free in the type, but not in the environment.</p>
<p>def gen(env: Env, t: Type): TypeScheme =</p>
<p>TypeScheme(tyvars(t) diff tyvars(env), t)</p>
<p>The set of free type variables of a type is simply the set of all type variables which oc-cur in the type. It is represented here as a list of type variables, which is constructedas follows.</p>
<p>def tyvars(t: Type): List[Tyvar] = t match {</p>
<p>case tv @ Tyvar(a) =&gt;</p>
<p>List(tv)</p>
<p>case Arrow(t1, t2) =&gt;</p>
<p>tyvars(t1) union tyvars(t2)</p>
<p>case Tycon(k, ts) =&gt;</p>
<p>(List<a href="">Tyvar</a> /: ts) ((tvs, t) =&gt; tvs union tyvars(t))</p>
<p>}</p>
<p>Note that the syntax tv @ &hellip; in the ﬁrst pattern introduces a variable which isbound to the pattern that follows. Note also that the explicit type parameter [Tyvar]in the expression of the third clause is needed to make local type inference work.</p>
<p>The set of free type variables of a type scheme is the set of free type variables of itstype component, excluding any quantiﬁed type variables:</p>
<p>def tyvars(ts: TypeScheme): List[Tyvar] =</p>
<p>tyvars(ts.tpe) diff ts.tyvars</p>
<p>Finally, the set of free type variables of an environment is the union of the free typevariables of all type schemes recorded in it.</p>
<p>def tyvars(env: Env): List[Tyvar] =</p>
<p>(List<a href="">Tyvar</a> /: env) ((tvs, nt) =&gt; tvs union tyvars(nt._2))</p>
<p>A central operation of Hindley/Milner type checking is uniﬁcation, which computesa substitution to make two given types equal (such a substitution is called a uniﬁer).Function mgu computes the most general uniﬁer of two given types t and u under apre-existing substitution s. That is, it returns the most general substitution s</p>
<p>which(cid:48)</p>
<ul>
<li>extends s, and which makes s</li>
</ul>
<p>(cid:48)</p>
<p>(t) and s</p>
<p>(cid:48)</p>
<p>(u) equal types.</p>
<p>def mgu(t: Type, u: Type, s: Subst): Subst = (s(t), s(u)) match {</p>
<p>case (Tyvar(a), Tyvar(b)) if (a == b) =&gt;</p>
<p>s</p>
<p>case (st @ Tyvar(a), su) if !(tyvars(su) contains st) =&gt;</p>
<p>s.extend(st, su)</p>
<p>case (_, Tyvar(a)) =&gt;</p>
<p>mgu(u, t, s)</p>
<p>case (Arrow(t1, t2), Arrow(u1, u2)) =&gt;</p>
<p>mgu(t1, u1, mgu(t2, u2, s))</p>
<p>case (Tycon(k1, ts), Tycon(k2, us)) if (k1 == k2) =&gt;</p>
<p>(s /: (ts zip us)) ((s, tu) =&gt; mgu(tu._1, tu._2, s))</p>
<p>case _ =&gt;</p>
<p>throw new TypeError(&ldquo;cannot unify &quot; + s(t) + &quot; with &quot; + s(u))</p>
<p>}</p>
<ul>
<li>
<p>The mgu function throws a TypeError exception if no uniﬁer substitution exists. This</p>
</li>
<li>
<p>can happen because the two types have different type constructors at correspond-</p>
</li>
<li>
<p>ing places, or because a type variable is uniﬁed with a type that contains the type</p>
</li>
<li>
<p>variable itself. Such exceptions are modeled here as instances of case classes that</p>
</li>
<li>
<p>inherit from the predeﬁned Exception class.</p>
</li>
</ul>
<p>case class TypeError(s: String) extends Exception(s) {}</p>
<ul>
<li>
<p>The main task of the type checker is implemented by function tp. This function</p>
</li>
<li>
<p>takes as parameters an environment env, a term e, a proto-type t, and a pre-existing</p>
</li>
<li>
<p>substitution s. The function yields a substitution s</p>
</li>
</ul>
<p>that extends s and that turns</p>
<p>(env) (cid:96) e : s</p>
<p>(cid:48)</p>
<ul>
<li>s</li>
</ul>
<p>(t) into a derivable type judgment according to the derivation rules</p>
<ul>
<li>
<p>of the Hindley/Milner type system [Mil78]. A TypeError exception is thrown if no</p>
</li>
<li>
<p>such substitution exists.</p>
</li>
</ul>
<p>(cid:48)</p>
<p>(cid:48)</p>
<p>def tp(env: Env, e: Term, t: Type, s: Subst): Subst = {</p>
<p>current = e</p>
<p>e match {</p>
<p>case Var(x) =&gt;</p>
<p>val u = lookup(env, x)</p>
<p>if (u == null) throw new TypeError(&ldquo;undefined: &quot; + x)</p>
<p>else mgu(u.newInstance, t, s)</p>
<p>case Lam(x, e1) =&gt;</p>
<p>val a, b = newTyvar()</p>
<p>val s1 = mgu(t, Arrow(a, b), s)</p>
<p>val env1 = {x, TypeScheme(List(), a)} :: env</p>
<p>tp(env1, e1, b, s1)</p>
<p>case App(e1, e2) =&gt;</p>
<p>Hindley/Milner Type Inferenceval a = newTyvar()</p>
<p>val s1 = tp(env, e1, Arrow(a, t), s)</p>
<p>tp(env, e2, a, s1)</p>
<p>case Let(x, e1, e2) =&gt;</p>
<p>val a = newTyvar()</p>
<p>val s1 = tp(env, e1, a, s)</p>
<p>tp({x, gen(s1(env), s1(a))} :: env, e2, t, s1)</p>
<p>}</p>
<p>}</p>
<p>var current: Term = null</p>
<p>To aid error diagnostics, the tp function stores the currently analyzed sub-term invariable current. Thus, if type checking is aborted with a TypeError exception, thisvariable will contain the subterm that caused the problem.</p>
<p>The last function of the type inference module, typeOf, is a simpliﬁed facade fortp. It computes the type of a given term e in a given environment env. It doesso by creating a fresh type variable a, computing a typing substitution that makesenv (cid:96) e : a into a derivable type judgment, and returning the result of applying thesubstitution to a.</p>
<p>def typeOf(env: Env, e: Term): Type = {</p>
<p>val a = newTyvar()</p>
<p>tp(env, e, a, emptySubst)(a)</p>
<p>}</p>
<p>}// end typeInfer</p>
<p>To apply the type inferencer, it is convenient to have a predeﬁned environment thatcontains bindings for commonly used constants. The module predefined deﬁnesan environment env that contains bindings for the types of booleans, numbers andlists together with some primitive operations over them. It also deﬁnes a ﬁxed pointoperator fix, which can be used to represent recursion.</p>
<p>object predefined {</p>
<p>val booleanType = Tycon(&ldquo;Boolean&rdquo;, List())</p>
<p>val intType = Tycon(&ldquo;Int&rdquo;, List())</p>
<p>def listType(t: Type) = Tycon(&ldquo;List&rdquo;, List(t))</p>
<p>private def gen(t: Type): typeInfer.TypeScheme = typeInfer.gen(List(), t)private val a = typeInfer.newTyvar()</p>
<p>val env = List(</p>
<p>{&ldquo;true&rdquo;, gen(booleanType)},</p>
<p>{&ldquo;false&rdquo;, gen(booleanType)},</p>
<p>{&ldquo;if&rdquo;, gen(Arrow(booleanType, Arrow(a, Arrow(a, a))))},</p>
<p>{&ldquo;zero&rdquo;, gen(intType)},</p>
<p>{&ldquo;succ&rdquo;, gen(Arrow(intType, intType))},</p>
<p>{&ldquo;nil&rdquo;, gen(listType(a))},</p>
<p>{&ldquo;cons&rdquo;, gen(Arrow(a, Arrow(listType(a), listType(a))))},</p>
<p>{&ldquo;isEmpty&rdquo;, gen(Arrow(listType(a), booleanType))},</p>
<p>{&ldquo;head&rdquo;, gen(Arrow(listType(a), a))},</p>
<p>{&ldquo;tail&rdquo;, gen(Arrow(listType(a), listType(a)))},</p>
<p>{&ldquo;fix&rdquo;, gen(Arrow(Arrow(a, a), a))}</p>
<p>)</p>
<p>}</p>
<ul>
<li>
<p>Here’s an example how the type inferencer can be used. Let’s deﬁne a function</p>
</li>
<li>
<p>showType which returns the type of a given term computed in the predeﬁned en-</p>
</li>
<li>
<p>vironment Predefined.env:</p>
</li>
</ul>
<p>object testInfer {</p>
<p>def showType(e: Term): String =</p>
<p>try {</p>
<p>typeInfer.typeOf(predefined.env, e).toString</p>
<p>} catch {</p>
<p>case typeInfer.TypeError(msg) =&gt;</p>
<p>&ldquo;\n cannot type: &quot; + typeInfer.current +</p>
<p>&ldquo;\n reason: &quot; + msg</p>
<p>}</p>
<ul>
<li>Then the application</li>
</ul>
<blockquote>
<p>testInfer.showType(Lam(&ldquo;x&rdquo;, App(App(Var(&ldquo;cons&rdquo;), Var(&ldquo;x&rdquo;)), Var(&ldquo;nil&rdquo;))))- would give the response</p>
</blockquote>
<blockquote>
<p>(a6-&gt;List[a6])</p>
</blockquote>
<ul>
<li>
<p>Exercise 16.0.1 Extend the Mini-ML type inferencer with a letrec construct which</p>
</li>
<li>
<p>allows the deﬁnition of recursive functions. Syntax:</p>
</li>
</ul>
<p>letrec ident &ldquo;=&rdquo; term in term .</p>
<ul>
<li>
<p>The typing of letrec is as for let, except that the deﬁned identiﬁer is visible in the</p>
</li>
<li>
<p>deﬁning expression. Using letrec, the length function for lists can now be deﬁned</p>
</li>
<li>
<p>as follows.</p>
</li>
</ul>
<p>letrec length = \xs.</p>
<p>if (isEmpty xs)</p>
<p>zero</p>
<p>(succ (length (tail xs)))</p>
<p>in &hellip;</p>
<p>Chapter 17</p>
<h2 id="abstractions-for-concurrency">Abstractions for Concurrency</h2>
<p>This section reviews common concurrent programming patterns and shows how</p>
<p>they can be implemented in Scala.</p>
<h3 id="171-signals-and-monitors">17.1 Signals and Monitors</h3>
<ul>
<li>
<p>Example 17.1.1 The monitor provides the basic means for mutual exclusion of pro-</p>
</li>
<li>
<p>cesses in Scala. Every instance of class AnyRef can be used as a monitor by calling</p>
</li>
<li>
<p>one or more of the methods below.</p>
</li>
</ul>
<p>def synchronized[A] (e: =&gt; A): A</p>
<p>def wait()</p>
<p>def wait(msec: Long)</p>
<p>def notify()</p>
<p>def notifyAll()</p>
<ul>
<li>
<p>The synchronized method executes its argument computation e in mutual exclu-</p>
</li>
<li>
<p>sive mode – at any one time, only one thread can execute a synchronized argument</p>
</li>
<li>
<p>of a given monitor.</p>
</li>
<li>
<p>Threads can suspend inside a monitor by waiting on a signal. Threads that call the</p>
</li>
<li>
<p>wait method wait until a notify method of the same object is called subsequently</p>
</li>
<li>
<p>by some other thread. Calls to notify with no threads waiting for the signal are</p>
</li>
<li>
<p>ignored.</p>
</li>
<li>
<p>There is also a timed form of wait, which blocks only as long as no signal was re-</p>
</li>
<li>
<p>ceived or the speciﬁed amount of time (given in milliseconds) has elapsed. Fur-</p>
</li>
<li>
<p>thermore, there is a notifyAll method which unblocks all threads which wait for</p>
</li>
<li>
<p>the signal. These methods, as well as class Monitor are primitive in Scala; they are</p>
</li>
<li>
<p>implemented in terms of the underlying runtime system.</p>
</li>
</ul>
<p>Abstractions for ConcurrencyTypically, a thread waits for some condition to be established. If the condition doesnot hold at the time of the wait call, the thread blocks until some other thread hasestablished the condition. It is the responsibility of this other thread to wake upwaiting processes by issuing a notify or notifyAll. Note however, that there is noguarantee that a waiting process gets to run immediately after the call to notify is is-sued. It could be that other processes get to run ﬁrst which invalidate the conditionagain. Therefore, the correct form of waiting for a condition C uses a while loop:</p>
<p>while (!C ) wait()</p>
<p>As an example of how monitors are used, here is is an implementation of a boundedbuffer class.</p>
<p>class BoundedBuffer[A](N: Int) {</p>
<p>var in = 0, out = 0, n = 0</p>
<p>val elems = new Array<a href="N">A</a></p>
<p>def put(x: A) = synchronized {</p>
<p>while (n &gt;= N) wait()</p>
<p>elems(in) = x ; in = (in + 1) % N ; n = n + 1</p>
<p>if (n == 1) notifyAll()</p>
<p>}</p>
<p>def get: A = synchronized {</p>
<p>while (n == 0) wait()</p>
<p>val x = elems(out) ; out = (out + 1) % N ; n = n - 1</p>
<p>if (n == N - 1) notifyAll()</p>
<p>x</p>
<p>}</p>
<p>}</p>
<p>And here is a program using a bounded buffer to communicate between a producerand a consumer process.</p>
<p>import scala.concurrent.ops._</p>
<p>&hellip;</p>
<p>val buf = new BoundedBuffer<a href="10">String</a></p>
<p>spawn { while (true) { val s = produceString ; buf.put(s) } }</p>
<p>spawn { while (true) { val s = buf.get ; consumeString(s) } }</p>
<p>}</p>
<p>The spawn method spawns a new thread which executes the expression given in theparameter. It is deﬁned in object concurrent.ops as follows.</p>
<p>def spawn(p: =&gt; Unit) {</p>
<p>val t = new Thread() { override def run() = p }</p>
<p>t.start()</p>
<ul>
<li>17.2 SyncVars</li>
</ul>
<p>}</p>
<h3 id="172-syncvars">17.2 SyncVars</h3>
<ul>
<li>
<p>A synchronized variable (or syncvar for short) offers get and put operations to read</p>
</li>
<li>
<p>and set the variable. get operations block until the variable has been deﬁned. An</p>
</li>
<li>
<p>unset operation resets the variable to undeﬁned state.</p>
</li>
<li>
<p>Here’s the standard implementation of synchronized variables.</p>
</li>
</ul>
<p>package scala.concurrent</p>
<p>class SyncVar[A] {</p>
<p>private var isDefined: Boolean = false</p>
<p>private var value: A = _</p>
<p>def get = synchronized {</p>
<p>while (!isDefined) wait()</p>
<p>value</p>
<p>}</p>
<p>def set(x: A) = synchronized {</p>
<p>value = x; isDefined = true; notifyAll()</p>
<p>}</p>
<p>def isSet: Boolean = synchronized {</p>
<p>isDefined</p>
<p>}</p>
<p>def unset = synchronized {</p>
<p>isDefined = false</p>
<p>}</p>
<p>}</p>
<h3 id="173-futures">17.3 Futures</h3>
<ul>
<li>
<p>A future is a value which is computed in parallel to some other client thread, to be</p>
</li>
<li>
<p>used by the client thread at some future time. Futures are used in order to make</p>
</li>
<li>
<p>good use of parallel processing resources. A typical usage is:</p>
</li>
</ul>
<p>import scala.concurrent.ops._</p>
<p>&hellip;</p>
<p>val x = future(someLengthyComputation)</p>
<p>anotherLengthyComputation</p>
<p>val y = f(x()) + g(x())</p>
<ul>
<li>The future method is deﬁned in object scala.concurrent.ops as follows.</li>
</ul>
<p>def future[A](p: =&gt; A): Unit =&gt; A = {</p>
<p>}</p>
<p>val result = new SyncVar[A]</p>
<p>fork { result.set(p) }</p>
<p>(() =&gt; result.get)</p>
<p>Abstractions for ConcurrencyThe future method gets as parameter a computation p to be performed. The typeof the computation is arbitrary; it is represented by future’s type parameter a. Thefuture method deﬁnes a guard result, which takes a parameter representing theresult of the computation. It then forks off a new thread that computes the resultand invokes the result guard when it is ﬁnished. In parallel to this thread, the func-tion returns an anonymous function of type a. When called, this functions waits onthe result guard to be invoked, and, once this happens returns the result argument.At the same time, the function reinvokes the result guard with the same argument,so that future invocations of the function can return the result immediately.</p>
<h3 id="174-parallel-computations">17.4 Parallel Computations</h3>
<p>The next example presents a function par which takes a pair of computations asparameters and which returns the results of the computations in another pair. Thetwo computations are performed in parallel.</p>
<p>The function is deﬁned in object scala.concurrent.ops as follows.</p>
<p>def par[A, B](xp: =&gt; A, yp: =&gt; B): (A, B) = {</p>
<p>val y = new SyncVar[B]</p>
<p>spawn { y set yp }</p>
<p>(xp, y.get)</p>
<p>}</p>
<p>Deﬁned in the same place is a function replicate which performs a number ofreplicates of a computation in parallel. Each replication instance is passed an inte-ger number which identiﬁes it.</p>
<p>def replicate(start: Int, end: Int)(p: Int =&gt; Unit) {</p>
<p>if (start == end)</p>
<p>()</p>
<p>else if (start + 1 == end)</p>
<p>p(start)</p>
<p>else {</p>
<p>val mid = (start + end) / 2</p>
<p>spawn { replicate(start, mid)(p) }</p>
<p>replicate(mid, end)(p)</p>
<p>}</p>
<p>}</p>
<ul>
<li>
<p>17.5 Semaphores</p>
</li>
<li>
<p>The next function uses replicate to perform parallel computations on all elements</p>
</li>
<li>
<p>of an array.</p>
</li>
</ul>
<p>def parMap[A,B](f: A =&gt; B, xs: Array[A]): Array[B] = {</p>
<p>val results = new Array<a href="xs.length">B</a></p>
<p>replicate(0, xs.length) { i =&gt; results(i) = f(xs(i)) }</p>
<p>results</p>
<p>}</p>
<h3 id="175-semaphores">17.5 Semaphores</h3>
<ul>
<li>
<p>A common mechanism for process synchronization is a lock (or: semaphore). A lock</p>
</li>
<li>
<p>offers two atomic actions: acquire and release. Here’s the implementation of a lock</p>
</li>
<li>
<p>in Scala:</p>
</li>
</ul>
<p>package scala.concurrent</p>
<p>class Lock {</p>
<p>var available = true</p>
<p>def acquire = synchronized {</p>
<p>while (!available) wait()</p>
<p>available = false</p>
<p>}</p>
<p>def release = synchronized {</p>
<p>available = true</p>
<p>notify()</p>
<p>}</p>
<p>}</p>
<h3 id="176-readerswriters">17.6 Readers/Writers</h3>
<ul>
<li>
<p>A more complex form of synchronization distinguishes between readers which ac-</p>
</li>
<li>
<p>cess a common resource without modifying it and writers which can both access</p>
</li>
<li>
<p>and modify it. To synchronize readers and writers we need to implement opera-</p>
</li>
<li>
<p>tions startRead, startWrite, endRead, endWrite, such that:</p>
</li>
</ul>
<p>• there can be multiple concurrent readers,</p>
<p>• there can only be one writer at one time,</p>
<p>• pending write requests have priority over pending read requests, but don’t</p>
<p>preempt ongoing read operations.</p>
<ul>
<li>
<p>The following implementation of a readers/writers lock is based on the mailbox</p>
</li>
<li>
<p>concept (see Section 17.10).</p>
</li>
</ul>
<p>Abstractions for Concurrencyimport scala.concurrent._</p>
<p>class ReadersWriters {</p>
<p>val m = new MailBox</p>
<p>private case class Writers(n: Int), Readers(n: Int) { m send this }</p>
<p>Writers(0); Readers(0)</p>
<p>def startRead = m receive {</p>
<p>case Writers(n) if n == 0 =&gt; m receive {</p>
<p>case Readers(n) =&gt; Writers(0); Readers(n+1)</p>
<p>}</p>
<p>}</p>
<p>def startWrite = m receive {</p>
<p>case Writers(n) =&gt;</p>
<p>Writers(n+1)</p>
<p>m receive { case Readers(n) if n == 0 =&gt; }</p>
<p>}</p>
<p>def endRead = m receive {</p>
<p>case Readers(n) =&gt; Readers(n-1)</p>
<p>}</p>
<p>def endWrite = m receive {</p>
<p>case Writers(n) =&gt; Writers(n-1); if (n == 0) Readers(0)</p>
<p>}</p>
<p>}</p>
<h3 id="177-asynchronous-channels">17.7 Asynchronous Channels</h3>
<p>A fundamental way of interprocess communication is the asynchronous channel.Its implementation makes use the following simple class for linked lists:</p>
<p>class LinkedList[A] {</p>
<p>var elem: A = _</p>
<p>var next: LinkedList[A] = null</p>
<p>}</p>
<p>To facilitate insertion and deletion of elements into linked lists, every reference intoa linked list points to the node which precedes the node which conceptually formsthe top of the list. Empty linked lists start with a dummy node, whose successor isnull.</p>
<p>The channel class uses a linked list to store data that has been sent but not read yet.At the opposite end, threads that wish to read from an empty channel, register theirpresence by incrementing the nreaders ﬁeld and waiting to be notiﬁed.</p>
<p>package scala.concurrent</p>
<ul>
<li>17.8 Synchronous Channels</li>
</ul>
<p>class Channel[A] {</p>
<p>class LinkedList[A] {</p>
<p>var elem: A = _</p>
<p>var next: LinkedList[A] = null</p>
<p>}</p>
<p>private var written = new LinkedList[A]</p>
<p>private var lastWritten = written</p>
<p>private var nreaders = 0</p>
<p>def write(x: A) = synchronized {</p>
<p>lastWritten.elem = x</p>
<p>lastWritten.next = new LinkedList[A]</p>
<p>lastWritten = lastWritten.next</p>
<p>if (nreaders &gt; 0) notify()</p>
<p>}</p>
<p>def read: A = synchronized {</p>
<p>if (written.next == null) {</p>
<p>nreaders = nreaders + 1; wait(); nreaders = nreaders - 1</p>
<p>}</p>
<p>val x = written.elem</p>
<p>written = written.next</p>
<p>x</p>
<p>}</p>
<p>}</p>
<h3 id="178-synchronous-channels">17.8 Synchronous Channels</h3>
<ul>
<li>
<p>Here’s an implementation of synchronous channels, where the sender of a message</p>
</li>
<li>
<p>blocks until that message has been received. Synchronous channels only need a</p>
</li>
<li>
<p>single variable to store messages in transit, but three signals are used to coordinate</p>
</li>
<li>
<p>reader and writer processes.</p>
</li>
</ul>
<p>package scala.concurrent</p>
<p>class SyncChannel[A] {</p>
<p>private var data: A = _</p>
<p>private var reading = false</p>
<p>private var writing = false</p>
<p>def write(x: A) = synchronized {</p>
<p>while (writing) wait()</p>
<p>data = x</p>
<p>writing = true</p>
<p>Abstractions for Concurrency}</p>
<p>if (reading) notifyAll()</p>
<p>else while (!reading) wait()</p>
<p>def read: A = synchronized {</p>
<p>while (reading) wait()</p>
<p>reading = true</p>
<p>while (!writing) wait()</p>
<p>val x = data</p>
<p>writing = false</p>
<p>reading = false</p>
<p>notifyAll()</p>
<p>x</p>
<p>}</p>
<p>}</p>
<h3 id="179-workers">17.9 Workers</h3>
<p>Here’s an implementation of a compute server in Scala. The server implements afuture method which evaluates a given expression in parallel with its caller. Unlikethe implementation in Section 17.3 the server computes futures only with a prede-ﬁned number of threads. A possible implementation of the server could run eachthread on a separate processor, and could hence avoid the overhead inherent incontext-switching several threads on a single processor.</p>
<p>import scala.concurrent.<em>, scala.concurrent.ops.</em></p>
<p>class ComputeServer(n: Int) {</p>
<p>private abstract class Job {</p>
<p>type T</p>
<p>def task: T</p>
<p>def ret(x: T)</p>
<p>}</p>
<p>private val openJobs = new Channel<a href="">Job</a></p>
<p>private def processor(i: Int) {</p>
<p>while (true) {</p>
<p>val job = openJobs.read</p>
<p>job.ret(job.task)</p>
<p>}</p>
<p>}</p>
<ul>
<li>17.9 Workers</li>
</ul>
<p>def future[A](p: =&gt; A): () =&gt; A = {</p>
<p>val reply = new SyncVar<a href="">A</a></p>
<p>openJobs.write{</p>
<p>new Job {</p>
<p>type T = A</p>
<p>def task = p</p>
<p>def ret(x: A) = reply.set(x)</p>
<p>}</p>
<p>}</p>
<p>() =&gt; reply.get</p>
<p>}</p>
<p>spawn(replicate(0, n) { processor })</p>
<p>}</p>
<ul>
<li>
<p>Expressions to be computed (i.e. arguments to calls of future) are written to the</p>
</li>
<li>
<p>openJobs channel. A job is an object with</p>
</li>
</ul>
<p>• An abstract type T which describes the result of the compute job.</p>
<p>• A parameterless task method of type t which denotes the expression to be</p>
<p>computed.</p>
<p>• A ret method which consumes the result once it is computed.</p>
<ul>
<li>
<p>The compute server creates n processor processes as part of its initialization. Every</p>
</li>
<li>
<p>such process repeatedly consumes an open job, evaluates the job’s task method</p>
</li>
<li>
<p>and passes the result on to the job’s ret method. The polymorphic future method</p>
</li>
<li>
<p>creates a new job where the ret method is implemented by a guard named reply</p>
</li>
<li>
<p>and inserts this job into the set of open jobs. It then waits until the corresponding</p>
</li>
<li>
<p>reply guard is called.</p>
</li>
<li>
<p>The example demonstrates the use of abstract types. The abstract type t keeps track</p>
</li>
<li>
<p>of the result type of a job, which can vary between different jobs. Without abstract</p>
</li>
<li>
<p>types it would be impossible to implement the same class to the user in a statically</p>
</li>
<li>
<p>type-safe way, without relying on dynamic type tests and type casts.</p>
</li>
<li>
<p>Here is some code which uses the compute server to evaluate the expression 41 + 1.</p>
</li>
</ul>
<p>object Test with Executable {</p>
<p>val server = new ComputeServer(1)</p>
<p>val f = server.future(41 + 1)</p>
<p>println(f())</p>
<p>}</p>
<p>Abstractions for Concurrency### 17.10 Mailboxes</p>
<p>Mailboxes are high-level, ﬂexible constructs for process synchronization and com-munication. They allow sending and receiving of messages. A message in this con-text is an arbitrary object. There is a special message TIMEOUT which is used to signala time-out.</p>
<p>case object TIMEOUT</p>
<p>Mailboxes implement the following signature.</p>
<p>class MailBox {</p>
<p>def send(msg: Any)</p>
<p>def receive[A](f: PartialFunction[Any, A]): A</p>
<p>def receiveWithin[A](msec: Long)(f: PartialFunction[Any, A]): A</p>
<p>}</p>
<p>The state of a mailbox consists of a multi-set of messages. Messages are added to themailbox with the send method. Messages are removed using the receive method,which is passed a message processor f as argument, which is a partial function frommessages to some arbitrary result type. Typically, this function is implemented as apattern matching expression. The receive method blocks until there is a messagein the mailbox for which its message processor is deﬁned. The matching message isthen removed from the mailbox and the blocked thread is restarted by applying themessage processor to the message. Both sent messages and receivers are orderedin time. A receiver r is applied to a matching message m only if there is no other{message, receiver} pair which precedes m,r in the partial ordering on pairs thatorders each component in time.</p>
<p>As a simple example of how mailboxes are used, consider a one-place buffer:</p>
<p>class OnePlaceBuffer {</p>
<p>private val m = new MailBox</p>
<p>private case class Empty, Full(x: Int) // Types of messages we deal withm send Empty</p>
<p>def write(x: Int)</p>
<p>// An internal mailbox</p>
<p>// Initialization</p>
<p>{ m receive { case Empty =&gt; m send Full(x) } }</p>
<p>def read: Int =</p>
<p>m receive { case Full(x) =&gt; m send Empty; x }</p>
<p>}</p>
<p>Here’s how the mailbox class can be implemented:</p>
<p>class MailBox {</p>
<p>private abstract class Receiver extends Signal {</p>
<p>def isDefined(msg: Any): Boolean</p>
<p>var msg = null</p>
<ul>
<li>17.10 Mailboxes</li>
</ul>
<p>}</p>
<ul>
<li>
<p>We deﬁne an internal class for receivers with a test method isDefined, which indi-</p>
</li>
<li>
<p>cates whether the receiver is deﬁned for a given message. The receiver inherits from</p>
</li>
<li>
<p>class Signal a notify method which is used to wake up a receiver thread. When the</p>
</li>
<li>
<p>receiver thread is woken up, the message it needs to be applied to is stored in the</p>
</li>
<li>
<p>msg variable of Receiver.</p>
</li>
</ul>
<p>private val sent = new LinkedList[Any]</p>
<p>private var lastSent = sent</p>
<p>private val receivers = new LinkedList[Receiver]</p>
<p>private var lastReceiver = receivers</p>
<ul>
<li>
<p>The mailbox class maintains two linked lists, one for sent but unconsumed mes-</p>
</li>
<li>
<p>sages, the other for waiting receivers.</p>
</li>
</ul>
<p>def send(msg: Any) = synchronized {</p>
<p>var r = receivers, r1 = r.next</p>
<p>while (r1 != null &amp;&amp; !r1.elem.isDefined(msg)) {</p>
<p>r = r1; r1 = r1.next</p>
<p>}</p>
<p>if (r1 != null) {</p>
<p>r.next = r1.next; r1.elem.msg = msg; r1.elem.notify</p>
<p>} else {</p>
<p>lastSent = insert(lastSent, msg)</p>
<p>}</p>
<p>}</p>
<ul>
<li>
<p>The send method ﬁrst checks whether a waiting receiver is applicable to the sent</p>
</li>
<li>
<p>message. If yes, the receiver is notiﬁed. Otherwise, the message is appended to the</p>
</li>
<li>
<p>linked list of sent messages.</p>
</li>
</ul>
<p>def receive[A](f: PartialFunction[Any, A]): A = {</p>
<p>val msg: Any = synchronized {</p>
<p>var s = sent, s1 = s.next</p>
<p>while (s1 != null &amp;&amp; !f.isDefinedAt(s1.elem)) {</p>
<p>s = s1; s1 = s1.next</p>
<p>}</p>
<p>if (s1 != null) {</p>
<p>s.next = s1.next; s1.elem</p>
<p>} else {</p>
<p>val r = insert(lastReceiver, new Receiver {</p>
<p>def isDefined(msg: Any) = f.isDefinedAt(msg)</p>
<p>})</p>
<p>lastReceiver = r</p>
<p>r.elem.wait()</p>
<p>r.elem.msg</p>
<p>Abstractions for Concurrency}</p>
<p>}</p>
<p>f(msg)</p>
<p>}</p>
<p>The receive method ﬁrst checks whether the message processor function f can beapplied to a message that has already been sent but that was not yet consumed. Ifyes, the thread continues immediately by applying f to the message. Otherwise, anew receiver is created and linked into the receivers list, and the thread waits fora notiﬁcation on this receiver. Once the thread is woken up again, it continues byapplying f to the message that was stored in the receiver. The insert method onlinked lists is deﬁned as follows.</p>
<p>def insert(l: LinkedList[A], x: A): LinkedList[A] = {</p>
<p>l.next = new LinkedList[A]</p>
<p>l.next.elem = x</p>
<p>l.next.next = l.next</p>
<p>l</p>
<p>}</p>
<p>The mailbox class also offers a method receiveWithin which blocks for only a speci-ﬁed maximal amount of time. If no message is received within the speciﬁed time in-terval (given in milliseconds), the message processor argument f will be unblockedwith the special TIMEOUT message. The implementation of receiveWithin is quitesimilar to receive:</p>
<p>def receiveWithin[A](msec: Long)(f: PartialFunction[Any, A]): A = {</p>
<p>val msg: Any = synchronized {</p>
<p>var s = sent, s1 = s.next</p>
<p>while (s1 != null &amp;&amp; !f.isDefinedAt(s1.elem)) {</p>
<p>s = s1; s1 = s1.next</p>
<p>}</p>
<p>if (s1 != null) {</p>
<p>s.next = s1.next; s1.elem</p>
<p>} else {</p>
<p>val r = insert(lastReceiver, new Receiver {</p>
<p>def isDefined(msg: Any) = f.isDefinedAt(msg)</p>
<p>})</p>
<p>lastReceiver = r</p>
<p>r.elem.wait(msec)</p>
<p>if (r.elem.msg == null) r.elem.msg = TIMEOUT</p>
<p>r.elem.msg</p>
<p>}</p>
<p>}</p>
<p>f(msg)</p>
<p>}</p>
<ul>
<li>17.11 Actors</li>
</ul>
<p>} // end MailBox</p>
<ul>
<li>The only differences are the timed call to wait, and the statement following it.</li>
</ul>
<h3 id="1711-actors">17.11 Actors</h3>
<ul>
<li>
<p>Chapter 3 sketched as a program example the implementation of an electronic auc-</p>
</li>
<li>
<p>tion service. This service was based on high-level actor processes that work by in-</p>
</li>
<li>
<p>specting messages in their mailbox using pattern matching. A reﬁned and opti-</p>
</li>
<li>
<p>mized implementation of actors is found in the scala.actors package. We now</p>
</li>
<li>
<p>give a sketch of a simpliﬁed version of the actors library.</p>
</li>
<li>
<p>The code below is different from the implementation in the scala.actors package,</p>
</li>
<li>
<p>so it should be seen as an example how a simple version of actors could be imple-</p>
</li>
<li>
<p>mented. It is not a description how actors are actually deﬁned and implemented in</p>
</li>
<li>
<p>the standard Scala library. For the latter, please refer to the Scala API documenta-</p>
</li>
<li>
<p>tion.</p>
</li>
<li>
<p>A simpliﬁed actor is just a thread whose communication primitives are those of a</p>
</li>
<li>
<p>mailbox. Such an actor can be deﬁned as a mixin composition extension of Java’s</p>
</li>
<li>
<p>standard Thread class with the MailBox class. We also override the run method of</p>
</li>
<li>
<p>the Thread class, so that it executes the behavior of the actor that is deﬁned by its</p>
</li>
<li>
<p>act method. The ! method simply calls the send method of the MailBox class:</p>
</li>
</ul>
<p>abstract class Actor extends Thread with MailBox {</p>
<p>def act(): Unit</p>
<p>override def run(): Unit = act()</p>
<p>def !(msg: Any) = send(msg)</p>
<p>}</p>
<ul>
<li>
<p>Bibliography</p>
</li>
<li>
<p>[ASS96] Harold Abelson, Gerald Jay Sussman, and Julie Sussman. The Structure and</p>
</li>
</ul>
<p>Interpretation of Computer Programs, 2nd edition. MIT Press, Cambridge,</p>
<p>Massachusetts, 1996.</p>
<ul>
<li>[Mil78] Robin Milner. A Theory of Type Polymorphism in Programming. Journal</li>
</ul>
<p>of Computer and System Sciences, 17:348–375, Dec 1978.</p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Ye Zheng</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2019-03-01
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="http://csyezheng.github.io/tags/scala/">Scala</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/programming-languages/go/quick-start/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">quick-start</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/programming-languages/java/spring-boot/">
            <span class="next-text nav-default">spring-boot</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:csyezheng@gmail.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://stackoverflow.com/users/5694480" rel="me noopener" class="iconfont"
      title="stack-overflow"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M809.714286 932.571429l-638.857143 0 0-274.285714-91.428571 0 0 365.714286 821.714286 0 0-365.714286-91.428571 0 0 274.285714zm-538.285714-299.428571l18.857143-89.714286 447.428571 94.285714-18.857143 89.142857zm58.857143-213.714286l38.285714-83.428571 414.285714 193.714286-38.285714 82.857143zm114.857143-203.428571l58.285714-70.285714 350.857143 293.142857-58.285714 70.285714zm226.857143-216l272.571429 366.285714-73.142857 54.857143-272.571429-366.285714zm-410.285714 840.571429l0-90.857143 457.142857 0 0 90.857143-457.142857 0z"></path>
</svg>

    </a>
  
    <a href="https://www.linkedin.com/in/%E7%83%A8-%E9%83%91-a2a987100/" rel="me noopener" class="iconfont"
      title="linkedin"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="33" height="33">
  <path d="M872.405333 872.618667h-151.637333v-237.610667c0-56.661333-1.152-129.578667-79.018667-129.578667-79.061333 0-91.136 61.653333-91.136 125.397334v241.792H398.976V384h145.664v66.602667h1.962667c20.352-38.4 69.845333-78.933333 143.786666-78.933334 153.642667 0 182.058667 101.12 182.058667 232.746667v268.202667zM227.712 317.141333a87.978667 87.978667 0 0 1-88.021333-88.106666 88.064 88.064 0 1 1 88.021333 88.106666z m76.032 555.477334H151.68V384h152.064v488.618667zM948.266667 0H75.562667C33.792 0 0 33.024 0 73.770667v876.458666C0 991.018667 33.792 1024 75.562667 1024h872.576C989.866667 1024 1024 991.018667 1024 950.229333V73.770667C1024 33.024 989.866667 0 948.138667 0h0.128z"></path>
</svg>

    </a>
  
    <a href="https://github.com/csyezheng" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="http://csyezheng.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/csyezheng/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2017 -
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        Ye Zheng
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  















</body>
</html>
