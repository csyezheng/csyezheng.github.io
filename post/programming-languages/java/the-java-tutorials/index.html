<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>The Java Tutorials - Ye Zheng&#39;s Blog</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="Ye Zheng" />
  <meta name="description" content="Getting Started The Java programming language is a high-level language that can be characterized by all of the following buzzwords:
 Simple Object oriented Distributed Multithreaded Dynamic Architecture neutral Portable High performance Robust Secure  An overview of the software development process:
all source code is first written in plain text files ending with the .java extension. Those source files are then compiled into .class files by the javac compiler. A ." />

  <meta name="keywords" content="technique, programming, computer science" />






<meta name="generator" content="Hugo 0.75.1" />


<link rel="canonical" href="http://csyezheng.github.io/post/programming-languages/java/the-java-tutorials/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.0493617b29ca314c4891213673bd17850fd873c91d68aa156d61f090a97c5ca6.css" integrity="sha256-BJNheynKMUxIkSE2c70XhQ/Yc8kdaKoVbWHwkKl8XKY=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="The Java Tutorials" />
<meta property="og:description" content="Getting Started The Java programming language is a high-level language that can be characterized by all of the following buzzwords:
 Simple Object oriented Distributed Multithreaded Dynamic Architecture neutral Portable High performance Robust Secure  An overview of the software development process:
all source code is first written in plain text files ending with the .java extension. Those source files are then compiled into .class files by the javac compiler. A ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://csyezheng.github.io/post/programming-languages/java/the-java-tutorials/" />
<meta property="article:published_time" content="2019-03-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-03-01T00:00:00+00:00" />
<meta itemprop="name" content="The Java Tutorials">
<meta itemprop="description" content="Getting Started The Java programming language is a high-level language that can be characterized by all of the following buzzwords:
 Simple Object oriented Distributed Multithreaded Dynamic Architecture neutral Portable High performance Robust Secure  An overview of the software development process:
all source code is first written in plain text files ending with the .java extension. Those source files are then compiled into .class files by the javac compiler. A .">
<meta itemprop="datePublished" content="2019-03-01T00:00:00+00:00" />
<meta itemprop="dateModified" content="2019-03-01T00:00:00+00:00" />
<meta itemprop="wordCount" content="10783">



<meta itemprop="keywords" content="Java," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="The Java Tutorials"/>
<meta name="twitter:description" content="Getting Started The Java programming language is a high-level language that can be characterized by all of the following buzzwords:
 Simple Object oriented Distributed Multithreaded Dynamic Architecture neutral Portable High performance Robust Secure  An overview of the software development process:
all source code is first written in plain text files ending with the .java extension. Those source files are then compiled into .class files by the javac compiler. A ."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Ye Zheng's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/about/">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      Ye Zheng's Blog
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://csyezheng.github.io/about/">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">The Java Tutorials</h1>
      
      <div class="post-meta">
        <time datetime="2019-03-01" class="post-time">
          2019-03-01
        </time>
        <div class="post-category">
            <a href="http://csyezheng.github.io/categories/programming-languages/"> programming-languages </a>
            <a href="http://csyezheng.github.io/categories/java/"> Java </a>
            
          </div>
        

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#getting-started">Getting Started</a></li>
    <li><a href="#language-basics">Language Basics</a>
      <ul>
        <li><a href="#comments">Comments</a></li>
        <li><a href="#primitive-data-types">Primitive Data Types</a></li>
        <li><a href="#variables-and-constants">Variables and Constants</a></li>
        <li><a href="#operators">Operators</a></li>
        <li><a href="#strings">Strings</a></li>
        <li><a href="#expressions-statements-and-blocks">Expressions, Statements, and Blocks</a></li>
        <li><a href="#input-and-output">Input and Output</a></li>
        <li><a href="#control-flow-statements">Control Flow Statements</a></li>
        <li><a href="#big-numbers">Big Numbers</a></li>
        <li><a href="#arrays">Arrays</a></li>
      </ul>
    </li>
    <li><a href="#numbers-and-strings">Numbers and Strings</a>
      <ul>
        <li><a href="#numbers">Numbers</a></li>
        <li><a href="#characters">Characters</a></li>
        <li><a href="#strings-1">Strings</a></li>
      </ul>
    </li>
    <li><a href="#classes-and-objects">Classes and Objects</a>
      <ul>
        <li><a href="#object-oriented-programming-concepts">Object-Oriented Programming Concepts</a></li>
        <li><a href="#classes">Classes</a></li>
        <li><a href="#object">Object</a></li>
        <li><a href="#more-on-classes">More on Classes</a></li>
        <li><a href="#packages">Packages</a></li>
        <li><a href="#documentation-comments">Documentation Comments</a></li>
      </ul>
    </li>
    <li><a href="#inheritance">Inheritance</a>
      <ul>
        <li><a href="#casting-objects">Casting Objects</a></li>
        <li><a href="#overriding-and-hiding-methodsoverloade-methods">Overriding and Hiding Methods、Overloade Methods</a></li>
        <li><a href="#polymorphism">Polymorphism</a></li>
        <li><a href="#using-the-keyword-super">Using the Keyword super</a></li>
        <li><a href="#object-as-a-superclass">Object as a Superclass</a></li>
        <li><a href="#abstract-methods-and-classes">Abstract Methods and Classes</a></li>
        <li><a href="#enumeration-classes">Enumeration Classes</a></li>
        <li><a href="#reflection">Reflection</a></li>
      </ul>
    </li>
    <li><a href="#interfaces-lambda-expressions-and">Interfaces, Lambda Expressions, and</a>
      <ul>
        <li><a href="#interface">Interface</a></li>
        <li><a href="#lambda-expressions">Lambda Expressions</a></li>
        <li><a href="#nested-classes">Nested Classes</a></li>
        <li><a href="#service-loaders">Service Loaders</a></li>
        <li><a href="#proxies">Proxies</a></li>
      </ul>
    </li>
    <li><a href="#exceptions-assertions-and-logging">Exceptions, Assertions, and Logging</a>
      <ul>
        <li><a href="#dealing-with-errors">Dealing with Errors</a></li>
        <li><a href="#caching-exceptions">Caching Exceptions</a></li>
        <li><a href="#using-assertions">Using Assertions</a></li>
        <li><a href="#logging">Logging</a></li>
        <li><a href="#debugging-tips">Debugging Tips</a></li>
      </ul>
    </li>
    <li><a href="#annotations">Annotations</a>
      <ul>
        <li><a href="#annotations-basics">Annotations Basics</a></li>
        <li><a href="#declaring-an-annotation-type">Declaring an Annotation Type</a></li>
        <li><a href="#predefined-annotation-types">Predefined Annotation Types</a></li>
        <li><a href="#type-annotations-and-pluggable-type-systems">Type Annotations and Pluggable Type Systems</a></li>
        <li><a href="#repeating-annotations">Repeating Annotations</a></li>
      </ul>
    </li>
    <li><a href="#generics">Generics</a>
      <ul>
        <li><a href="#heading"></a></li>
      </ul>
    </li>
    <li><a href="#heading-1"></a></li>
    <li><a href="#concurrency">concurrency</a></li>
    <li><a href="#regular-expressions">regular expressions</a></li>
    <li><a href="#the-platform-environment">the platform environment.</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h2 id="getting-started">Getting Started</h2>
<p>The Java programming language is a high-level language that can be characterized by all of the following buzzwords:</p>
<ul>
<li>Simple</li>
<li>Object oriented</li>
<li>Distributed</li>
<li>Multithreaded</li>
<li>Dynamic</li>
<li>Architecture neutral</li>
<li>Portable</li>
<li>High performance</li>
<li>Robust</li>
<li>Secure</li>
</ul>
<p>An overview of the software development process:</p>
<p><img src="https://docs.oracle.com/javase/tutorial/figures/getStarted/getStarted-compiler.gif" alt="Figure showing MyProgram.java, compiler, MyProgram.class, Java VM, and My Program running on a computer."></p>
<p>all source code is first written in plain text files ending with the <code>.java</code> extension. Those source files are then compiled into <code>.class</code> files by the <code>javac</code> compiler. A <code>.class</code> file does not contain code that is native to your processor; it instead contains <em>bytecodes</em> — the machine language of the Java Virtual Machine<a href="https://docs.oracle.com/javase/tutorial/getStarted/intro/definition.html#FOOT">1</a> (Java VM). The <code>java</code> launcher tool then runs your application with an instance of the Java Virtual Machine.</p>
<p>The Java platform has two components:</p>
<ul>
<li>The <em>Java Virtual Machine</em></li>
<li>The <em>Java Application Programming Interface</em> (API)</li>
</ul>
<pre><code>/**
 * The HelloWorldApp class implements an application that
 * simply prints &quot;Hello World!&quot; to standard output.
 */
class HelloWorldApp {
    public static void main(String[] args) {
        System.out.println(&quot;Hello World!&quot;); // Display the string.
    }
}
</code></pre><pre><code>$ javac HelloWorldApp.java
</code></pre><pre><code>$ java HelloWorldApp
</code></pre><h2 id="language-basics">Language Basics</h2>
<h3 id="comments">Comments</h3>
<pre><code>/* comments */
// comments
</code></pre><h3 id="primitive-data-types">Primitive Data Types</h3>
<p>The Java programming language is statically-typed, which means that all variables must first be declared before they can be used. This involves stating the variable&rsquo;s type and name</p>
<pre><code>int gear = 1;    // holds numerical data, and has an initial value 
</code></pre><p>The eight primitive data types supported by the Java programming language are:</p>
<ul>
<li><strong>byte</strong>: The <code>byte</code> data type is an 8-bit signed two&rsquo;s complement integer. The <code>byte</code> data type can <strong>be useful for saving memory in large arrays</strong>.</li>
<li><strong>short</strong>: The <code>short</code> data type is a 16-bit signed two&rsquo;s complement integer. You can use a <code>short</code> to save memory in large arrays, in situations where the memory savings actually matters.</li>
<li><strong>int</strong>: By default, the <code>int</code> data type is a 32-bit signed two&rsquo;s complement integer In Java SE 8 and later, you can use the <code>int</code> data type to represent an unsigned 32-bit integer. Use the Integer class to use <code>int</code> data type as an unsigned integer. Static methods like <code>compareUnsigned</code>, <code>divideUnsigned</code> etc have been added to the Integer class to support the arithmetic operations for unsigned integers.</li>
<li><strong>long</strong>: The <code>long</code> data type is a 64-bit two&rsquo;s complement integer. In Java SE 8 and later, you can use the <code>long</code> data type to represent an unsigned 64-bit long. Use this data type when you need a range of values wider than those provided by <code>int</code>. The <code>Long</code>class also contains methods like <code>compareUnsigned</code>, <code>divideUnsigned</code> etc to support arithmetic operations for unsigned long.</li>
<li><strong>float</strong>: As with the recommendations for <code>byte</code> and <code>short</code>, use a <code>float</code> (instead of <code>double</code>) if you need to save memory in large arrays of floating point numbers. This data type should never be used for precise values, such as currency. For that, you will need to use the <code>java.math.BigDecimal</code> class instead.</li>
<li><strong>double</strong>: For decimal values, this data type is generally the default choice. As mentioned above, this data type should never be used for precise values, such as currency.</li>
<li><strong>boolean</strong>: The <code>boolean</code> data type has only two possible values: <code>true</code> and <code>false</code>. Use this data type for simple flags that track true/false conditions.</li>
<li><strong>char</strong>: The <code>char</code> data type is a single 16-bit Unicode character. It has a minimum value of <code>'\u0000'</code> (or 0) and a maximum value of <code>'\uffff'</code> (or 65,535 inclusive).</li>
</ul>
<p><strong>Default Values</strong></p>
<p>It&rsquo;s not always necessary to assign a value when a field is declared. Fields that are declared but not initialized will be set to a reasonable default by the compiler. Generally speaking, this default will be zero or <code>null</code>, depending on the data type. <strong>Relying on such default values, however, is generally considered bad programming style</strong>.</p>
<table>
<thead>
<tr>
<th><strong>Data Type</strong></th>
<th><strong>Default Value (for fields)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>char</td>
<td>&lsquo;\u0000&rsquo;</td>
</tr>
<tr>
<td>String (or any object)</td>
<td>null</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><strong>Local variables are slightly different; the compiler never assigns a default value to an uninitialized local variable.</strong> If you cannot initialize your local variable where it is declared, make sure to assign it a value before you attempt to use it. Accessing an uninitialized local variable will result in a compile-time error.</p>
<p><strong>Literals</strong></p>
<p>You may have noticed that the <code>new</code> keyword isn&rsquo;t used when initializing a variable of a primitive type.</p>
<p><strong>Character and String Literals</strong></p>
<p><strong>Always use &lsquo;single quotes&rsquo; for <code>char</code> literals and &ldquo;double quotes&rdquo; for <code>String</code> literals.</strong></p>
<p>The Java programming language also supports a few special escape sequences for <code>char</code> and <code>String</code>literals: <code>\b</code> (backspace), <code>\t</code> (tab), <code>\n</code> (line feed), <code>\f</code> (form feed), <code>\r</code> (carriage return), <code>\&quot;</code> (double quote), <code>\'</code>(single quote), and <code>\\</code> (backslash).</p>
<p>There&rsquo;s also a special <code>null</code> literal that can be used as a value for any reference type. <strong><code>null</code> may be assigned to any variable, except variables of primitive types.</strong> There&rsquo;s little you can do with a <code>null</code> value beyond testing for its presence. Therefore, <strong><code>null</code> is often used in programs as a marker to indicate that some object is unavailable</strong>.</p>
<p>Finally, there&rsquo;s also a special kind of literal called a <em><strong>class literal</strong></em>, formed by taking a type name and appending &ldquo;<code>.class&quot;</code>; for example, <code>String.class</code>. This refers to the object (of type <code>Class</code>) that represents the type itself.</p>
<h3 id="variables-and-constants">Variables and Constants</h3>
<p>The Java programming language defines the following kinds of variables:</p>
<ul>
<li><strong>Instance Variables (Non-Static Fields)</strong> Technically speaking, objects store their individual states in &ldquo;non-static fields&rdquo;, that is, fields declared without the <strong><code>static</code></strong> keyword. Non-static fields are also known as <em>instance variables</em> because their values are unique to each <em>instance</em> of a class (to each object, in other words); the <code>currentSpeed</code> of one bicycle is independent from the <code>currentSpeed</code> of another.</li>
<li><strong>Class Variables (Static Fields)</strong> A <em>class variable</em> is any field declared with the <code>static</code>modifier; this tells the compiler that <strong>there is exactly one copy of this variable in existence, regardless of how many times the class has been instantiated</strong>. A field defining the number of gears for a particular kind of bicycle could be marked as <strong><code>static</code></strong> since conceptually the same number of gears will apply to all instances. The code <code>static int numGears = 6;</code> would create such a static field. Additionally, the keyword <strong><code>final</code></strong> could be added to indicate that the number of gears will never change.</li>
<li><strong>Local Variables</strong> a method will often store its temporary state in <em>local variables</em>. There is no special keyword designating a variable as local; that determination comes entirely from the location in which the variable is declared — which is between the opening and closing braces of a method. As such, local variables are only visible to the methods in which they are declared; they are not accessible from the rest of the class.</li>
<li><strong>Parameters</strong> Recall that the signature for the <code>main</code>method is <code>public static void main(String[] args)</code>. Here, the <code>args</code> variable is the parameter to this method.</li>
</ul>
<p><strong>Naming</strong></p>
<p>Every programming language has its own set of rules and conventions for the kinds of names that you&rsquo;re allowed to use:</p>
<ul>
<li>Variable names are <strong>case-sensitive</strong>. The convention, is to always begin your variable names with a letter, not &ldquo;<code>$</code>&rdquo; or &ldquo;<code>_</code>&rdquo;. `</li>
<li>When choosing a name for your variables, <strong>use full words instead of cryptic abbreviations</strong>. Also keep in mind that the name you choose must not be a keyword or reserved word.</li>
<li>If the name you choose consists of only one word, spell that word in all lowercase letters. If it consists of more than one word, <strong>capitalize the first letter of each subsequent word</strong>. The names <code>gearRatio</code> and <code>currentGear</code> are prime examples of this convention. If your variable stores a <strong>constant value</strong>, such as <code>static final int NUM_GEARS = 6</code>, the convention changes slightly, capitalizing every letter and separating subsequent words with the underscore character. By convention, <strong>the underscore character is never used elsewhere</strong>.</li>
</ul>
<h4 id="constants">Constants</h4>
<p>The keyword <strong><code>final</code></strong> indicates that you can assign to the variable once, and then its value is set once and for all. It is customary to name constants in all uppercase.</p>
<pre><code>public static void main(String[] args)
{
	final double CM_PER_INCH = 2.54;
}
</code></pre><p>Set up a class constant with the keywords <strong><code>static final</code></strong>.</p>
<pre><code>public class Constants2
{
    public static final double CM_PER_INCH = 2.54;
    public static void main(String[] args)
    {
        double paperWidth = 8.5;
        double paperHeight = 11;
        System.out.println(&quot;Paper size in centimeters: &quot; + paperWidth * CM_PER_INCH + &quot; by &quot; + paperHeight * CM_PER_INCH);
    }
}
</code></pre><h4 id="enumerated-types">Enumerated Types</h4>
<pre><code>enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE };
</code></pre><pre><code>Size s = Size.MEDIUM;
</code></pre><h3 id="operators">Operators</h3>
<table>
<thead>
<tr>
<th>Operators</th>
<th>Precedence</th>
</tr>
</thead>
<tbody>
<tr>
<td>postfix</td>
<td><code>expr++ expr--</code></td>
</tr>
<tr>
<td>unary</td>
<td><code>++expr --expr +expr -expr ~ !</code></td>
</tr>
<tr>
<td>multiplicative</td>
<td><code>* / %</code></td>
</tr>
<tr>
<td>additive</td>
<td><code>+ -</code></td>
</tr>
<tr>
<td>shift</td>
<td><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td>
</tr>
<tr>
<td>relational</td>
<td><code>&lt; &gt; &lt;= &gt;= instanceof</code></td>
</tr>
<tr>
<td>equality</td>
<td><code>== !=</code></td>
</tr>
<tr>
<td>bitwise AND</td>
<td><code>&amp;</code></td>
</tr>
<tr>
<td>bitwise exclusive OR</td>
<td><code>^</code></td>
</tr>
<tr>
<td>bitwise inclusive OR</td>
<td><code>|</code></td>
</tr>
<tr>
<td>logical AND</td>
<td><code>&amp;&amp;</code></td>
</tr>
<tr>
<td>logical OR</td>
<td><code>||</code></td>
</tr>
<tr>
<td>ternary</td>
<td><code>? :</code></td>
</tr>
<tr>
<td>assignment</td>
<td><code>= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</code></td>
</tr>
</tbody>
</table>
<h3 id="strings">Strings</h3>
<p>In addition to the eight primitive data types listed above, the Java programming language also provides special support for character strings via the <code>java.lang.String</code> class. Enclosing your character string within double quotes will automatically create a new String object.</p>
<pre><code>String s = &quot;this is a string&quot;;
</code></pre><p><code>String</code> objects are <em><strong>immutable</strong></em>, which means that once created, their values cannot be changed. The <code>String</code> class is not technically a primitive data type, but considering the special support given to it by the language, you&rsquo;ll probably tend to think of it as such.</p>
<h3 id="expressions-statements-and-blocks">Expressions, Statements, and Blocks</h3>
<pre><code>double aValue = 8933.234;  // declaration statement
aValue = 8933.234;   // assignment statement
aValue++;   // increment statement
System.out.println(&quot;Hello World!&quot;);   // method invocation statement
Bicycle myBike = new Bicycle();   // object creation statement
</code></pre><pre><code>class BlockDemo {
     public static void main(String[] args) {
          boolean condition = true;
          if (condition) { // begin block 1
               System.out.println(&quot;Condition is true.&quot;);
          } // end block one
          else { // begin block 2
               System.out.println(&quot;Condition is false.&quot;);
          } // end block 2
     }
}
</code></pre><h3 id="input-and-output">Input and Output</h3>
<h4 id="reading-input">Reading Input</h4>
<pre><code>import java.util.*;
Scanner in = new Scanner(System.in);
</code></pre><pre><code>System.out.print(&quot;What is your name? &quot;);

jshell&gt; String name = in.nextLine();
Ye
name ==&gt; &quot;Ye&quot;
</code></pre><pre><code>String firstName = in.next();
</code></pre><pre><code>System.out.print(&quot;How old are you? &quot;);
int age = in.nextInt();
</code></pre><pre><code>boolean hasNext()
</code></pre><p>The Scanner class is not suitable for reading a password from a console since the input is plainly visible to anyone.</p>
<pre><code>Console cons = System.console();
String username = cons.readLine(&quot;User name: &quot;);
char[] passwd = cons.readPassword(&quot;Password: &quot;);
</code></pre><h4 id="formatting-output">Formatting Output</h4>
<pre><code>System.out.printf(&quot;Hello, %s. Next year, you'll be %d&quot;, name, age);
</code></pre><table>
<thead>
<tr>
<th>Character</th>
<th>Conversion Type</th>
<th>Character</th>
<th>Conversion Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>decimal</td>
<td>s</td>
<td>String</td>
</tr>
<tr>
<td>x</td>
<td>Hexadecimal integer</td>
<td>c</td>
<td>Character</td>
</tr>
<tr>
<td>o</td>
<td>Octal integer</td>
<td>b</td>
<td>boolean</td>
</tr>
<tr>
<td>f</td>
<td>float</td>
<td>h</td>
<td></td>
</tr>
<tr>
<td>e</td>
<td></td>
<td>tx</td>
<td>Date and time</td>
</tr>
<tr>
<td>g</td>
<td></td>
<td>%</td>
<td></td>
</tr>
<tr>
<td>a</td>
<td></td>
<td>n</td>
<td></td>
</tr>
</tbody>
</table>
<p>Date and Time Conversion Characters</p>
<table>
<thead>
<tr>
<th>Character</th>
<th>Conversion Type</th>
<th>Character</th>
<th>Conversion Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>Complete date and time</td>
<td>D</td>
<td>02/09/2015</td>
</tr>
<tr>
<td>F</td>
<td>2015-02-09</td>
<td>T</td>
<td>18:05:19</td>
</tr>
<tr>
<td>r</td>
<td>06:05:19 pm</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code>System.out.printf(&quot;%tc&quot;, new Date());  
// Mon Feb 09 18:05:19 PST 2015
</code></pre><pre><code>System.out.printf(&quot;%1$s %2$tB %2$te, %2$tY&quot;, &quot;Due date:&quot;, new Date());
// Due date: February 9, 2015
</code></pre><h4 id="file-input-and-output">File Input and Output</h4>
<p>To read from a file</p>
<pre><code>Scanner in = new Scanner(Path.of(&quot;c:\\mydirectory\\myfile.txt&quot;), StandardCharsets.UTF_8);
</code></pre><p>To write to a file</p>
<pre><code>PrintWriter out = new PrintWriter(&quot;myfile.txt&quot;, StandardCharsets.UTF_8);
</code></pre><p>When you specify a relative file name, the file is located relative to the directory in which the Java virtual machine was started.</p>
<p>If you construct a Scanner with a file that does not exist or a PrintWriter with a file name that cannot be created, an exception occurs.</p>
<pre><code>public static void main(String[] args) throws IOException
{
    Scanner in = new Scanner(Path.of(&quot;myfile.txt&quot;), StandardCharsets.UTF_8);
    . . .
}
</code></pre><h3 id="control-flow-statements">Control Flow Statements</h3>
<h4 id="the-if-else-statements">The if-else Statements</h4>
<pre><code>class IfElseDemo {
    public static void main(String[] args) {

        int testscore = 76;
        char grade;

        if (testscore &gt;= 90) {
            grade = 'A';
        } else if (testscore &gt;= 80) {
            grade = 'B';
        } else {
            grade = 'F';
        }
        System.out.println(&quot;Grade = &quot; + grade);
    }
}
</code></pre><h4 id="the-switch-statement">The switch Statement</h4>
<p>The <code>break</code> statements are necessary because without them, statements in <code>switch</code> blocks <em>fall through</em>: <strong>All statements after the matching <code>case</code> label are executed in sequence, regardless of the expression of subsequent <code>case</code> labels, until a <code>break</code> statement is encountered.</strong></p>
<pre><code>public class SwitchDemoFallThrough {

    public static void main(String[] args) {
        java.util.ArrayList&lt;String&gt; futureMonths =
            new java.util.ArrayList&lt;String&gt;();

        int month = 8;

        switch (month) {
            case 1:  futureMonths.add(&quot;January&quot;);
            case 2:  futureMonths.add(&quot;February&quot;);
            case 3:  futureMonths.add(&quot;March&quot;);
            case 4:  futureMonths.add(&quot;April&quot;);
            case 5:  futureMonths.add(&quot;May&quot;);
            case 6:  futureMonths.add(&quot;June&quot;);
            case 7:  futureMonths.add(&quot;July&quot;);
            case 8:  futureMonths.add(&quot;August&quot;);
            case 9:  futureMonths.add(&quot;September&quot;);
            case 10: futureMonths.add(&quot;October&quot;);
            case 11: futureMonths.add(&quot;November&quot;);
            case 12: futureMonths.add(&quot;December&quot;);
                     break;
            default: break;
        }

        if (futureMonths.isEmpty()) {
            System.out.println(&quot;Invalid month number&quot;);
        } else {
            for (String monthName : futureMonths) {
               System.out.println(monthName);
            }
        }
    }
}
/*
August
September
October
November
December
*/
</code></pre><pre><code>public class StringSwitchDemo {

    public static int getMonthNumber(String month) {

        int monthNumber = 0;

        if (month == null) {
            return monthNumber;
        }

        switch (month.toLowerCase()) {
            case &quot;january&quot;:
                monthNumber = 1;
                break;
            case &quot;february&quot;:
                monthNumber = 2;
                break;
            // ...
            default: 
                monthNumber = 0;
                break;
        }

        return monthNumber;
    }

    public static void main(String[] args) {

        String month = &quot;August&quot;;

        int returnedMonthNumber =
            StringSwitchDemo.getMonthNumber(month);

        if (returnedMonthNumber == 0) {
            System.out.println(&quot;Invalid month&quot;);
        } else {
            System.out.println(returnedMonthNumber);
        }
    }
}
</code></pre><p>This example <strong>checks if the expression in the <code>switch</code> statement is <code>null</code>.</strong> Ensure that the expression in any <code>switch</code> statement is not null to prevent a <code>NullPointerException</code> from being thrown.</p>
<p>This example <strong>Call class method</strong> <code>getMonthNumber</code></p>
<h4 id="the-while-and-do-while-statements"><strong>The while and do-while Statements</strong></h4>
<pre><code>while (expression) {
     statement(s)
}
</code></pre><h4 id="the-for-statement"><strong>The for Statement</strong></h4>
<pre><code>for (initialization; termination; increment) {
    statement(s)
}
</code></pre><p>The three expressions of the <code>for</code> loop are optional; an infinite loop can be created as follows:</p>
<pre><code>// infinite loop
for ( ; ; ) {
    // your code goes here
}
</code></pre><p>The for statement also has another form designed for iteration through <code>Collections</code> and <code>arrays</code>.</p>
<pre><code>class EnhancedForDemo {
    public static void main(String[] args){
         int[] numbers = 
             {1,2,3,4,5,6,7,8,9,10};
         for (int item : numbers) {
             System.out.println(&quot;Count is: &quot; + item);
         }
    }
}
</code></pre><h4 id="branching-statements"><strong>Branching Statements</strong></h4>
<pre><code>break;
</code></pre><pre><code>continue;
</code></pre><pre><code>return;
</code></pre><p>The <code>return</code> statement has two forms: one that returns a value, and one that doesn&rsquo;t.  The data type of the returned value must match the type of the method&rsquo;s declared return value. When a method is declared <code>void</code>, use the form of <code>return</code> that doesn&rsquo;t return a value.</p>
<h3 id="big-numbers">Big Numbers</h3>
<p>Use the static <code>valueOf</code> method to turn an ordinary number into a big
number:</p>
<pre><code>BigInteger a = BigInteger.valueOf(100);
</code></pre><pre><code>BigInteger reallyBig = new BigInteger(&quot;2222322446294204455297398934619099672066669390&quot;);
</code></pre><pre><code>BigInteger c = a.add(b); // c = a + b
BigInteger d = c.multiply(b.add(BigInteger.valueOf(2))); // d = c *
</code></pre><pre><code>BigInteger add(BigInteger other)
BigInteger subtract(BigInteger other)
BigInteger multiply(BigInteger other)
BigInteger divide(BigInteger other)
BigInteger mod(BigInteger other)
</code></pre><h3 id="arrays">Arrays</h3>
<p>An <em>array</em> is a container object that holds a fixed number of values of a <strong>single type</strong>. The length of an array is established when the array is created. After creation, <strong>its length is fixed</strong>.</p>
<h4 id="declaring-arrays">Declaring Arrays</h4>
<pre><code>// declares an array of integers
int[] anArray;
</code></pre><pre><code>// allocates memory for 100 integers
int[] a = new int[100]; // or var a = new int[100];
</code></pre><p>Like declarations for variables of other types, an array declaration has two components: the array&rsquo;s type and the array&rsquo;s name. An array&rsquo;s type is written as <strong><code>type[]</code></strong>, where <code>type</code> is the data type of the contained elements; the brackets are special symbols indicating that this variable holds an array. <strong>The size of the array is not part of its type (which is why the brackets are empty)</strong>. As with variables of other types, <strong>the declaration does not actually create an array</strong>; it simply tells the compiler that this variable will hold an array of the specified type.</p>
<p>Alternatively, you can use the shortcut syntax to create and initialize an array:</p>
<pre><code>//  creating an array object and supplying initial values
int[] smallPrimes = { 2, 3, 5, 7, 11, 13 };
// reinitialize an array without creating a new variable. 
smallPrimes = new int[] { 17, 19, 23, 29, 31, 37 };
</code></pre><h4 id="accessing-array-elements">Accessing Array Elements</h4>
<p>To find the number of elements of an array, use <strong><code>array.length</code></strong>.</p>
<pre><code>String[] names = new String[10];
for (int i = 0; i &lt; 10; i++) names[i] = &quot;&quot;;
</code></pre><pre><code>for (int i = 0; i &lt; names.length; i++)
	System.out.println(names[i]);
</code></pre><h4 id="the-for-each-loop">The “for each” Loop</h4>
<pre><code>for (variable : collection) statement
</code></pre><p>The collection expression must be an array or an object of a class that implements the Iterable interface, such as ArrayList.</p>
<pre><code>for (int element : a)
	System.out.println(element);
</code></pre><pre><code>for (int i = 0; i &lt; a.length; i++)
	System.out.println(a[i]);
</code></pre><pre><code>System.out.println(Arrays.toString(a));
</code></pre><h4 id="array-copying">Array Copying</h4>
<pre><code>int[] smallPrimes = { 2, 3, 5, 7, 11, 13 };
int[] luckyNumbers = smallPrimes;
luckyNumbers[5] = 12; // now smallPrimes[5] is also 12
</code></pre><pre><code>int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length);
</code></pre><p>A common use of this method is to increase the size of an array.</p>
<pre><code>luckyNumbers = Arrays.copyOf(luckyNumbers, 2 * luckyNumbers.length);
</code></pre><p>The additional elements are filled with 0 if the array contains numbers, false if the array contains boolean values.</p>
<p>The <code>System</code> class has an <strong><code>arraycopy</code></strong> method that you can use to efficiently copy data from one array into another:</p>
<pre><code>public static void arraycopy(Object src, int srcPos,
                             Object dest, int destPos, int length)
</code></pre><pre><code>char[] copyFrom = { 'd', 'e', 'c', 'a', 'f', 'f', 'e', 'i', 'n', 'a', 't', 'e', 'd' };
char[] copyTo = new char[7];
System.arraycopy(copyFrom, 2, copyTo, 0, 7);
System.out.println(new String(copyTo));   // caffein
</code></pre><pre><code>char[] copyFrom = {'d', 'e', 'c', 'a', 'f', 'f', 'e', 'i', 'n', 'a', 't', 'e', 'd'};
char[] copyTo = java.util.Arrays.copyOfRange(copyFrom, 2, 9);
System.out.println(new String(copyTo));
</code></pre><p>Some other useful operations provided by methods in the <strong><code>java.util.Arrays</code></strong> class, are:</p>
<ul>
<li>Searching an array for a specific value to get the index at which it is placed (the <strong><code>binarySearch</code></strong> method).</li>
<li>Comparing two arrays to determine if they are equal or not (the <strong><code>equals</code></strong> method).</li>
<li>Filling an array to place a specific value at each index (the <strong><code>fill</code></strong> method).</li>
</ul>
<h4 id="command-line-parameters">Command-Line Parameters</h4>
<pre><code>public class Message
{
    public static void main(String[] args)
    {
        if (args.length == 0 || args[0].equals(&quot;-h&quot;))
            System.out.print(&quot;Hello,&quot;);
        else if (args[0].equals(&quot;-g&quot;))
            System.out.print(&quot;Goodbye,&quot;);
        // print the other command-line arguments
        for (int i = 1; i &lt; args.length; i++)
            System.out.print(&quot; &quot; + args[i]);
        System.out.println(&quot;!&quot;);
    }
}
</code></pre><pre><code>java Message -g cruel world
</code></pre><pre><code>args[0]: &quot;-g&quot;
args[1]: &quot;cruel&quot;
args[2]: &quot;world&quot;
</code></pre><h4 id="array-sorting">Array Sorting</h4>
<p>Sorting an array into ascending order. This can be done either sequentially, using the <strong><code>sort</code></strong> method, or concurrently, using the <strong><code>parallelSort</code></strong> method introduced in Java SE 8. Parallel sorting of large arrays on multiprocessor systems is faster than sequential array sorting.</p>
<pre><code>int[] a = new int[10000];
. . .
Arrays.sort(a)      //  QuickSort algorithm
</code></pre><pre><code>static String toString(xxx[] a) 
static xxx[] copyOf(xxx[] a, int end) 
static xxx[] copyOfRange(xxx[] a, int start, int end) 
static void sort(xxx[] a)
static int binarySearch(xxx[] a, xxx v)
static int binarySearch(xxx[] a, int start, int end, xxx v)
static void fill(xxx[] a, xxx v)
static boolean equals(xxx[] a, xxx[] b)
</code></pre><h4 id="multidimensional-arrays">Multidimensional Arrays</h4>
<p>declare an array of arrays (also known as a <em><strong>multidimensional</strong></em> array) by using two or more sets of brackets, such as <code>String[][] names</code>.  A consequence of this is that <strong>the rows are allowed to vary in length</strong></p>
<pre><code>class MultiDimArrayDemo {
    public static void main(String[] args) {
        String[][] names = {
            {&quot;Mr. &quot;, &quot;Mrs. &quot;, &quot;Ms. &quot;},
            {&quot;Smith&quot;, &quot;Jones&quot;}
        };
        // Mr. Smith
        System.out.println(names[0][0] + names[1][0]);
        // Ms. Jones
        System.out.println(names[0][2] + names[1][1]);
    }
}
</code></pre><h4 id="ragged-arrays">Ragged Arrays</h4>
<p>It is also easy to make “ragged” arrays—that is, arrays in <strong>which different</strong>
<strong>rows have different lengths</strong>.</p>
<pre><code>int[][] odds = new int[NMAX + 1][];
for (int n = 0; n &lt;= NMAX; n++)
	odds[n] = new int[n + 1];
</code></pre><pre><code>for (int n = 0; n &lt; odds.length; n++)
    for (int k = 0; k &lt; odds[n].length; k++)
    {
        // compute lotteryOdds
        . . .
        odds[n][k] = lotteryOdds;
    }
</code></pre><h2 id="numbers-and-strings">Numbers and Strings</h2>
<h3 id="numbers">Numbers</h3>
<p>When working with numbers, most of the time you use the primitive types in your code.  There are, however, reasons to use objects in place of primitives, and <strong>the Java platform provides <em>wrapper</em> classes for each of the primitive data types</strong>. <strong>These classes &ldquo;wrap&rdquo; the primitive in an object.</strong> <strong>The Java compiler automatically wraps (boxes) primitives for you when necessary and unboxes them, again when necessary.</strong></p>
<pre><code>int ==&gt; Integer
float ==&gt; Float
double ==&gt; Double
byte ==&gt;  Byte
</code></pre><p>The following table lists the instance methods that all the subclasses of the <code>Number</code> class implement.</p>
<pre><code>// Converts the value of this Number object to the primitive data type returned.
byte byteValue()
short shortValue()
int intValue()
long longValue()
float floatValue()
double doubleValue()
</code></pre><pre><code>// Compares this Number object to the argument.
int compareTo(Byte anotherByte)
int compareTo(Double anotherDouble)
int compareTo(Float anotherFloat)
int compareTo(Integer anotherInteger)
int compareTo(Long anotherLong)
int compareTo(Short anotherShort)
</code></pre><pre><code>// Determines whether this number object is equal to the argument. 
boolean equals(Object obj)
</code></pre><p>methods for  converting numbers to and from strings and for converting between number systems.</p>
<pre><code>// Decodes a string into an integer. 
static Integer decode(String s)

// Returns an integer (decimal only).
static int parseInt(String s)

// radix equals 10, 2, 8, or 16 respectively
static int parseInt(String s, int radix)

// Returns a String object representing the value of this Integer.
String toString()

// Returns a String object representing the specified integer.
static String toString(int i)

// Returns an Integer object holding the value of the specified primitive.
static Integer valueOf(int i)

// Returns an Integer object holding the value of the specified string representation.
static Integer valueOf(String s)

// Returns an Integer object holding the integer value of the specified string representation, parsed with the value of radix.
static Integer valueOf(String s, int radix)
</code></pre><h4 id="formatting-numeric-print-output">Formatting Numeric Print Output</h4>
<p>You can use <code>format</code> or <code>printf</code> anywhere in your code where you have previously been using <code>print</code> or <code>println</code>.</p>
<pre><code>int i = 461012;
System.out.format(&quot;The value of i is: %d%n&quot;, i);
System.out.printf(&quot;The value of i is: %d%n&quot;, i);
System.out.println(&quot;&quot;);
</code></pre><table>
<thead>
<tr>
<th>Converter</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>A decimal integer.</td>
</tr>
<tr>
<td>f</td>
<td>A float.</td>
</tr>
<tr>
<td>n</td>
<td>A new line character appropriate to the platform running the application. You should always use <code>%n</code>, rather than <code>\n</code>.</td>
</tr>
</tbody>
</table>
<h4 id="beyond-basic-arithmetic">Beyond Basic Arithmetic</h4>
<pre><code>import static java.lang.Math.*;

double a = -191.635;
double b = 43.74;
int c = 16, d = 45;

double abs_a = Math.abs(a)
double ceil_b = Math.ceil(b)
</code></pre><pre><code>int number = (int)(Math.random() * 10);    // 0.0 &lt;= Math.random() &lt; 1.0
</code></pre><h3 id="characters">Characters</h3>
<pre><code>char ch = 'a'; 
// Unicode for uppercase Greek omega character
char uniChar = '\u03A9';
// an array of chars
char[] charArray = { 'a', 'b', 'c', 'd', 'e' };
</code></pre><p>useful methods in the <code>Character</code> class</p>
<pre><code>boolean isLetter(char ch)
boolean isDigit(char ch)
boolean isWhitespace(char ch)	
boolean isUpperCase(char ch)
boolean isLowerCase(char ch)	
char toUpperCase(char ch)
char toLowerCase(char ch)	
toString(char ch)	
</code></pre><p>Escape Sequences</p>
<pre><code>\t	Insert a tab 
\b	Insert a backspace 
\n	Insert a newline 
\r	Insert a carriage return 
\f	Insert a formfeed 
\'	Insert a single quote character
\&quot;	Insert a double quote character 
\\	Insert a backslash character 
</code></pre><h3 id="strings-1">Strings</h3>
<p>In the Java programming language, strings are objects. <strong>The <code>String</code> class is immutable</strong>.</p>
<pre><code>String greeting = &quot;Hello world!&quot;;
char[] helloArray = { 'h', 'e', 'l', 'l', 'o', '.' };
String helloString = new String(helloArray);
</code></pre><p>useful methods</p>
<pre><code>length()          // returns the number of characters contained in the string object
charAt(i)         // returns the ith character in the string, counting from 0
getChars(pos, len, destChatArray, startPos) // convert a string into an array of characters
concat(string2)    // concatenating two strings
String.format()        // returns a String object rather than a PrintStream object.
</code></pre><p>The <code>+</code> operator is widely used in <code>print</code> statements.</p>
<pre><code>String fs;
fs = String.format(&quot;The value of the float &quot; +
                   &quot;variable is %f, while &quot; +
                   &quot;the value of the &quot; + 
                   &quot;integer variable is %d, &quot; +
                   &quot; and the string is %s&quot;,
                   floatVar, intVar, stringVar);
System.out.println(fs);
</code></pre><h4 id="converting-between-numbers-and-strings">Converting Between Numbers and Strings</h4>
<p>The Number subclasses that wrap primitive numeric types ( Byte, Integer, Double, Float, Long, and Short) each provide a class method named <strong><code>valueOf</code></strong> that converts a string to an object of that type.</p>
<pre><code>public class ValueOfDemo {
    public static void main(String[] args) {
        // this program requires two arguments on the command line 
        if (args.length == 2) {
            // convert strings to numbers
            float a = (Float.valueOf(args[0])).floatValue(); 
            float b = (Float.valueOf(args[1])).floatValue();
        } else {
            System.out.println(&quot;This program &quot; +
                &quot;requires two command-line arguments.&quot;);
        }
    }
}
</code></pre><p>Each of the <code>Number</code> subclasses that wrap primitive numeric types also provides a <code>parseXXXX()</code> method (for example, <code>parseFloat()</code>) that can be used to convert strings to primitive numbers. Since a primitive type is returned instead of an object, the <code>parseFloat()</code> method is more direct than the <code>valueOf()</code> method.</p>
<pre><code>float a = Float.parseFloat(args[0]);
float b = Float.parseFloat(args[1]);
</code></pre><h4 id="converting-numbers-to-strings">Converting Numbers to Strings</h4>
<pre><code>int i;
// Concatenate &quot;i&quot; with an empty string; conversion is handled for you.
String s1 = &quot;&quot; + i;
</code></pre><pre><code>// The valueOf class method.
String s2 = String.valueOf(i);
</code></pre><pre><code>int i;
double d;
String s3 = Integer.toString(i); 
String s4 = Double.toString(d); 
</code></pre><h4 id="manipulating-characters-in-a-string">Manipulating Characters in a String</h4>
<pre><code>public class Filename {
    private String fullPath;
    private char pathSeparator, 
                 extensionSeparator;

    public Filename(String str, char sep, char ext) {
        fullPath = str;
        pathSeparator = sep;
        extensionSeparator = ext;
    }
    
    public String extension() {
        int dot = fullPath.lastIndexOf(extensionSeparator);
        return fullPath.substring(dot + 1);                     // substring
    }

    // gets filename without extension
    public String filename() {
        int dot = fullPath.lastIndexOf(extensionSeparator);     // indexOf, lastIndexOf
        int sep = fullPath.lastIndexOf(pathSeparator);
        return fullPath.substring(sep + 1, dot);                // substring
    }

    public String path() {
        int sep = fullPath.lastIndexOf(pathSeparator);
        return fullPath.substring(0, sep);                      // substring
    }

    public char charAt(int i) {
        String filename = this.filename();
        return filename.charAt(i);                              // chartAt
    }

    public String toUpperCase() {
        String filename = this.filename();
        filename = filename.trim();                             // trim
        return filename.toUpperCase();                          // toUpperCase, toLowerCase
    }

    public String directoryName() {
        String path = this.path();
        String[] tokens = path.split(&quot;/&quot;);                      // split
        return tokens[tokens.length - 1];
    }

    public String contains(String s) {
        Boolean ret = fullPath.contains(s);                     // contains
        return String.valueOf(ret);
    }

    public String replace(String target, String replacement) {
        return fullPath.replace(target, replacement);           // replace
    }
}
</code></pre><pre><code>public class FilenameDemo {
    public static void main(String[] args) {
        final String FPATH = &quot;/home/user/index.html&quot;;
        Filename myHomePage = new Filename(FPATH, '/', '.');
        System.out.println(&quot;Extension = &quot; + myHomePage.extension());
        System.out.println(&quot;Filename = &quot; + myHomePage.filename());
        System.out.println(&quot;Path = &quot; + myHomePage.path());
        System.out.println(&quot;Filename first letter = &quot; + myHomePage.charAt(0));
        System.out.println(&quot;Filename uppercase = &quot; + myHomePage.toUpperCase());
        System.out.println(&quot;Directory name = &quot; + myHomePage.directoryName());
        System.out.println(&quot;Full path contains user = &quot; + myHomePage.contains(&quot;user&quot;));
        System.out.println(&quot;Test change extension = &quot; + myHomePage.replace(&quot;html&quot;, &quot;text&quot;));
    }
}
</code></pre><h4 id="comparing-strings-and-portions-of-strings">Comparing Strings and Portions of Strings</h4>
<pre><code>boolean endsWith(String suffix)
boolean startsWith(String prefix)
boolean startsWith(String prefix, int offset)        
int compareTo(String anotherString)                   
int compareToIgnoreCase(String str)                    
boolean equals(Object anObject)                  
boolean equalsIgnoreCase(String anotherString)     
boolean regionMatches(int toffset, String other, int ooffset, int len)
boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)
boolean matches(String regex)        
</code></pre><pre><code>public class RegionMatchesDemo {
    public static void main(String[] args) {
        String searchMe = &quot;Green Eggs and Ham&quot;;
        String findMe = &quot;Eggs&quot;;
        int searchMeLength = searchMe.length();
        int findMeLength = findMe.length();
        boolean foundIt = false;
        for (int i = 0; 
             i &lt;= (searchMeLength - findMeLength);
             i++) {
           if (searchMe.regionMatches(i, findMe, 0, findMeLength)) {
              foundIt = true;
              System.out.println(searchMe.substring(i, i + findMeLength));
              break;
           }
        }
        if (!foundIt)
            System.out.println(&quot;No match found.&quot;);
    }
}
</code></pre><h4 id="the-stringbuilder-class">The StringBuilder Class</h4>
<pre><code>StringBuilder append(String s)
StringBuilder insert(int offset, String s)
StringBuilder replace(int start, int end, String s)
void setCharAt(int index, char c)
StringBuilder reverse()
String toString()
</code></pre><pre><code>// creates empty builder, capacity 16
StringBuilder sb = new StringBuilder();
// adds 9 character string at beginning
sb.append(&quot;Greetings&quot;);
</code></pre><pre><code>public class StringBuilderDemo {
    public static void main(String[] args) {
        String palindrome = &quot;Dot saw I was Tod&quot;;
        StringBuilder sb = new StringBuilder(palindrome);
        sb.reverse();                                       // reverse it
        System.out.println(sb);
    }
}
</code></pre><h4 id="autoboxing-and-unboxing">Autoboxing and Unboxing</h4>
<p>Converting a primitive value (an <code>int</code>, for example) into an object of the corresponding wrapper class (<code>Integer</code>) is called <strong>autoboxing</strong>. The Java compiler applies autoboxing when a primitive value is:</p>
<ul>
<li>Passed as a parameter to a method that expects an object of the corresponding wrapper class.</li>
<li>Assigned to a variable of the corresponding wrapper class.</li>
</ul>
<p>Converting an object of a wrapper type (<code>Integer</code>) to its corresponding primitive (<code>int</code>) value is called <strong>unboxing</strong>. The Java compiler applies unboxing when an object of a wrapper class is:</p>
<ul>
<li>Passed as a parameter to a method that expects a value of the corresponding primitive type.</li>
<li>Assigned to a variable of the corresponding primitive type.</li>
</ul>
<h2 id="classes-and-objects">Classes and Objects</h2>
<h3 id="object-oriented-programming-concepts">Object-Oriented Programming Concepts</h3>
<p>teaches you the core concepts behind object-oriented programming: objects, messages, classes, and inheritance. This lesson ends by showing you how these concepts translate into code. Feel free to skip this lesson if you are already familiar with object-oriented programming.</p>
<p>Real-world objects share two characteristics: They all have <em>state</em> and <em>behavior</em>.  A software object have fields (state) and methods (behavior). Hiding internal state and requiring all interaction to be performed through an object&rsquo;s methods is known as <em><strong>data encapsulation</strong></em> — a fundamental principle of object-oriented programming.</p>
<h3 id="classes">Classes</h3>
<h4 id="declaring-classes">Declaring Classes</h4>
<p><strong>modifiers</strong>, <strong>constructor</strong>, <strong>fields</strong>, <strong>methods</strong></p>
<pre><code>modifiers class MyClass extends MySuperClass implements YourInterface {
    // field, constructor, and
    // method declarations
}
</code></pre><p>naming rules: the first letter of a class name should be capitalized, and the first (or only) word in a method name should be a verb.</p>
<pre><code>public class Bicycle {
        
    // the Bicycle class has three fields
    private int cadence;
    private int gear;
    private int speed;
        
    // the Bicycle class has one constructor
    public Bicycle(int startCadence, int startSpeed, int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
    }
    
    // the Bicycle class has six methods
    public int getCadence() {
        return cadence;
    }
        
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public int getGear() {
        return gear;
    }
    
    public void setCadence(int newValue) {
        cadence = newValue;
    }
        
    public void setGear(int newValue) {
        gear = newValue;
    }
        
    public void applyBrake(int decrement) {
        speed -= decrement;
    }
        
    public void speedUp(int increment) {
        speed += increment;
    }
        
}
</code></pre><h5 id="overloading-methods">Overloading Methods</h5>
<p>The Java programming language supports <em>overloading</em> methods, and Java can distinguish between methods with different <em>method signatures</em>. This means that methods within a class can have the same name if they have different parameter lists (there are some qualifications to this that will be discussed in the lesson titled &ldquo;Interfaces and Inheritance&rdquo;).</p>
<p>You cannot declare more than one method with the same name and the same number and type of arguments, because the compiler cannot tell them apart.</p>
<h5 id="constructors">Constructors</h5>
<p>constructor <strong>use the name of the class</strong> and <strong>have no return type</strong>.</p>
<p>You don&rsquo;t have to provide any constructors for your class, the compiler automatically provides a no-argument, default constructor for any class without constructors. This default constructor will call the no-argument constructor of the superclass. In this situation,</p>
<p>To create a new <code>Bicycle</code> object called <code>myBike</code>, a constructor is called by the <strong><code>new</code></strong> operator:</p>
<pre><code>Bicycle myBike = new Bicycle(30, 0, 8);
</code></pre><p>All classes have at least one constructor. If a class does not explicitly declare any, the Java compiler automatically provides a no-argument constructor, called the <em>default constructor</em>. This default constructor calls the class parent&rsquo;s no-argument constructor, or the <code>Object</code> constructor if the class has no other parent. If the parent has no constructor (<code>Object</code> does have one), the compiler will reject the program.</p>
<h5 id="using-objects">Using Objects</h5>
<p>Code that is outside the object&rsquo;s class must use an object reference or expression, followed by the dot (.) operator, followed by a simple field name, as in:</p>
<pre><code>objectReference.fieldName
</code></pre><p>You also use an object reference to invoke an object&rsquo;s method. You append the method&rsquo;s simple name to the object reference, with an intervening dot operator (.).</p>
<pre><code>objectReference.methodName(argumentList);
</code></pre><p><strong>The Garbage Collector</strong></p>
<p>Some object-oriented languages require that you keep track of all the objects you create and that you explicitly <strong>destroy</strong> them when they are no longer needed. Managing memory explicitly is tedious and error-prone. The Java platform allows you to create as many objects as you want (limited, of course, by what your system can handle), and you don&rsquo;t have to worry about destroying them. The Java runtime environment deletes objects when it determines that they are no longer being used. This process is called <em>garbage collection</em>.</p>
<p>An object is eligible for garbage collection <strong>when there are no more references to that object</strong>. References that are held in a variable are usually dropped <strong>when the variable goes out of scope</strong>. Or, you can <strong>explicitly drop an object reference by setting the variable to the special value <code>null</code>.</strong> Remember that a program can have multiple references to the same object; <strong>all references to an object must be dropped before</strong> the object is eligible for garbage collection.</p>
<p>The Java runtime environment has a garbage collector that periodically frees the memory used by objects that are no longer referenced. The garbage collector does its job automatically when it determines that the time is right.</p>
<h5 id="declaring-classes-1">Declaring Classes</h5>
<p><strong>subclass</strong>:  <strong><code>extends</code></strong>, <strong><code>super</code></strong></p>
<pre><code>public class MountainBike extends Bicycle {
        
    // the MountainBike subclass has one field
    public int seatHeight;

    // the MountainBike subclass has one constructor
    public MountainBike(int startHeight, int startCadence,
                        int startSpeed, int startGear) {
        super(startCadence, startSpeed, startGear);
        seatHeight = startHeight;
    }   
        
    // the MountainBike subclass has one method
    public void setHeight(int newValue) {
        seatHeight = newValue;
    }   

}
</code></pre><h5 id="passing-information-to-a-method-or-a-constructor">Passing Information to a Method or a Constructor</h5>
<p><strong>Arbitrary Number of Arguments</strong></p>
<p>To use varargs, you follow the type of the last parameter by an ellipsis (<strong>three dots</strong>, &hellip;), then a space, and the parameter name.</p>
<pre><code>public Polygon polygonFrom(Point... corners) {
    int numberOfSides = corners.length;
    double squareOfSide1, lengthOfSide1;
    squareOfSide1 = (corners[1].x - corners[0].x)
                     * (corners[1].x - corners[0].x) 
                     + (corners[1].y - corners[0].y)
                     * (corners[1].y - corners[0].y);
    lengthOfSide1 = Math.sqrt(squareOfSide1);

    // more method body code follows that creates and returns a 
    // polygon connecting the Points
}
</code></pre><p><strong>Passing Primitive Data Type Arguments</strong></p>
<p>This means that any changes to the values of the parameters exist only within the scope of the method. When the method returns, the parameters are gone and any changes to them are lost.</p>
<p><strong>Passing Reference Data Type Arguments</strong></p>
<p>Reference data type parameters, such as objects, are also passed into methods <em>by value</em>. This means that when the method returns, the passed-in reference still references the same object as before. <em>However</em>, the values of the object&rsquo;s fields <em>can</em> be changed in the method, if they have the proper access level.</p>
<pre><code>public void moveCircle(Circle circle, int deltaX, int deltaY) {
    // code to move origin of circle to x+deltaX, y+deltaY
    circle.setX(circle.getX() + deltaX);
    circle.setY(circle.getY() + deltaY);
        
    // code to assign a new reference to circle
    circle = new Circle(0, 0);
}
</code></pre><pre><code>moveCircle(myCircle, 23, 56)
</code></pre><p>Inside the method, <code>circle</code> initially refers to <code>myCircle</code>. The method changes the x and y coordinates of the object that <code>circle</code> references (i.e., <code>myCircle</code>) by 23 and 56, respectively. These changes will persist when the method returns. Then <code>circle</code> is assigned a reference to a new <code>Circle</code> object with <code>x = y = 0</code>. <strong>This reassignment has no permanence, however, because the reference was passed in by value and cannot change</strong>. Within the method, the object pointed to by <code>circle</code> has changed, but, when the method returns, <code>myCircle</code> <strong>still references the same <code>Circle</code> object as before the method was called.</strong></p>
<h3 id="object">Object</h3>
<h4 id="creating-objects">Creating Objects</h4>
<pre><code>Point originOne = new Point(23, 94);
</code></pre><ol>
<li><strong>Declaration</strong>: The code set in <strong>bold</strong> are all variable declarations that associate a variable name with an object type.</li>
<li><strong>Instantiation</strong>: The <code>new</code> keyword is a Java operator that creates the object.</li>
<li><strong>Initialization</strong>: The <code>new</code> operator is followed by a call to a constructor, which initializes the new object.</li>
</ol>
<h3 id="more-on-classes">More on Classes</h3>
<h4 id="returning-a-value-from-a-method">Returning a Value from a Method</h4>
<p>A method can return a primitive type or a reference type.</p>
<p>When a method uses a class name as its return type, <strong>the class of the type of the returned object must be either a subclass of, or the exact class of, the return type.</strong></p>
<p>This technique, called <em><strong>covariant return type</strong></em>, means that the return type is allowed to vary in the same direction as the subclass.</p>
<h4 id="using-the-this-keyword">Using the this Keyword</h4>
<p>Within an <strong>instance method or a constructor</strong>, <strong><code>this</code> is a reference to the <em>current object</em></strong> — the object whose method or constructor is being called. You can refer to any member of the current object from within an instance method or a constructor by using <code>this</code>.</p>
<p><strong>Using this with a Constructor</strong></p>
<p>From within a constructor, you can also use the <code>this</code> keyword to call another constructor in the same class. Doing so is called an <em><strong>explicit constructor invocation</strong></em>.</p>
<pre><code>public class Rectangle {
    private int x, y;
    private int width, height;
        
    public Rectangle() {
        this(0, 0, 1, 1);
    }
    public Rectangle(int width, int height) {
        this(0, 0, width, height);
    }
    public Rectangle(int x, int y, int width, int height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    ...
}
</code></pre><h4 id="controlling-access-to-members-of-a-class">Controlling Access to Members of a Class</h4>
<p>Access level modifiers determine whether other classes can use a particular field or invoke a particular method. There are two levels of access control:</p>
<ul>
<li>At the top level—<code>public</code>, or <em>package-private</em> (no explicit modifier).</li>
<li>At the member level—<code>public</code>, <code>private</code>, <code>protected</code>, or <em>package-private</em> (no explicit modifier).</li>
</ul>
<p>A class may be declared with the modifier <code>public</code>, in which case that class is visible to all classes everywhere. If a class has no modifier (the default, also known as <em>package-private</em>), it is visible <strong>only within its own package</strong> (packages are named groups of related classes — you will learn about them in a later lesson.)</p>
<p>At the member level, you can also use the <code>public</code> modifier or no modifier (<em>package-private</em>) just as with top-level classes, and with the same meaning. For members, there are two additional access modifiers: <code>private</code> and <code>protected</code>. The <code>private</code> modifier specifies that the member can only be accessed in its own class. The <code>protected</code> modifier specifies that the member can only be accessed <strong>within its own package</strong> (as with <em>package-private</em>) and, in addition, by <strong>a subclass of its class in another package</strong>.</p>
<h4 id="understanding-class-members">Understanding Class Members</h4>
<ul>
<li>
<p><strong>Class Variables</strong></p>
<p>Fields that have the <strong><code>static</code></strong> modifier in their declaration are called <em>static fields</em> or <em>class variables</em>. They are associated with the class, rather than with any object. Every instance of the class shares a class variable, which is in one fixed location in memory. Any object can change the value of a class variable, but class variables can also be manipulated without creating an instance of the class.</p>
<p>Class variables are referenced by the class name itself, as in</p>
<pre><code>Bicycle.numberOfBicycles
</code></pre><p>You can use the <code>Bicycle</code> constructor to set the <code>id</code> instance variable and increment the <code>numberOfBicycles</code> class variable:</p>
<pre><code>public class Bicycle {
          
    private int cadence;
    private int gear;
    private int speed;
    private int id;
    // add a class variable for the number of Bicycle objects instantiated
    private static int numberOfBicycles = 0;
          
    public Bicycle(int startCadence, int startSpeed, int startGear){
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
  
        // increment number of Bicycles and assign ID number
        id = ++numberOfBicycles;
    }
  
    // new method to return the ID instance variable
    public int getID() {
        return id;
    }
}
</code></pre></li>
<li>
<p><strong>Class Methods</strong></p>
<p>The Java programming language supports static methods as well as static variables. Static methods, which have the <code>static</code> modifier in their declarations, should be invoked with the class name, without the need for creating an instance of the class, as in</p>
<pre><code>ClassName.methodName(args)
</code></pre><p><strong>A common use for static methods is to access static fields.</strong></p>
<pre><code>public static int getNumberOfBicycles() {
    return numberOfBicycles;
}
</code></pre></li>
<li>
<p><strong>Constants</strong></p>
<p>The <code>static</code> modifier, in combination with the <code>final</code> modifier, is also used to define constants. <strong>The <code>final</code> modifier indicates that the value of this field cannot change.</strong></p>
<pre><code>static final double PI = 3.141592653589793;
</code></pre><p>Constants defined in this way cannot be reassigned, and it is a compile-time error if your program tries to do so. By convention, the names of constant values are spelled in uppercase letters. If the name is composed of more than one word, the words are separated by an underscore (_).</p>
</li>
</ul>
<h4 id="initializing-fields">Initializing Fields</h4>
<p>If initialization requires some logic (for example, error handling or a <code>for</code> loop to fill a complex array), simple assignment is inadequate. Instance variables can be initialized in constructors, where error handling or other logic can be used. To provide the same capability for class variables, the Java programming language includes <em><strong>static initialization blocks</strong></em>.</p>
<ul>
<li>
<p><strong>Static Initialization Blocks</strong></p>
<pre><code>class Whatever {
    public static varType myVar = initializeClassVariable();
          
    private static varType initializeClassVariable() {
        // initialization code goes here
    }
}
</code></pre></li>
<li>
<p><strong>Initializing Instance Members</strong></p>
<p>A <em>final method</em> cannot be overridden in a subclass.</p>
<pre><code>class Whatever {
    private varType myVar = initializeInstanceVariable();
          
    protected final varType initializeInstanceVariable() {
        // initialization code goes here
    }
}
</code></pre></li>
</ul>
<h3 id="packages">Packages</h3>
<p>Packages are a feature of the Java programming language that help you to organize and structure your classes and their relationships to one another.</p>
<p>A package is a namespace that organizes a set of related classes and interfaces.</p>
<p>The <a href="https://docs.oracle.com/javase/8/docs/api/index.html">Java Platform API Specification</a> contains the complete listing for all packages, interfaces, classes, fields, and methods supplied by the Java SE platform. Load the page in your browser and bookmark it. As a programmer, it will become your single most important piece of reference documentation.</p>
<h4 id="creating-and-using-packages">Creating and Using Packages</h4>
<h5 id="creating-a-package">Creating a Package</h5>
<pre><code>package packageName;
</code></pre><p>must be the first line in the source file.</p>
<p>If you put multiple types in a single source file, only one can be <code>public</code>, and it <strong>must have the same name as the source file</strong>. For example, you can define <code>public class Circle</code> in the file <code>Circle.java</code>, define <code>public interface Draggable</code> in the file <code>Draggable.java</code>, define <code>public enum Day</code> in the file <code>Day.java</code>, and so forth.</p>
<h5 id="naming-a-package">Naming a Package</h5>
<p>Naming Conventions: Package names are written in all lower case to avoid conflict with the names of classes or interfaces.</p>
<p>perhaps by including the region or the project name after the company name (for example, <code>com.example.region.mypackage</code>).</p>
<p>Packages in the Java language itself begin with <code>java.</code> or <code>javax.</code></p>
<h5 id="using-package-members">Using Package Members</h5>
<ul>
<li>
<p>Referring to a Package Member by Its Qualified Name</p>
<p><strong>use fully qualified name when name ambiguities</strong></p>
<pre><code>packagename.TypeName
</code></pre></li>
<li>
<p>Importing a Package Member</p>
<pre><code>import packagename.TypeName;
</code></pre></li>
<li>
<p>Importing an Entire Package</p>
<pre><code>import packagename.*;
</code></pre></li>
</ul>
<p>At first, **packages appear to be hierarchical, but they are not. **The prefix is used for a number of related packages to make the relationship evident, but not to show inclusion.</p>
<p>you must import both packages with all their files:</p>
<pre><code>import java.awt.*;
import java.awt.color.*;
</code></pre><p>The Static Import Statement allow you access to static final fields (constants) and static methods from one or two classes.</p>
<pre><code>import static java.lang.Math.PI;
import static mypackage.MyConstants.*;
</code></pre><h5 id="managing-source-and-class-files">Managing Source and Class Files</h5>
<h3 id="documentation-comments">Documentation Comments</h3>
<h4 id="comment-insertion">Comment Insertion</h4>
<ul>
<li>Modules</li>
<li>Packages</li>
<li>Public classes and interfaces</li>
<li>Public and protected fields</li>
<li>Public and protected constructors and methods</li>
</ul>
<p>You can (and should) supply a comment for each of these features.</p>
<h4 id="class-comments">Class Comments</h4>
<p>The class comment must be placed after any import statements, directly before the class definition.</p>
<h4 id="method-comments">Method Comments</h4>
<p>Each method comment must immediately precede the method that it describes.</p>
<p>In addition to the general-purpose tags, you can use the following tags:</p>
<ul>
<li><strong><code>@param</code></strong> variable description</li>
<li><strong><code>@return</code></strong> description</li>
<li><strong><code>@throws</code></strong> class description</li>
</ul>
<h4 id="field-comments">Field Comments</h4>
<p>You only need to document public fields—generally that means static constants.</p>
<h4 id="general-comments">General Comments</h4>
<ul>
<li>
<p><strong><code>@author</code></strong> name</p>
</li>
<li>
<p><strong><code>@version</code></strong> text</p>
</li>
<li>
<p><strong><code>@since</code></strong> text</p>
</li>
<li>
<p><strong><code>@deprecated</code></strong> text</p>
</li>
<li>
<p><strong><code>@see</code></strong> reference</p>
</li>
</ul>
<h2 id="inheritance">Inheritance</h2>
<p>In the Java language, classes can be <em>derived</em> from other classes, thereby <em>inheriting</em> fields and methods from those classes. In the absence of any other explicit superclass, every class is implicitly a subclass of <code>Object</code>.</p>
<p><strong>Constructors</strong> are not members, so they <strong>are not inherited by subclasses</strong>, but <strong>the constructor of the superclass can be invoked from the subclass</strong>.</p>
<p>A subclass inherits all of the <em>public</em> and <em>protected</em> members of its parent, no matter what package the subclass is in. <strong>If the subclass is in the same package as its parent, it also inherits the <em>package-private</em> members of the parent.</strong></p>
<ul>
<li>You can write a new <em>instance</em> method in the subclass that has the same signature as the one in the superclass, thus <em><strong>overriding</strong></em> it.</li>
<li>You can write a new <em>static</em> method in the subclass that has the same signature as the one in the superclass, thus <em><strong>hiding</strong></em> it.</li>
<li>You can write a subclass constructor that invokes the constructor of the superclass, either implicitly or by using the keyword <strong><code>super</code></strong>.</li>
</ul>
<pre><code>public class Bicycle {
        
    // the Bicycle class has one constructor
    public Bicycle(int startCadence, int startSpeed, int startGear) {
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
    }  
}
</code></pre><pre><code>class MountainBike extends Bicycle {

    // the MountainBike subclass adds one field
    privite int seatHeight;
    
    // the MountainBike subclass has one constructor
    public MountainBike(int startHeight,
                        int startCadence,
                        int startSpeed,
                        int startGear) {
        super(startCadence, startSpeed, startGear);
        seatHeight = startHeight;
    }  
    
    // the MountainBike subclass adds one method
}
</code></pre><h3 id="casting-objects">Casting Objects</h3>
<p><em>Casting</em> shows the use of an object of one type in place of another type, among the objects permitted by inheritance and implementations. For example, if we write</p>
<pre><code>Object obj = new MountainBike();
</code></pre><p>then <code>obj</code> is both an <code>Object</code> and a <code>MountainBike</code> (until such time as <code>obj</code> is assigned another object that is <em>not</em> a <code>MountainBike</code>). This is called <em><strong>implicit casting</strong></em>.</p>
<pre><code>MountainBike myBike = obj;
</code></pre><p>we would get a compile-time error because <code>obj</code> is not known to the compiler to be a <code>MountainBike</code>. However, we can <em>tell</em> the compiler that we promise to assign a <code>MountainBike</code> to <code>obj</code> by <em><strong>explicit casting:</strong></em></p>
<pre><code>MountainBike myBike = (MountainBike)obj;
</code></pre><p>This cast inserts a runtime check that <code>obj</code> is assigned a <code>MountainBike</code> so that the compiler can safely assume that <code>obj</code> is a <code>MountainBike</code>.</p>
<p>You can make a logical test as to the type of a particular object using the <strong><code>instanceof</code></strong> operator. This can save you from a runtime error owing to an improper cast.</p>
<pre><code>if (obj instanceof MountainBike) {
    MountainBike myBike = (MountainBike)obj;
}
</code></pre><p>Here the <code>instanceof</code> operator verifies that <code>obj</code> refers to a <code>MountainBike</code> so that we can make the cast with knowledge that there will be no runtime exception thrown.</p>
<h3 id="overriding-and-hiding-methodsoverloade-methods">Overriding and Hiding Methods、Overloade Methods</h3>
<p><strong>Defining a Method with the Same Signature as a Superclass&rsquo;s Method</strong>:</p>
<table>
<thead>
<tr>
<th>&ndash;</th>
<th><strong>Superclass Instance Method</strong></th>
<th><strong>Superclass Static Method</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Subclass Instance Method</strong></td>
<td>Overrides</td>
<td>Generates a compile-time error</td>
</tr>
<tr>
<td><strong>Subclass Static Method</strong></td>
<td>Generates a compile-time error</td>
<td>Hides</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>Instance Methods</p>
<p>An overriding method can also return a subtype of the type returned by the overridden method. This subtype is called a <em><strong>covariant return type</strong></em>.</p>
<p>When overriding a method, you might want to use the <strong><code>@Override</code></strong> annotation that instructs the compiler that you intend to override a method in the superclass.</p>
</li>
<li>
<p>Static Methods:</p>
<p>The distinction between <strong>hiding a static method</strong> and <strong>overriding an instance method</strong> has important implications:</p>
<ul>
<li>
<p>The version of the overridden instance method that gets invoked is the one in the subclass.</p>
</li>
<li>
<p><strong>The version of the hidden static method that gets invoked depends on whether it is invoked from the superclass or the subclass.</strong></p>
<pre><code>public class Animal {
    public static void testClassMethod() {
        System.out.println(&quot;The static method in Animal&quot;);
    }
    public void testInstanceMethod() {
        System.out.println(&quot;The instance method in Animal&quot;);
    }
}
public class Cat extends Animal {
    public static void testClassMethod() {
        System.out.println(&quot;The static method in Cat&quot;);
    }
    public void testInstanceMethod() {
        System.out.println(&quot;The instance method in Cat&quot;);
    }
    
    public static void main(String[] args) {
        Cat myCat = new Cat();
        Animal myAnimal = myCat;
        Animal.testClassMethod();   // The static method in Animal
        myAnimal.testInstanceMethod();  // The instance method in Cat
    }
}
</code></pre></li>
</ul>
</li>
<li>
<p>Interface Methods</p>
<p><strong>Default methods</strong> and <strong>abstract methods</strong> in interfaces are inherited like instance methods. <strong>Static methods</strong> in interfaces are never inherited.</p>
<p><strong>Instance methods are preferred over interface default methods.</strong></p>
</li>
</ul>
<p>In a subclass, you can overload the methods inherited from the superclass. Such <strong>overloaded</strong> methods neither hide nor override the superclass instance methods—they are new methods, unique to the subclass.</p>
<h3 id="polymorphism">Polymorphism</h3>
<pre><code>public class TestBikes {
  public static void main(String[] args){
    Bicycle bike01, bike02, bike03;

    bike01 = new Bicycle(20, 10, 1);
    bike02 = new MountainBike(20, 10, 5, &quot;Dual&quot;);
    bike03 = new RoadBike(40, 20, 8, 23);

    bike01.printDescription();
    bike02.printDescription();
    bike03.printDescription();
  }
}
</code></pre><h3 id="using-the-keyword-super">Using the Keyword super</h3>
<pre><code>public class Superclass {
    public void printMethod() {
        System.out.println(&quot;Printed in Superclass.&quot;);
    }
}
public class Subclass extends Superclass {
    // overrides printMethod in Superclass
    public void printMethod() {
        super.printMethod();
        System.out.println(&quot;Printed in Subclass&quot;);
    }
    public static void main(String[] args) {
        Subclass s = new Subclass();
        s.printMethod();    
    }
}
</code></pre><pre><code>public MountainBike(int startHeight, 
                    int startCadence,
                    int startSpeed,
                    int startGear) {
    super(startCadence, startSpeed, startGear);
    seatHeight = startHeight;
}   
</code></pre><p>If a subclass constructor invokes a constructor of its superclass, either explicitly or implicitly, you might think that there will be a whole chain of constructors called, all the way back to the constructor of <code>Object</code>,  it is called <em><strong>constructor chaining</strong></em></p>
<h3 id="object-as-a-superclass">Object as a Superclass</h3>
<ul>
<li>
<pre><code>protected Object clone() throws CloneNotSupportedException
</code></pre><p>The simplest way to make your class cloneable is to add <strong><code>implements Cloneable</code></strong> to your class&rsquo;s declaration. then your objects can invoke the <code>clone()</code> method.</p>
<p>An object contains a reference to an external object, say <code>ObjExternal</code>, you may need to override <code>clone()</code> to get correct behavior.</p>
</li>
<li>
<pre><code>public boolean equals(Object obj)
</code></pre><pre><code>public class Book {
    ...
    public boolean equals(Object obj) {
        if (obj instanceof Book)
            return ISBN.equals((Book)obj.getISBN()); 
        else
            return false;
    }
}
</code></pre><p>If you override <code>equals()</code>, you must override <code>hashCode()</code> as well.</p>
</li>
<li>
<pre><code>protected void finalize() throws Throwable
</code></pre><p>you can override <code>finalize()</code> to do cleanup, such as freeing resources.</p>
</li>
<li>
<pre><code>public final Class getClass()
</code></pre><p>You cannot override <code>getClass</code>.</p>
<pre><code>void printClassName(Object obj) {
    System.out.println(&quot;The object's&quot; + &quot; class is &quot; +
        obj.getClass().getSimpleName());
}
</code></pre></li>
<li>
<pre><code>public int hashCode()
</code></pre><p>The value returned by <code>hashCode()</code> is the object&rsquo;s hash code, which is the object&rsquo;s memory address in hexadecimal.</p>
<p>By definition, if two objects are equal, their hash code <em>must also</em> be equal. If you override the <code>equals()</code> method, you change the way two objects are equated and <code>Object</code>&rsquo;s implementation of <code>hashCode()</code> is no longer valid. <strong>Therefore, if you override the <code>equals()</code> method, you must also override the <code>hashCode()</code> method as well.</strong></p>
</li>
<li>
<pre><code>public String toString()
</code></pre><p><strong>You should always consider overriding the <code>toString()</code> method in your classes.</strong> The <code>Object</code>&rsquo;s <code>toString()</code> method returns a <code>String</code> representation of the object, <strong>which is very useful for debugging</strong>.</p>
<pre><code>System.out.println(firstBook.toString());
</code></pre></li>
</ul>
<p>Writing Final Classes and Methods</p>
<p>You can declare some or all of a class&rsquo;s methods <em>final</em>. You use the <strong><code>final</code></strong> keyword in a method declaration to indicate that the method cannot be overridden by subclasses.</p>
<pre><code>class ChessAlgorithm {
    enum ChessPlayer { WHITE, BLACK }
    ...
    final ChessPlayer getFirstPlayer() {
        return ChessPlayer.WHITE;
    }
    ...
}
</code></pre><p>You might wish to make a method final if it has an implementation that should not be changed and it is critical to the consistent state of the object.</p>
<p>**Methods called from constructors should generally be declared final. **Note that you can also declare an entire class final. A class that is declared final cannot be subclassed.</p>
<h3 id="abstract-methods-and-classes">Abstract Methods and Classes</h3>
<p>An <em>abstract class</em> is a class that is declared <strong><code>abstract</code></strong>—it may or may not include abstract methods. Abstract classes cannot be instantiated, but they can be subclassed.</p>
<pre><code>public abstract class GraphicObject {
   // declare fields
   // declare nonabstract methods
   abstract void draw();
}
</code></pre><p>When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods in its parent class. However, i<strong>f it does not, then the subclass must also be declared <code>abstract</code>.</strong></p>
<p><strong>Abstract Classes Compared to Interfaces</strong>:</p>
<ul>
<li>similar:
<ul>
<li>cannot instantiate</li>
<li>may contain a mix of methods declared with or without an implementation</li>
</ul>
</li>
<li>difference:
<ul>
<li>abstract classes, you can declare fields that are not static and final, and define public, protected, and private concrete methods.</li>
<li>interfaces, all fields are automatically public, static, and final, and all methods that you declare or define (as default methods) are public.</li>
<li>you can extend only one class, whether or not it is abstract, whereas you can implement any number of interfaces.</li>
</ul>
</li>
</ul>
<p>It is possible to define a class that does not implement all of the interface&rsquo;s methods, provided that the class is declared to be <code>abstract</code>.</p>
<h3 id="enumeration-classes">Enumeration Classes</h3>
<h3 id="reflection">Reflection</h3>
<p>A program that can <strong>analyze the capabilities of classes</strong> is called <strong>reflective</strong>. The
reflection mechanism is extremely powerful. As the next sections show, you
can use it to</p>
<ul>
<li>Analyze the capabilities of classes at runtime</li>
<li>Inspect objects at runtime—for example, to write a single toString method that works for all classes</li>
<li>Implement generic array manipulation code</li>
<li>Take advantage of Method objects that work just like function pointers in languages such as C++</li>
</ul>
<h4 id="the-class-class">The Class Class</h4>
<pre><code>Employee e;
. . .
Class cl = e.getClass();
</code></pre><pre><code>System.out.println(e.getClass().getName() + &quot; &quot; + e.getName());
</code></pre><p>If the class is in a package, the package name is part of the class name:</p>
<pre><code>var generator = new Random();
Class cl = generator.getClass();
String name = cl.getName(); // name is set to &quot;java.util.Random&quot;
</code></pre><p>You can obtain a Class object corresponding to a class name by using the static <strong><code>forName</code></strong> method.</p>
<pre><code>try {
    String className = &quot;java.util.Random&quot;;
    Class cl = Class.forName(className);
} catch(ClassNotFoundException e) {
   e.printStackTrace();
}
</code></pre><p>A third method for obtaining an object of type Class is a convenient shorthand. If T is any Java type (or the void keyword), then <strong><code>T.class</code></strong> is the matching class object.</p>
<pre><code>Class cl1 = Random.class; // if you import java.util.*;
Class cl2 = int.class;
Class cl3 = Double[].class;
</code></pre><p>use the <strong><code>==</code></strong> operator to compare class objects.</p>
<pre><code>if (e.getClass() == Employee.class) . . .
</code></pre><p>use the <strong><code>newInstance</code></strong> method to construct an instance</p>
<pre><code>var className = &quot;java.util.Random&quot;; // or any other name of a class with a no-arg constructor
Class cl = Class.forName(className);
Object obj = cl.getConstructor().newInstance();
</code></pre><h4 id="resources">Resources</h4>
<p>Classes often have associated data files, such as:</p>
<ul>
<li>Image and sound files</li>
<li>Text files with message strings and button labels</li>
</ul>
<p>In Java, such an associated file is called a resource.</p>
<p>The Class class provides a useful service for locating resource files.</p>
<pre><code>import java.net.*;
import java.nio.charset.*;
import javax.swing.*;

public class ResourceTest
{
    public static void main(String[] args) throws IOException
    {
        Class cl = ResourceTest.class;
        URL aboutURL = cl.getResource(&quot;about.gif&quot;);
        var icon = new ImageIcon(aboutURL);
        InputStream stream = cl.getResourceAsStream(&quot;data/about.txt&quot;);
        var about = new String(stream.readAllBytes(), &quot;UTF-8&quot;);
        InputStream stream2 = cl.getResourceAsStream(&quot;/corejava/title.txt&quot;);
        var title = new String(stream2.readAllBytes(), StandardCharsets.UTF_8
        JOptionPane.showMessageDialog(null, about, title, JOptionPane.INFORMA
    }
}
</code></pre><h4 id="using-reflection-to-analyze-the-capabilities-of-classes">Using Reflection to Analyze the Capabilities of Classes</h4>
<p>print out all information about a class.</p>
<pre><code>import java.lang.reflect.*;

Class cl = Class.forName(name);
Class supercl = cl.getSuperclass();
String modifiers = Modifier.toString(cl.getModifiers());
if (modifiers.length() &gt; 0) 
	System.out.print(modifiers);
if (supercl != null &amp;&amp; supercl != Object.class) 
	System.out + supercl.getName());
</code></pre><pre><code>Constructor[] constructors = cl.getDeclaredConstructors();
for (Constructor c : constructors) 
{
	String name = c.getName();
	String modifiers = Modifier.toString(c.getModifiers());
	Class[] paramTypes = c.getParameterTypes();
    for (int j = 0; j &lt; paramTypes.length; j++)
    {
        if (j &gt; 0) System.out.print(&quot;, &quot;);
        System.out.print(paramTypes[j].getName());
    }
}
</code></pre><pre><code>Method[] methods = cl.getDeclaredMethods();
for (Method m : methods)
{
    Class retType = m.getReturnType();
    String name = m.getName();
    String modifiers = Modifier.toString(m.getModifiers());
    if (modifiers.length() &gt; 0) 
    	System.out.print(modifiers + &quot; &quot;);
	System.out.print(retType.getName() + &quot; &quot; + name + &quot;(&quot;);

    // print parameter types
    Class[] paramTypes = m.getParameterTypes();
    for (int j = 0; j &lt; paramTypes.length; j++)
    {
        if (j &gt; 0) 
        	System.out.print(&quot;, &quot;);
        System.out.print(paramTypes[j].getName());
    }
    System.out.println(&quot;);&quot;);
}
</code></pre><pre><code>Field[] fields = cl.getDeclaredFields();
for (Field f : fields)
{
    Class type = f.getType();
    String name = f.getName();
    System.out.print(&quot;&quot;);
    String modifiers = Modifier.toString(f.getModifiers());
    if (modifiers.length() &gt; 0) 
    	System.out.print(modifiers + &quot; &quot;);
    System.out.println(type.getName() + &quot; &quot; + name + &quot;;&quot;);
}
</code></pre><h2 id="interfaces-lambda-expressions-and">Interfaces, Lambda Expressions, and</h2>
<p>Inner Classes</p>
<h3 id="interface">Interface</h3>
<p>In the Java programming language, an <em>interface</em> is a reference type, similar to a class, that can contain <em>only</em> constants, method signatures, default methods, static methods, and nested types. Method bodies exist only for default methods and static methods. Interfaces cannot be instantiated—they can only be <em><strong>implemented</strong></em> by classes or <em><strong>extended</strong></em> by other interfaces.</p>
<h4 id="defining-an-interface">Defining an Interface</h4>
<p>The <code>public</code> access specifier indicates that the interface can be used by any class in any package. If you do not specify that the interface is public, then your interface is accessible only to classes defined in the same package as the interface.</p>
<p>An interface can extend other interfaces, just as a class subclass or extend another class. However, whereas a class can extend only one other class, an interface can extend any number of interfaces. The interface declaration includes a comma-separated list of all the interfaces that it extends.</p>
<pre><code>public interface Bicycle {
    // constant declarations
    
    // method signatures
    void changeCadence(int newValue);
    void changeGear(int newValue);
    void speedUp(int increment);
    void applyBrakes(int decrement);
    public int isLargerThan(Bicycle other);
}
</code></pre><p>Note that the method signatures have no braces and are terminated with a semicolon.</p>
<p>The interface body can contain <strong>abstract methods</strong>, <strong>default methods</strong>, and <strong>static methods</strong>. An abstract method within an interface is followed by a semicolon, but no braces (an abstract method does <strong>not contain an implementation</strong>). Default methods are defined with the <strong>default modifier</strong>, and static methods with the <strong>static keyword</strong>. All abstract, default, and static methods in an interface are <strong>implicitly public</strong>, so you can omit the public modifier.</p>
<p>In addition, an interface can contain constant declarations. All constant values defined in an interface are <strong>implicitly public, static, and final.</strong> Once again, you can omit these modifiers.</p>
<h4 id="implementing-an-interface">Implementing an Interface</h4>
<p>To use an interface, you write a class that <em><strong>implements</strong></em> the interface. When an instantiable class implements an interface, it provides a method body for each of the methods declared in the interface.</p>
<pre><code>public class ACMEBicycle implements Bicycle {
    int cadence = 0;
    int speed = 0;
    int gear = 1;
    double price = 0;
   // The compiler will now require that methods changeCadence, changeGear, speedUp, and applyBrakes
   // all be implemented. Compilation will fail if those
   // methods are missing from this class.
    void changeCadence(int newValue) {
         cadence = newValue;
    }
    void changeGear(int newValue) {
         gear = newValue;
    }
    void speedUp(int increment) {
         speed = speed + increment;   
    }
    void applyBrakes(int decrement) {
         speed = speed - decrement;
    }
    void printStates() {
         System.out.println(&quot;cadence:&quot; +
             cadence + &quot; speed:&quot; + 
             speed + &quot; gear:&quot; + gear);
    }
    void getPrice() {
         return this.price;
    }
    public int isMoreExpensive(Bicycle other) {
        // casts other to a ACMEBicycle instance. 
        ACMEBicycle otherBicycle 
            = (ACMEBicycle)other;
        if (this.getPrice() &lt; otherBicycle.getPrice())
            return -1;
        else if (this.getPrice() &gt; otherBicycle.getPrice())
            return 1;
        else
            return 0;               
    }
}
</code></pre><p>Because <code>ACMEBicycle</code> implements <code>Bicycle</code>, the price of any two <code>ACMEBicycle</code> objects can be compared.</p>
<p><code>(ACMEBicycle)other</code> casts <code>other</code> to a <code>ACMEBicycle</code> instance. <strong>Type casting tells the compiler what the object really is</strong>. Invoking <code>getPrice</code> directly on the <code>other</code> instance (<code>other.getPrice()</code>) would fail to compile because the compiler does not understand that <code>other</code> is actually an instance of <code>ACMEBicycle</code>.</p>
<h4 id="using-an-interface-as-a-type">Using an Interface as a Type</h4>
<pre><code>public Object findMoreExpensive(Object object1, Object object2) {
   Bicycle obj1 = (Bicycle)object1;
   Bicycle obj2 = (Bicycle)object2;
   if ((obj1).isMoreExpensive(obj2) &gt; 0)
      return object1;
   else 
      return object2;
}
</code></pre><p>By casting <code>object1</code> to a <code>Bicycle</code> type, it can invoke the <code>isMoreExpensive</code> method.</p>
<p>These methods work for any &ldquo;Bicycle&rdquo; objects, no matter what their class inheritance is. When they implement <code>Bicycle</code>, they can be of both their own class (or superclass) type and a <code>Bicycle</code> type. This gives them some of the advantages of multiple inheritance, where they can have behavior from both a superclass and an interface.</p>
<h4 id="evolving-interfaces">Evolving Interfaces</h4>
<pre><code>public interface DoIt {
   void doSomething(int i, double x);
   int doSomethingElse(String s);
}
</code></pre><p>Suppose that, at a later time, you want to add a third method to <code>DoIt</code>, so that the interface now becomes:</p>
<pre><code>public interface DoIt {
   void doSomething(int i, double x);
   int doSomethingElse(String s);
   boolean didItWork(int i, double x, String s);
   
}
</code></pre><p>If you make this change, then all classes that implement the old <code>DoIt</code> interface will break because they no longer implement the old interface. Programmers relying on this interface will protest loudly.</p>
<pre><code>public interface DoItPlus extends DoIt {
   boolean didItWork(int i, double x, String s);
}
</code></pre><p>Now users of your code can choose to continue to use the old interface or to upgrade to the new interface.</p>
<p>Alternatively, you can define your new methods as <strong>default methods</strong>.</p>
<pre><code>public interface DoIt {
   void doSomething(int i, double x);
   int doSomethingElse(String s);
   default boolean didItWork(int i, double x, String s) {
       // Method body 
   }
}
</code></pre><p>Note that you must provide an implementation for default methods. You could also define new static methods to existing interfaces. Users who have classes that implement interfaces enhanced with new default or static methods do not have to modify or recompile them to accommodate the additional methods.</p>
<h4 id="default-methods">Default Methods</h4>
<p>Add new functionality to the interfaces, If they add them as <strong>static methods</strong>, then programmers would <strong>regard them as utility methods, not as essential, core methods.</strong></p>
<p>Default methods enable you to add new functionality to the interfaces of your libraries and ensure binary compatibility with code written for older versions of those interfaces.</p>
<p>Extending Interfaces That Contain Default Methods:</p>
<ul>
<li>Not mention the default method at all, which lets your extended interface inherit the default method.</li>
<li>Redeclare the default method, which makes it <code>abstract</code>.</li>
<li>Redefine the default method, which overrides it.</li>
</ul>
<h4 id="static-methods">Static Methods</h4>
<p>In addition to default methods, you can <strong>define static methods in interfaces</strong>. (A static method is a method that is associated with the class in which it is defined rather than with any object. Every instance of the class shares its static methods.) This makes it easier for you to organize helper methods in your libraries; you can <strong>keep static methods specific to an interface in the same interface rather than in a separate class</strong>.</p>
<pre><code>public interface TimeClient {
    // ...
    static public ZoneId getZoneId (String zoneString) {
        try {
            return ZoneId.of(zoneString);
        } catch (DateTimeException e) {
            System.err.println(&quot;Invalid time zone: &quot; + zoneString +
                &quot;; using default time zone instead.&quot;);
            return ZoneId.systemDefault();
        }
    }

    default public ZonedDateTime getZonedDateTime(String zoneString) {
        return ZonedDateTime.of(getLocalDateTime(), getZoneId(zoneString));
    }    
}
</code></pre><h3 id="lambda-expressions">Lambda Expressions</h3>
<h3 id="nested-classes">Nested Classes</h3>
<pre><code>public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
    THURSDAY, FRIDAY, SATURDAY 
}
</code></pre><pre><code>public class EnumTest {
    Day day;
    
    public EnumTest(Day day) {
        this.day = day;
    }
    
    public void tellItLikeItIs() {
        switch (day) {
            case MONDAY:
                System.out.println(&quot;Mondays are bad.&quot;);
                break;
            case FRIDAY:
                System.out.println(&quot;Fridays are better.&quot;);
                break;      
            case SATURDAY: case SUNDAY:
                System.out.println(&quot;Weekends are best.&quot;);
                break        
            default:
                System.out.println(&quot;Midweek days are so-so.&quot;);
                break;
        }
    }
    public static void main(String[] args) {
        EnumTest firstDay = new EnumTest(Day.MONDAY);
        firstDay.tellItLikeItIs();
    }
}
</code></pre><pre><code>for (Day d : Day.values()) {
}
</code></pre><h3 id="service-loaders">Service Loaders</h3>
<h3 id="proxies">Proxies</h3>
<h2 id="exceptions-assertions-and-logging">Exceptions, Assertions, and Logging</h2>
<h3 id="dealing-with-errors">Dealing with Errors</h3>
<h3 id="caching-exceptions">Caching Exceptions</h3>
<h3 id="using-assertions">Using Assertions</h3>
<h3 id="logging">Logging</h3>
<h3 id="debugging-tips">Debugging Tips</h3>
<h2 id="annotations">Annotations</h2>
<p><em>Annotations</em>, a form of <strong>metadata</strong>, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate.</p>
<h3 id="annotations-basics">Annotations Basics</h3>
<p>The at sign character (<code>@</code>) indicates to the compiler that what follows is an annotation.</p>
<p>The annotation type can be one of the types that are defined in the <code>java.lang</code> or <code>java.lang.annotation</code> packages of the Java SE API. It is also possible to define your own annotation type.</p>
<pre><code>@Override
void mySuperMethod() { ... }
@SuppressWarnings(value = &quot;unchecked&quot;)
void myMethod() { ... }
</code></pre><p>Annotations can be applied to declarations: declarations of classes, fields, methods, and other program elements. Annotations can also be applied to the <em>use</em> of types. This form of annotation is called a <em>type annotation</em>.</p>
<h3 id="declaring-an-annotation-type">Declaring an Annotation Type</h3>
<p>Many annotations replace comments in code.</p>
<pre><code>public class Generation3List extends Generation2List {
   // Author: John Doe
   // Date: 3/17/2002
   // Current revision: 6
   // Last modified: 4/12/2004
   // By: Jane Doe
   // Reviewers: Alice, Bill, Cindy

   // class code goes here
}
</code></pre><p>To add this same metadata with an annotation, you must first define the <em>annotation type</em>.</p>
<p>The keyword <code>interface</code> is preceded by the at sign (<code>@</code>) (@ = AT, as in annotation type). Annotation types are a form of <em>interface</em>.</p>
<p><strong>Optional</strong>: To make the information in <code>@ClassPreamble</code> appear in Javadoc-generated documentation, you must annotate the <code>@ClassPreamble</code> definition with the <code>@Documented</code> annotation:</p>
<pre><code>// import this to use @Documented
import java.lang.annotation.*;

@Documented
@interface ClassPreamble {
   String author();
   String date();
   int currentRevision() default 1;
   String lastModified() default &quot;N/A&quot;;
   String lastModifiedBy() default &quot;N/A&quot;;
   // Note use of array
   String[] reviewers();
}
</code></pre><pre><code>@ClassPreamble (
   author = &quot;John Doe&quot;,
   date = &quot;3/17/2002&quot;,
   currentRevision = 6,
   lastModified = &quot;4/12/2004&quot;,
   lastModifiedBy = &quot;Jane Doe&quot;,
   // Note array notation
   reviewers = {&quot;Alice&quot;, &quot;Bob&quot;, &quot;Cindy&quot;}
)
public class Generation3List extends Generation2List {
	// class code goes here
}
</code></pre><h3 id="predefined-annotation-types">Predefined Annotation Types</h3>
<p>Annotation Types Used by the Java Language:</p>
<ul>
<li>
<p><code>@Deprecated</code></p>
<pre><code>   // Javadoc comment follows
    /**
     * @deprecated
     * explanation of why it was deprecated
     */
    @Deprecated
    static void deprecatedMethod() { }
}
</code></pre></li>
<li>
<p><code>@Override</code></p>
<pre><code>   // mark method as a superclass method
   // that has been overridden
   @Override 
   int overriddenMethod() { }
</code></pre></li>
<li>
<p><code>@SuppressWarnings</code></p>
<pre><code>   // use a deprecated method and tell 
   // compiler not to generate a warning
   // To suppress multiple categories of warnings, use the following syntax:
   // @SuppressWarnings({&quot;unchecked&quot;, &quot;deprecation&quot;})
   @SuppressWarnings(&quot;deprecation&quot;)
    void useDeprecatedMethod() {
        objectOne.deprecatedMethod();
    }
</code></pre></li>
</ul>
<p>Annotations That Apply to Other Annotations:</p>
<ul>
<li><code>@Retention</code></li>
<li><code>@Documented</code></li>
<li><code>@Target</code></li>
<li><code>@Inherited</code></li>
<li><code>@Repeatable</code></li>
</ul>
<h3 id="type-annotations-and-pluggable-type-systems">Type Annotations and Pluggable Type Systems</h3>
<p>Type annotations were created to support improved analysis of Java programs way of ensuring stronger type checking. For example, you want to ensure that a particular variable in your program is never assigned to null; you want to avoid triggering a <code>NullPointerException</code>.</p>
<pre><code>@NonNull String str;
</code></pre><p>In many cases, you do not have to write your own type checking modules. There are third parties who have done the work for you. For example, you might want to take advantage of the Checker Framework created by the University of Washington. This framework includes a <code>NonNull</code> module, as well as a regular expression module, and a mutex lock module. For more information, see the <a href="http://types.cs.washington.edu/checker-framework/">Checker Framework</a>.</p>
<h3 id="repeating-annotations">Repeating Annotations</h3>
<p><strong>Declare a Repeatable Annotation Type</strong>:</p>
<pre><code>import java.lang.annotation.Repeatable;

@Repeatable(Schedules.class)
public @interface Schedule {
  String dayOfMonth() default &quot;first&quot;;
  String dayOfWeek() default &quot;Mon&quot;;
  int hour() default 12;
}
</code></pre><pre><code>public @interface Schedules { 
    Schedule [] value（）; 
}
</code></pre><pre><code>@Schedule(dayOfMonth=&quot;last&quot;)
@Schedule(dayOfWeek=&quot;Fri&quot;, hour=&quot;23&quot;)
public void doPeriodicCleanup() { ... }
</code></pre><h2 id="generics">Generics</h2>
<p>are a powerful feature of the Java programming language. They improve the type safety of your code, making more of your bugs detectable at compile time.</p>
<h3 id="heading"></h3>
<h2 id="heading-1"></h2>
<h2 id="concurrency">concurrency</h2>
<h2 id="regular-expressions">regular expressions</h2>
<h2 id="the-platform-environment">the platform environment.</h2>
<p>aaa</p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Ye Zheng</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2019-03-01
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="http://csyezheng.github.io/tags/java/">Java</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/programming-languages/go/standard-library/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">standard-library</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/programming-languages/python/standard-library-by-example/">
            <span class="next-text nav-default">The Python Standard Library</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:csyezheng@gmail.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://stackoverflow.com/users/5694480" rel="me noopener" class="iconfont"
      title="stack-overflow"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M809.714286 932.571429l-638.857143 0 0-274.285714-91.428571 0 0 365.714286 821.714286 0 0-365.714286-91.428571 0 0 274.285714zm-538.285714-299.428571l18.857143-89.714286 447.428571 94.285714-18.857143 89.142857zm58.857143-213.714286l38.285714-83.428571 414.285714 193.714286-38.285714 82.857143zm114.857143-203.428571l58.285714-70.285714 350.857143 293.142857-58.285714 70.285714zm226.857143-216l272.571429 366.285714-73.142857 54.857143-272.571429-366.285714zm-410.285714 840.571429l0-90.857143 457.142857 0 0 90.857143-457.142857 0z"></path>
</svg>

    </a>
  
    <a href="https://www.linkedin.com/in/%E7%83%A8-%E9%83%91-a2a987100/" rel="me noopener" class="iconfont"
      title="linkedin"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="33" height="33">
  <path d="M872.405333 872.618667h-151.637333v-237.610667c0-56.661333-1.152-129.578667-79.018667-129.578667-79.061333 0-91.136 61.653333-91.136 125.397334v241.792H398.976V384h145.664v66.602667h1.962667c20.352-38.4 69.845333-78.933333 143.786666-78.933334 153.642667 0 182.058667 101.12 182.058667 232.746667v268.202667zM227.712 317.141333a87.978667 87.978667 0 0 1-88.021333-88.106666 88.064 88.064 0 1 1 88.021333 88.106666z m76.032 555.477334H151.68V384h152.064v488.618667zM948.266667 0H75.562667C33.792 0 0 33.024 0 73.770667v876.458666C0 991.018667 33.792 1024 75.562667 1024h872.576C989.866667 1024 1024 991.018667 1024 950.229333V73.770667C1024 33.024 989.866667 0 948.138667 0h0.128z"></path>
</svg>

    </a>
  
    <a href="https://github.com/csyezheng" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="http://csyezheng.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/csyezheng/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2017 -
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        Ye Zheng
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  















</body>
</html>
