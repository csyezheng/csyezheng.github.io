<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ye Zheng&#39;s Blog</title>
    <link>http://www.yezheng.pro/</link>
    <description>Recent content on Ye Zheng&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 01 Apr 2021 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="http://www.yezheng.pro/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>http://www.yezheng.pro/about/</link>
      <pubDate>Mon, 25 Sep 2017 21:38:52 +0800</pubDate>
      
      <guid>http://www.yezheng.pro/about/</guid>
      
        <description>&lt;p&gt;I&amp;rsquo;m graduated from the Hebei GEO University with a degree in marketing, because I thought computers were cool from an early age, so I chose programmers as my future employment direction in my third year of college. In the third year of college, I learned some front-end knowledge, and in the fourth year of college I learned some C ++ related knowledge. After graduating, I naturally found a job related to programming.&lt;/p&gt;
&lt;p&gt;In the first company, I was mainly engaged in web crawling. I was responsible for scraping various financial data including stock exchanges, performing data cleaning, and completing an announcement classification system during the period. I worked as a data development engineer in the second company, and solved development problems such as real-time data forwarding, reception, and storage. I worked as a back-end development engineer at a third company and built the entire edx-based online learning system.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>How To Use the STAR Interview Response Technique</title>
      <link>http://www.yezheng.pro/post/interview/star/</link>
      <pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/interview/star/</guid>
      
        <description>&lt;h2 id=&#34;what-is-the-star-interview-method&#34;&gt;What is the STAR interview method?&lt;/h2&gt;
&lt;p&gt;The STAR interview method is a technique you can use to prepare for behavioral and situational interview questions. STAR stands for: &lt;strong&gt;situation,&lt;/strong&gt; &lt;strong&gt;task,&lt;/strong&gt; &lt;strong&gt;action&lt;/strong&gt; and &lt;strong&gt;result&lt;/strong&gt;. This method will help you prepare clear and concise responses using real-life examples.&lt;/p&gt;
&lt;h2 id=&#34;how-does-the-star-method-work&#34;&gt;How does the STAR method work?&lt;/h2&gt;
&lt;p&gt;The STAR method helps you create an easy-to-follow story with a clear conflict and resolution. Here’s what each part of the technique means:&lt;/p&gt;
&lt;h3 id=&#34;situation&#34;&gt;Situation&lt;/h3&gt;
&lt;p&gt;Set the stage for the story by sharing context around the situation or challenge you faced. In most cases, it’s best to describe relevant work situations but depending on the amount of directly transferable experience you have, it might also be appropriate to discuss academic projects or volunteer work. It’s also imperative to talk about a specific instance rather than your general responsibilities.&lt;/p&gt;
&lt;p&gt;You should spend the least amount of time on this part of your answer as interviewers are more concerned with the actions you took and results you got. Share the right amount of relevant detail by identifying the two or three most important pieces of information necessary to give the interviewer enough context about the situation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;em&gt;“In my last role as lead designer, there was a point in time when my team was short-staffed and facing a significant backlog of work. The account managers were setting unrealistic deadlines, which was causing stress for my team and affecting morale.”&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;task&#34;&gt;Task&lt;/h3&gt;
&lt;p&gt;Describe your responsibility or role in the situation or challenge. In other words, discuss the goal or task set out for you. This section requires a minimal amount of time similar to the situation component. Again, consider just one or two points that best illustrate the task you needed to complete.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;em&gt;“As a team leader, it was my role not only to ensure my team met our deadlines but also to communicate bandwidth to other departments and keep my team motivated.”&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;action&#34;&gt;Action&lt;/h3&gt;
&lt;p&gt;Explain the specific actions you took to handle the situation or overcome the challenge. This part of your answer requires the most in depth description as this is what largely indicates your fitness for a role. Identify and discuss a few of the most impactful steps you took to find success.&lt;/p&gt;
&lt;p&gt;Often, workplace challenges are addressed by a team; however, it’s a common pitfall to use the word “we” to describe how you achieved your goals during an interview. In any case, it’s important to focus on what you did in the situation. It can be helpful to remember that the employer’s intention is to hire you for the role rather than your team, so you should use the word “I” to highlight your particular contributions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;em&gt;“I set up a formal creative request process including project timeline estimates to set better expectations. I scheduled weekly meetings with account managers to discuss my team’s bandwidth and share progress updates. I also kept my team informed of the new processes, so they could have some peace of mind knowing the issues were being addressed.”&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;result&#34;&gt;Result&lt;/h3&gt;
&lt;p&gt;What was the outcome you reached through your actions? This is also an important part of your response to focus on. You should spend only slightly less time discussing the results than your actions. Decide what the two to three most impressive results were and talk about these.&lt;/p&gt;
&lt;p&gt;Quantify your success or provide concrete examples of the effects of your efforts if possible. In addition, discuss what you learned, how you grew and why you’re a stronger employee because of the experience.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;em&gt;“By providing more transparency into my team’s processes and setting better expectations with the account managers, we were able to re-prioritize the design team’s to-do list and complete everything in our backlog. I took these learnings, continued to apply this structure and as a result, in the following quarter, we shortened our average project timeline by two days. I also learned just how important it is to communicate clearly across teams.”&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;how-to-use-the-star-method-to-prepare-for-an-interview&#34;&gt;How to use the STAR method to prepare for an interview&lt;/h2&gt;
&lt;p&gt;While you won’t know the interview questions ahead of time, most behavioral interviews will focus on various work-related challenges that demonstrate critical thinking and problem solving, and situations that showcase &lt;a href=&#34;https://www.indeed.com/career-advice/resumes-cover-letters/leadership-skills&#34;&gt;leadership skills&lt;/a&gt;, conflict resolution and performance under pressure. Here’s some additional background on behavioral questions and a few tips to help you leverage the STAR method when answering them.&lt;/p&gt;
&lt;h3 id=&#34;what-are-behavioral-interview-questions&#34;&gt;What are behavioral interview questions?&lt;/h3&gt;
&lt;p&gt;Interviewers ask behavioral interview questions to learn how you have behaved in previous work situations. In your answers, employers are looking for examples of your past actions that may be predictors of how you’ll act when you face these situations again. These questions are more open-ended than a “yes-or-no” question and usually ask you to share stories or examples from your previous jobs.&lt;/p&gt;
&lt;h3 id=&#34;star-interview-question-examples&#34;&gt;STAR interview question examples&lt;/h3&gt;
&lt;p&gt;Here are a few examples of common behavioral questions you might be asked during an interview:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Share an example of a time when you faced a difficult problem at work. How did you solve this problem?&lt;/li&gt;
&lt;li&gt;Have you ever had to make an unpopular decision? How did you handle it?&lt;/li&gt;
&lt;li&gt;Describe a time when you were under a lot of pressure at work. How did you react?&lt;/li&gt;
&lt;li&gt;Tell me about a mistake you’ve made. How did you handle it?&lt;/li&gt;
&lt;li&gt;Share an example of a time you had to make a difficult decision. What did you do?&lt;/li&gt;
&lt;li&gt;Explain a situation where you used data or logic to make a recommendation.&lt;/li&gt;
&lt;li&gt;Tell me about a time when you disagreed with your boss. How did you resolve it?&lt;/li&gt;
&lt;li&gt;Describe a time when you had to deliver bad news. How did you do it?&lt;/li&gt;
&lt;li&gt;Tell me about a time you worked with other departments to complete a project.&lt;/li&gt;
&lt;li&gt;Share an example of a time when you failed. What did you learn from the experience?&lt;/li&gt;
&lt;li&gt;Tell me about a time when you set and achieved a specific goal.&lt;/li&gt;
&lt;li&gt;Tell me about a time when you had to persuade someone to do something.&lt;/li&gt;
&lt;li&gt;Describe a time when you had a conflict with a colleague. How did you handle it?&lt;/li&gt;
&lt;li&gt;Have you ever had to motivate others? How did you do it?&lt;/li&gt;
&lt;li&gt;Tell me about the last time your workday ended before you were able to get everything done.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;steps-to-prepare&#34;&gt;Steps to prepare&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Review the job description and required skills&lt;/strong&gt; and consider what sorts of challenges might arise or what obstacles you may have to navigate in the position.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You should also review &lt;a href=&#34;https://www.indeed.com/career-advice/interviewing/most-common-behavioral-interview-questions-and-answers&#34;&gt;common behavioral interview questions&lt;/a&gt;&lt;/strong&gt; similar to the list above. While the phrasing of these questions may vary from interview to interview, the general intent of the question typically remains the same so it can be helpful to prepare your answers with that in mind. For example, the interviewer might ask about “a time you were under pressure,” or they might ask about “how you handle stress.” Either way, their goal is to understand how you deal with tense situations.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Write down the various situations&lt;/strong&gt; you’ve handled in your professional history that would display the sorts of strengths you’ll need to succeed in the role and that address some of the most common behavioral interview questions. Prepare each example using the STAR framework.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Practice talking through your answers&lt;/strong&gt; out loud to make sure each story is as concise and coherent as possible. This will also help you feel more confident and natural when delivering the answers in an interview.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you’re new to the workforce and don’t have a long professional history to draw from, consider examples from internships, volunteer work or group projects you completed for school. In some cases, employers may ask you to share a non-work-related example, so consider challenges or obstacles you’ve overcome in your personal life, too.&lt;/p&gt;
&lt;p&gt;No matter what stories you decide to share, make sure you define a situation, task, action and result, and showcase skills and abilities most relevant to the job.&lt;/p&gt;
&lt;h2 id=&#34;how-to-answer-a-question-using-the-star-method-with-examples&#34;&gt;How to answer a question using the STAR method (with examples)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;举例说明您在工作中遇到难题的时候。您是如何解决这个问题的？&lt;/strong&gt;
&lt;strong&gt;情况：&lt;/strong&gt; &lt;em&gt;“在舞会期间，我曾在一家百货公司担任零售经理。一位顾客在网上购买了一件衣服，并将其交付给商店。我的一位同事不小心将这件衣服放在地板上，另一位顾客立即在那买了这件衣服。&lt;/em&gt;
&lt;strong&gt;任务：&lt;/strong&gt; &lt;em&gt;我知道我需要为客户制定这项权利，以达到我自己的服务水平标准并维护公司的声誉。&lt;/em&gt;
&lt;strong&gt;行动：&lt;/strong&gt; &lt;em&gt;在致电客户让她知道错误之前，我在附近的另一家商店找到了这件衣服。我下令将它压在舞会当天清晨，并连同礼品卡送到她的家里，以感谢她的谅解。&lt;/em&gt;
&lt;strong&gt;结果：&lt;/strong&gt; &lt;em&gt;客户非常感激，她在几个评论网站上给我们写了五星级评论。”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述一下您在工作中承受很大压力的时间。您对此有何反应？&lt;/strong&gt;
&lt;strong&gt;情况：&lt;/strong&gt; &lt;em&gt;“在我之前担任客户经理的工作中，我的一位同事在签署了公司有史以来最大的客户后立即辞职。&lt;/em&gt;
&lt;strong&gt;任务：&lt;/strong&gt; &lt;em&gt;尽管我已经在管理全部帐户，但也为我分配了这个新客户。我知道赌注很高，如果我们输掉了这笔交易，那么我们就不会实现我们的季度目标。&lt;/em&gt;
&lt;strong&gt;行动：&lt;/strong&gt; &lt;em&gt;我首先采取了一些缓解压力的措施。然后，我仔细评估并调整了任务列表，以确保可以管理所有职责。因此，我能够使自己对客户完全可用，并且我还牺牲了一些晚上和周末来接听电话，直到项目交付为止。&lt;/em&gt;
&lt;strong&gt;结果：&lt;/strong&gt; &lt;em&gt;客户对我的奉献精神印象深刻，他们立即签署了一份年度合同，使我们公司获利500万美元。”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;告诉我您犯的一个错误。你是怎么处理的呢？&lt;/strong&gt;
&lt;strong&gt;情况：&lt;/strong&gt; &lt;em&gt;“我当时是一家活动公司的实习生，负责订购由知名客户主持的私人活动的鲜花布置。不幸的是，我把另一个事件的信息混在一起，把鲜花送到了镇另一端的错误地点。&lt;/em&gt;
&lt;strong&gt;任务：&lt;/strong&gt; &lt;em&gt;我非常认真地对待这一点，并且知道我需要在紧迫的期限内迅速找到解决方案。&lt;/em&gt;
&lt;strong&gt;行动：&lt;/strong&gt; &lt;em&gt;在考虑了几种解决问题的方法之后。我向老板承认了自己的错误，向他们通报了我的计划以及为什么我认为这是最好的选择。我在午餐前休息了一段时间，驱车前往另一个地点，在活动开始前一个小时将鲜花采摘并送到了适当的地点。&lt;/em&gt;
&lt;strong&gt;结果：&lt;/strong&gt; &lt;em&gt;客户从来不知道我的想法，我的老板非常感激。”&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>SWOT Analysis Guide (With Examples)</title>
      <link>http://www.yezheng.pro/post/any-path/swot/</link>
      <pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/any-path/swot/</guid>
      
        <description>&lt;p&gt;A SWOT analysis is a way to evaluate strengths, weaknesses, opportunities and threats. You might perform this analysis for a product, team, organization, leadership or other entities. SWOT analyses are used in many business environments to gain a better understanding of how to plan for the future.&lt;/p&gt;
&lt;p&gt;In this article, we discuss what a SWOT analysis is in further detail, why they are used and how to perform a SWOT analysis. Additionally, we will discuss ways you can use your knowledge of SWOT analyses during the hiring process when you are looking for new jobs.&lt;/p&gt;
&lt;h2 id=&#34;what-is-a-swot-analysis&#34;&gt;What is a SWOT analysis?&lt;/h2&gt;
&lt;p&gt;A SWOT analysis is a tool you can use both personally and at work to evaluate and make decisions about a particular subject. In this analysis, you will investigate both internal and external factors. Internal factors are positive (strengths) or negative (weaknesses) factors that exist within your organization and are able to be changed or affected in some way. External factors are positive (opportunities) or negative (threats) factors that exist outside of the subject you are evaluating and cannot necessarily be changed or affected by you or your organization in any way.&lt;/p&gt;
&lt;p&gt;Let’s take a closer look at each of these areas:&lt;/p&gt;
&lt;h3 id=&#34;strengths&#34;&gt;Strengths&lt;/h3&gt;
&lt;p&gt;Your strengths analysis should record internal, positive attributes of the organization, individual, product or other entity you are evaluating. Some questions you might ask to understand strengths are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What are your positive qualities?&lt;/li&gt;
&lt;li&gt;What achievements have you made?&lt;/li&gt;
&lt;li&gt;What helps you accomplish goals?&lt;/li&gt;
&lt;li&gt;What resources do you have?&lt;/li&gt;
&lt;li&gt;What are your specialties?&lt;/li&gt;
&lt;li&gt;What sets you apart from others?&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;weaknesses&#34;&gt;Weaknesses&lt;/h3&gt;
&lt;p&gt;Your weaknesses analysis will capture all internal areas of improvement or vulnerabilities that exist within the subject you are evaluating. Some questions you might ask to understand weaknesses are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Internally, what makes it difficult to achieve goals?&lt;/li&gt;
&lt;li&gt;What are your areas for improvement?&lt;/li&gt;
&lt;li&gt;What are you lacking (resources, technology, people, etc.)?&lt;/li&gt;
&lt;li&gt;What do you need to tackle long-term goals?&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;opportunities&#34;&gt;Opportunities&lt;/h3&gt;
&lt;p&gt;Your opportunities section should list all external opportunities relevant to your subject. Some questions you might ask to understand opportunities are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What products, services or information is popular with your audience?&lt;/li&gt;
&lt;li&gt;Are there external resources you can use to achieve goals?&lt;/li&gt;
&lt;li&gt;Can you benefit from any current economic or market trends?&lt;/li&gt;
&lt;li&gt;What technology will be popular in the near future?&lt;/li&gt;
&lt;li&gt;How do stakeholders view your brand, product or service?&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;threats&#34;&gt;Threats&lt;/h3&gt;
&lt;p&gt;Your threats section should include all external threats that could have a negative effect on your subject. Some questions you might ask to understand threats are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Is market health expected to be bad or turbulent?&lt;/li&gt;
&lt;li&gt;Is your brand, product or service no longer needed?&lt;/li&gt;
&lt;li&gt;Do competitors have a certain edge over you?&lt;/li&gt;
&lt;li&gt;How does your audience, industry or market view your company?&lt;/li&gt;
&lt;li&gt;What could put your business at risk?&lt;/li&gt;
&lt;li&gt;Are there potential new competitors on the horizon?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;why-are-swot-analyses-used&#34;&gt;Why are SWOT analyses used?&lt;/h2&gt;
&lt;p&gt;SWOT analyses are used to gain more information about all aspects of an issue, team, individual or other entity. These evaluations are used in many businesses in nearly every industry, as well as personally for individuals to assess their progress towards certain goals. Many people use SWOT analysis before they set team or organization goals to ensure they are working towards appropriate milestones.&lt;/p&gt;
&lt;p&gt;These types of evaluations can be used in a variety of situations. Here are several examples for when a SWOT analysis would be beneficial:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When deciding on a new hire&lt;/li&gt;
&lt;li&gt;When designing a new product&lt;/li&gt;
&lt;li&gt;When reviewing performance of a team or group&lt;/li&gt;
&lt;li&gt;When reviewing performance of an individual&lt;/li&gt;
&lt;li&gt;When evaluating an audience or market&lt;/li&gt;
&lt;li&gt;When analyzing a product for improvement&lt;/li&gt;
&lt;li&gt;When analyzing a process for inefficiencies&lt;/li&gt;
&lt;li&gt;When deciding where or how to focus resources&lt;/li&gt;
&lt;li&gt;When determining your personal effectiveness in a role&lt;/li&gt;
&lt;li&gt;When determining your strengths for a new role&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;how-to-do-a-swot-analysis&#34;&gt;How to do a SWOT analysis&lt;/h2&gt;
&lt;p&gt;While there are several ways you might perform a SWOT analysis, here are several essential steps you can take:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Clearly define the subject you are analyzing.&lt;/strong&gt; Whether it is progress towards a specific goal, performance of a team, or a particular question about a product or market, clearly define what subject you want to analyze. This will help you gain clearer insights which will result in a better overall evaluation. Here are some examples subjects for analysis:
**January performance of inside sales team*
*&lt;em&gt;Personal readiness to acquire an executive assistant job&lt;/em&gt;
* &lt;em&gt;Evaluating social media marketing strategy&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Draw the SWOT framework.&lt;/strong&gt; To perform the SWOT analysis, create a large box divided into four squares. In the top-right square, you will record strengths. In the top-left square you will record weaknesses. In the bottom-right square, you will record opportunities. In the bottom-left square, you will record threats.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you are doing a personal SWOT, feel free to draw it on a notepad or work in an online doc or spreadsheet. If you are doing a SWOT with a team, it might be helpful to draw the frame work on a whiteboard or project the SWOT so everyone is able to see and contribute. You can also forego the framework if you feel it would be easier to simply write them down in order on a document.&lt;/p&gt;
&lt;p&gt;\3. &lt;strong&gt;Work through each square.&lt;/strong&gt; Take time to work through each square considering internal strengths, internal weaknesses, external opportunities and external threats. If you are doing this exercise with a team, it can be helpful to have everyone participate. This will bring various points of view to help provide a more holistic understanding of the SWOT.&lt;/p&gt;
&lt;p&gt;\4. &lt;strong&gt;Draw conclusions and key takeaways.&lt;/strong&gt; After completing the square, take time to understand how the recorded information helps inform your analysis. For example, if you are performing a SWOT on a job candidate, does it appear that they are a good fit? Do their positive qualities help fill a major skill set gap at the company? Are the weaknesses or threats able to be overcome?&lt;/p&gt;
&lt;p&gt;After completing the SWOT, it can be helpful to revisit after a certain amount of time. For example, if your SWOT revealed certain weaknesses you are working to improve for a promotion, you might revisit your SWOT after working on those areas. This can help you gain a better understanding of how your work has changed after working towards certain goals.&lt;/p&gt;
&lt;h2 id=&#34;swot-analysis-example&#34;&gt;SWOT analysis example&lt;/h2&gt;
&lt;p&gt;Here is an example of a completed SWOT analysis using one of our examples above. While this example contains only three bullet points per section, you can include as much or as little information as is helpful:&lt;/p&gt;
&lt;h3 id=&#34;swot-analysis-social-media-marketing-strategy&#34;&gt;SWOT Analysis: Social Media Marketing Strategy&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Strengths:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;New procurement process speeds up output&lt;/li&gt;
&lt;li&gt;Team dynamic makes collaboration easy&lt;/li&gt;
&lt;li&gt;Diverse strengths allows many areas of expertise&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Weaknesses:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Many people with similar or overlapping responsibilities&lt;/li&gt;
&lt;li&gt;Many different team goals&lt;/li&gt;
&lt;li&gt;Difficult to get market research&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Opportunities:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Platform’s real-time analysis allows for fast strategy changes&lt;/li&gt;
&lt;li&gt;Audience interested in video content&lt;/li&gt;
&lt;li&gt;Market trends show certain platforms more popular than others&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Threats:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Main competitor has better brand awareness&lt;/li&gt;
&lt;li&gt;Other, similar products being introduced to the market&lt;/li&gt;
&lt;li&gt;Audience attention span increasingly short&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Overall, SWOT analyses can be helpful to assess a certain subject. You might be looking to simply gain a better understanding of something, or you can also create action items as a result of your SWOT. For example, you might see that there are some internal weaknesses that can easily be fixed. From there, you can create individual or team goals to overcome those weaknesses.&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.indeed.com/career-advice/career-development/swot-analysis-guide?from=careeradvice-US&#34;&gt;SWOT Analysis Guide (With Examples)&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>business-analyst</title>
      <link>http://www.yezheng.pro/post/interview/business-analyst/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/interview/business-analyst/</guid>
      
        <description>&lt;h3 id=&#34;1-how-would-you-work-with-a-difficult-stakeholder困难的利益相关者&#34;&gt;1. How would you work with a difficult stakeholder（困难的利益相关者）?&lt;/h3&gt;
&lt;p&gt;As a business analyst, you will likely deal with many different personalities occupying a variety of positions（与担任各种职位的许多不同人物打交道）. Situational questions like this one measure your &lt;strong&gt;problem-solving skills, communication skills and ability to resolve difficult situations&lt;/strong&gt;. This question assesses whether you can successfully navigate interactions with many different stakeholders.&lt;/p&gt;
&lt;p&gt;Provide a direct answer and explain a related challenge you faced in past work. You can use the &lt;a href=&#34;https://www.indeed.com/career-advice/interviewing/how-to-use-the-star-interview-response-technique&#34;&gt;STAR interview response framework&lt;/a&gt; to structure your answer by addressing the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Situation:&lt;/strong&gt; Briefly explain the issue you were dealing with in a positive, constructive way.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Task:&lt;/strong&gt; Explain your role in the situation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Action:&lt;/strong&gt; Explain what you did to resolve or address the situation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Result:&lt;/strong&gt; Explain your learnings and how your actions resulted in a positive impact for the business.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;During your discussion with the interviewer, you also gain insight into the challenges you might face in the new role, which can be a helpful context to understand before accepting an offer.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我发现同理心，沟通和行动可以解决大部分问题。例如，有一次业务owner是很生气的，他提出了很多需求，因为版本容量和开发人力的缘故，没有纳入版本计划，他不知道什么时候能够上线。我的任务是有义务澄清需求版本的。我决定立即与项目交付经理确定版本计划，并在后续需求接纳后及时反馈版本。在那之后，需求的版本就清晰了。&lt;/p&gt;
&lt;p&gt;直播课程创建两次，业务的困扰&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-describe-a-time-when-you-had-to-advise-a-client-toward-a-different-course-of-action&#34;&gt;2. Describe a time when you had to advise a client toward a different course of action.&lt;/h3&gt;
&lt;p&gt;As a business analyst, it is your job to make recommendations both in the interest of the client and the organization. Your perspective should be based on the collected data as you interpret it. Should a client pursue a certain course of action you do not feel is in their best interest, you may be required to present the data in new and interesting ways to convince them otherwise.&lt;/p&gt;
&lt;p&gt;In your answer, you should explain the ways you can apply your problem-solving skills to navigate potentially difficult situations with clients and other important stakeholders.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;直播发放积分，直播课程发放积分，积分交互的方式，积分发放的条件随堂测试完成百分比。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3-what-is-the-most-important-aspect-of-analytical-reporting&#34;&gt;3. What is the most important aspect of analytical reporting?&lt;/h3&gt;
&lt;p&gt;Analytical reporting is a type of business reporting that offers information, data analysis and recommendations. The recommendations are what set &lt;strong&gt;this type of reporting apart from informational reporting&lt;/strong&gt;. Analytical reporting allows people to use data to make decisions.&lt;/p&gt;
&lt;p&gt;As a business analyst, you &lt;strong&gt;should understand the importance and limitations of analytical reporting.&lt;/strong&gt; In your answer, explain the measurable impact you have made with analytical reporting in previous roles. This helps employers understand the value you have to offer at their organization. Formulate your response to demonstrate your critical thinking and analytical skills, showing how you can create recommendations from data sources.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然数据本身无法解决问题，但是当进行上下文分析时，它可以使您做出正确的业务决策。即使某个决策不能产生您所期望的结果，数据也可以使您从这些结果中学习并继续进行改进。分析报告的最重要方面是解决问题和根据事实做出决策的能力。试图根据无根据的猜测或假设做出决策可能会出现问题，分析报告提供了切实的信息，可用来制定战略和方向。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;4-describe-your-familiarity-with-sql-queries&#34;&gt;4. Describe your familiarity with SQL queries.&lt;/h3&gt;
&lt;p&gt;SQL is the standard language for relational database management systems. Since SQL allows you to work with structured data where there are relations between different variables, SQL queries are commonly used in the business analyst role.&lt;/p&gt;
&lt;p&gt;Though it is not necessary for a business analyst to demonstrate advanced technical skills, certain skills are incredibly valuable. You may be asked to explain the elements of a SQL Statement during an interview so employers can assess your related technical skills and advanced analysis skills. In addition to providing definitions that demonstrate your knowledge, you might also consider providing an example of how you have used SQL to make an impact in your previous BA work.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are four parts to an SQL statement. The &lt;strong&gt;DDL&lt;/strong&gt;, or the Data Definition Language, is used for defining data structure. The &lt;strong&gt;DML&lt;/strong&gt;, or Data Manipulation Language, is used for inserting, deleting and modifying data. The &lt;strong&gt;DCL&lt;/strong&gt;, or Data Control Language, is used to control access to data stored in the database. Finally, the &lt;strong&gt;TCL&lt;/strong&gt;, or Transactional Control Language, is used to organize data adjusted by the DML. I have used SQL statements to determine which of my client&amp;rsquo;s customers are purchasing which products, which has helped them make important decisions about future product lines. This work has made them a repeat customer three years running.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;5-what-tools-do-you-consider-the-most-important-for-a-business-analyst-to-do-their-job-well&#34;&gt;5. What tools do you consider the most important for a business analyst to do their job well?&lt;/h3&gt;
&lt;p&gt;This question allows an interviewer to test your basic technical skills and familiarity with standard business analytics applications as well as those they may use at the company. BAs commonly use tools like the Microsoft Office Suite, though you may have used other tools or programs in your work. Tailor your answer to highlight your own unique experience and skills.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我通常使用诸如Word，Excel，PowerPoint，MS Visio和Rational工具之类的工具。我还具有高级SQL技巧-当我需要分析诸如客户购买之类的商品时，使用SQL会很有帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;6-describe-how-you-typically-approach-a-project&#34;&gt;6. Describe how you typically approach a project.&lt;/h3&gt;
&lt;p&gt;Understanding a candidate&amp;rsquo;s workflow can help employers gauge their teamwork, project management and organizational skills. To answer, explain general phases you work through with standard deliverables you typically produce instead of listing specific processes or tasks the interviewer may not be familiar with. Focus on your actual experience to describe your skills and how you use them.&lt;/p&gt;
&lt;p&gt;For example, if you worked on the planning stages of a project, you could mention deliverables such as a communication plan (沟通计划), a work breakdown structure (WBS) (工作分解结构), a requirements management plan (需求管理计划) and a business analysis approach (业务分析方法), including whether it is plan-driven or change-driven.&lt;/p&gt;
&lt;p&gt;Speak about how you have customized specific approaches to the needs of a given project. You can follow up by asking about the organization&amp;rsquo;s projects and processes to give yourself a better sense of how you would fit in and to show the interviewer that you are invested in the way they work.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我首先倾听客户的需求，关注客户明确表达的项目目标。然后，我对数据进行了更深入的研究，以找出如何指导他们走向成功或如何改变客户的方式我们正在考虑以更高的生产率前进的目标，当然，每个项目和每个客户都需要一些新的东西，因此，我始终确保考虑到特定的情况，而不是自动采用“一刀切”的解决方案，IT方案是可灵活配置的，不该绑定死的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;7-name-two-diagrams-you-use-as-a-business-analyst-and-describe-how-they-impact-your-work&#34;&gt;7. Name two diagrams you use as a business analyst, and describe how they impact your work.&lt;/h3&gt;
&lt;p&gt;The interviewer may ask this question to ensure that you are familiar with &lt;strong&gt;standard BA documents&lt;/strong&gt; and how to apply them to a client&amp;rsquo;s case. Even if they do not directly ask about your past experience here, providing examples can validate your ability to bring value to the employer.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我更喜欢使用的两个图是活动图和用例图。活动图显示了各个部门之间发生的各种活动。我使用活动图来显示谁与系统进行交互以及他们通过该系统实现的主要目标。当我需要可视化给定系统的功能需求时，我发现用例图非常有用，这样我就可以在设计和确定开发优先级时做出明智的选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;8-what-questions-do-you-have&#34;&gt;8. What questions do you have?&lt;/h3&gt;
&lt;p&gt;Asking intelligent questions at the conclusion of your interview shows that you know how to ask the right questions to get the right information—a necessary skill for business analysts. This is your chance to have a thoughtful conversation with your prospective employer or colleague. Make sure to use active listening skills during your interview to inform your questions. The person interviewing you should feel that you are invested and engaged throughout the interview.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我经常与希望扩展业务的客户一起工作，并且擅长指导他们做出明智的决定，从而扩大他们已有的优势。典型的客户对您来说是什么样子？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;9-what-is-a-swot-analysis&#34;&gt;9. What is a SWOT analysis?&lt;/h3&gt;
&lt;p&gt;A SWOT analysis is a way to evaluate &lt;strong&gt;strengths&lt;/strong&gt;, &lt;strong&gt;weaknesses&lt;/strong&gt;, &lt;strong&gt;opportunities&lt;/strong&gt; and &lt;strong&gt;threats&lt;/strong&gt;. You might perform this analysis for a &lt;strong&gt;product&lt;/strong&gt;, &lt;strong&gt;team&lt;/strong&gt;, &lt;strong&gt;organization&lt;/strong&gt;, &lt;strong&gt;leadership&lt;/strong&gt; or &lt;strong&gt;other entities&lt;/strong&gt;. SWOT analyses are used in many business environments to gain a better understanding of how to plan for the future.&lt;/p&gt;
&lt;h3 id=&#34;10-what-is-the-role-of-a-business-analyst-in-an-organization&#34;&gt;10. What is the role of a business analyst in an organization?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;业务分析师是组织中不同域的不同利益相关者之间的联系或链接来回答此问题。业务分析师应具有实现业务目标并平衡各个利益相关者需求的能力。&lt;/p&gt;
&lt;p&gt;业务分析师充当组织中不同利益相关者之间的桥梁。他与组织的不同利益相关者联系，以澄清和最终确定需求，帮助项目团队进行项目规划，设计并最终验证开发的组件。他是具有足够领域知识的人，可以在属于不同领域的利益相关者之间对业务需求进行分类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;11-how-do-you-see-yourself-fit-for-the-role-of-business-analyst-in-our-company&#34;&gt;11. How do you see yourself fit for the role of business analyst in our company?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;历史工作经验和编程技能优势&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12-what-according-to-you-are-the-core-competencies-of-a-business-analyst&#34;&gt;12. What, according to you, are the core competencies of a Business Analyst?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;出色的沟通和谈判技巧&lt;/p&gt;
&lt;p&gt;分析思维，解决问题和制定决策也是至关重要的属性&lt;/p&gt;
&lt;p&gt;业务分析师应具有行业知识，业务流程管理技能以及技术能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;13-do-you-have-any-technical-skills-can-you-list-your-database-skills-or-business-intelligence-skills&#34;&gt;13. Do you have any technical skills? Can you list your database skills or business intelligence skills?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;relational databases and SQL&lt;/p&gt;
&lt;p&gt;the specific Business Intelligence tools&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;14-what-is-invest&#34;&gt;14. What is INVEST?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Independent, Negotiable, Valuable, Estimable&lt;/p&gt;
&lt;p&gt;独立的、可协商的、有价值的、可评价的&lt;/p&gt;
&lt;p&gt;它可以协助项目经理和技术团队提供优质的产品/服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;15-are-you-aware-of-the-different-techniques-like-moscow-and-swot&#34;&gt;15. Are you aware of the different techniques like MoSCoW and SWOT?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;业务分析师应了解用于创建和实施战略的流程，以识别组织的需求并提供最佳结果。&lt;/p&gt;
&lt;p&gt;有了这个问题，招聘人员想知道您是否理解这些术语并将其纳入您的工作政策中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MoSCoW&lt;/strong&gt;代表“必须或应该，可能或将会”。业务分析师应通过将每个需求与其他需求进行比较以实现框架需求的优先级，从而实施此过程。例如，此要求是必须具备还是应该具有？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SWOT&lt;/strong&gt;或“优势，劣势，机会和威胁分析”是组织中用于适当资源分配的最广泛使用的技术。业务分析师应该能够确定任何公司框架的优点和缺点，并将其转化为机遇和威胁。&lt;/p&gt;
&lt;p&gt;**专家提示：**还有许多其他&lt;a href=&#34;https://www.simplilearn.com/business-analysis-techniques-article&#34;&gt;业务技术，&lt;/a&gt;例如MOST和PESTLE，您可以了解有关它们的更多信息，以便为业务分析师面试做准备。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;16-what-do-you-mean-by-project-deliverables可交付成果&#34;&gt;16. What do you mean by project deliverables(可交付成果)?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;项目完成后交付给最终客户的可衡量的服务和产品的集合。版本交付范围&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;17-how-do-you-keep-yourself-updated-about-the-latest-business-trends-and-knowledge&#34;&gt;17. How do you keep yourself updated about the latest business trends and knowledge?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;参加活动和会议，与其他团队的BA以及SE交流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;18-what-are-the-various-stages-of-a-business-project&#34;&gt;18. What are the various stages of a business project?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;任何业务或IT项目的主要阶段都是启动，计划，执行，监控和闭环。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;19-explain-uml-and-its-uses&#34;&gt;19. Explain UML and its uses?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;UML或统一建模语言是一种通用的，可开发的建模语言，它提供了构想系统的标准方法。它用于合理化系统行为，以检测和消除错误/瓶颈。&lt;/p&gt;
&lt;p&gt;该建模标准主要用于软件开发。但是，它也用于描述工作角色，组织职能和业务流程。BA作为UML的一部分使用的一些重要图是类图，状态图和用例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;20-can-you-explain-srs-and-its-key-elements及其要素&#34;&gt;20. Can you explain SRS and its key elements(及其要素)?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;SRS代表系统或软件需求规范。它是描述软件应用程序或系统功能的一组文档。&lt;/p&gt;
&lt;p&gt;SRS的关键要素是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;工作范围&lt;/li&gt;
&lt;li&gt;功能要求&lt;/li&gt;
&lt;li&gt;非功能要求&lt;/li&gt;
&lt;li&gt;数据模型&lt;/li&gt;
&lt;li&gt;依赖关系&lt;/li&gt;
&lt;li&gt;假设条件&lt;/li&gt;
&lt;li&gt;约束条件&lt;/li&gt;
&lt;li&gt;验收标准&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;21-what-is-brd-how-is-it-different-from-srs&#34;&gt;21. What is BRD? How is it different from SRS?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;BRD为的缩写Business Requirement Document。它是组织与客户之间针对特定产品开发的正式合同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BRD是软件的功能规范，而SRS都是BA与客户直接交互后创建的&lt;/li&gt;
&lt;li&gt;BRD是由业务分析师与客户直接互动后创建的，而SRS是根据技术专长和需求设计的。&lt;/li&gt;
&lt;li&gt;SRS来自BRD&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;BRD&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;SRS&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;它是软件的高级功能规范。&lt;/td&gt;
&lt;td&gt;它是软件的高级功能和技术规范&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;这是描述客户要求的正式文件（书面，口头）&lt;/td&gt;
&lt;td&gt;它描述了要开发的软件的功能和非功能要求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在与客户直接互动之后，业务分析师会创建它&lt;/td&gt;
&lt;td&gt;系统架构师可以根据需要的技术知识来创建它。尽管有时Bas也可以创建它。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;它是根据需求和客户交互得出的&lt;/td&gt;
&lt;td&gt;它来自BRS&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;22-how-can-you-say-that-a-requirement-is-good-or-perfect&#34;&gt;22. How can you say that a requirement is good or perfect?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;需求描述是具体的&lt;/p&gt;
&lt;p&gt;所有参数可测量的&lt;/p&gt;
&lt;p&gt;必须资源都是可实现&lt;/p&gt;
&lt;p&gt;我们可以使用SMART规则来衡量需求的质量。根据此规则，良好的质量要求应该是：**特定的：**要求应该是特定的并且可以适当地记录在案。**可测量的：&lt;strong&gt;不同的参数可以衡量要求的成功标准可以达到的&lt;/strong&gt;：&lt;strong&gt;要求应该在给定资源的范围内是可行的&lt;/strong&gt;相关：&lt;strong&gt;需求必须与项目的业务案例&lt;/strong&gt;相符及时：**需求应在项目生命周期的早期传达&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;23-what-is-the-purpose-of-the-requirement-traceability-matrix&#34;&gt;23. What is the purpose of the Requirement Traceability Matrix?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;它记录了客户给出的所有需求，并确保满足所有必须的功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;24-what-is-business-modelling&#34;&gt;24. What is business modelling?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;业务建模是用于识别运营业务的价值主张的分步方法。&lt;/p&gt;
&lt;p&gt;为组织制定战略计划的业务建模的关键属性是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;视觉&lt;/li&gt;
&lt;li&gt;使命&lt;/li&gt;
&lt;li&gt;目标&lt;/li&gt;
&lt;li&gt;应对策略&lt;/li&gt;
&lt;li&gt;行动计划&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;25-what-is-the-project-life-cycle-which-models-will-you-employ-and-why&#34;&gt;25. What is the project life cycle? Which models will you employ, and why?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;整个项目生命周期分割成项目管理的阶段&lt;/p&gt;
&lt;p&gt;敏捷模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;26what-do-you-understand-by-gap-analysis差距分析-and-what-are-the-types-of-gaps-that-can-occur-during-an-analysis&#34;&gt;26.What do you understand by Gap Analysis(差距分析), and what are the types of gaps that can occur during an analysis?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;差距分析是指对现有系统和目标系统的功能之间的差异进行分析。差距意味着完成建议结果所需的更改。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;利润差距&lt;/strong&gt;是公司的实际利润与估计利润之间的差额。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;人力差距&lt;/strong&gt;是公司实际和所需劳动力之间的转换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绩效差距&lt;/strong&gt;是预期绩效与实际绩效之间的差异。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;市场差距&lt;/strong&gt;是估计的实际销售额之间的差异。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;27-what-strategies-will-you-follow-to-design-a-use-case&#34;&gt;27. What strategies will you follow to design a use case?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;用例应简明扼要，定义明确并正确记录。&lt;/p&gt;
&lt;p&gt;设计用例的策略或方法是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;strong&gt;第一个阶段&lt;/strong&gt;是用户的身份创建与每个角色相关联的目标，每个用户类别和识别角色的配置。&lt;/li&gt;
&lt;li&gt;所述&lt;strong&gt;第二阶段&lt;/strong&gt;涉及通过捕捉功能和非功能性要求的结构和用例创建。包括用例图和用户界面详细信息。&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;最后阶段&lt;/strong&gt;的审查和验证用例。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;28-explain-your-typical-work-tactic-策略-for-a-project&#34;&gt;28. Explain your typical work tactic (策略) for a project?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;标准交付品遵循的一般步骤&lt;/p&gt;
&lt;p&gt;首先，您必须阐明自己的角色，并确定项目干系人的观点。您应该定义主要目标，并协调利益相关者之间的期望冲突。
创建一个工作计划，列出步骤，时间表和可交付成果。
定义可行且简洁的要求。
确保技术实施，因为许多解决方案都需要IT团队的支持。
创建文档并培训最终用户以实施该解决方案。
最后，评估项目的价值。它有效吗，或者需要任何后续措施？&lt;/p&gt;
&lt;p&gt;您应该专注于&lt;strong&gt;描述自己的技能并解释您使用的定制策略的经验&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;29-what-documents-are-needed-by-a-business-analyst-which-documents-have-you-prepared-in-your-previous-works&#34;&gt;29. What documents are needed by a business analyst? Which documents have you prepared in your previous works?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;项目生命周期使用许多文档，并且取决于业务分析师的使用过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发起文件&lt;/li&gt;
&lt;li&gt;系统要求规格文档&lt;/li&gt;
&lt;li&gt;业务需求文件&lt;/li&gt;
&lt;li&gt;功能需求文件&lt;/li&gt;
&lt;li&gt;需求可追溯性矩阵&lt;/li&gt;
&lt;li&gt;用例规格文档&lt;/li&gt;
&lt;li&gt;变更申请文件&lt;/li&gt;
&lt;li&gt;差距分析文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了这个问题，招聘经理想了解您是否使用过几种类型的文档，并评估您提供业务和技术规格的能力。&lt;/p&gt;
&lt;p&gt;**专家提示：**确保仅使用您熟悉的文档并进行详细说明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目愿景文件&lt;/li&gt;
&lt;li&gt;用例&lt;/li&gt;
&lt;li&gt;需求管理计划&lt;/li&gt;
&lt;li&gt;用户故事&lt;/li&gt;
&lt;li&gt;需求追踪矩阵（RTM）&lt;/li&gt;
&lt;li&gt;业务需求文件&lt;/li&gt;
&lt;li&gt;系统需求规范（SRS）/系统需求文档（SRD）&lt;/li&gt;
&lt;li&gt;测试用例&lt;/li&gt;
&lt;li&gt;功能需求说明书（FRS）/功能说明书（FSD）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;30-what-is-the-requirement-elicitation需求启发-have-you-ever-participated-in-these-elicitation-meetings&#34;&gt;30. What is the requirement elicitation(需求启发)? Have you ever participated in these elicitation meetings?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;它是一种从利益相关者和用户那里收集信息的技术。它涉及直接与客户或用户协作的方法或策略。&lt;/p&gt;
&lt;p&gt;一些需求启发技术是-&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件分析&lt;/li&gt;
&lt;li&gt;面试&lt;/li&gt;
&lt;li&gt;原型制作&lt;/li&gt;
&lt;li&gt;集思广益&lt;/li&gt;
&lt;li&gt;讲习班和观察&lt;/li&gt;
&lt;li&gt;调查/问卷&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;您可以通过解释如何使用这些技术以及它们如何影响您的项目来回答问题的第二部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比如用户反馈的问题单，平台缺陷管理，运营部分反馈的问题，用户体验，集思广益&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过进行会议，问卷调查，访谈，集思广益的原型设计，会议等从利益相关者，用户和客户收集需求的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;31-what-are-the-various-kinds-of-diagrams-you-use-as-a-business-analyst-how-do-they-impact-the-work&#34;&gt;31. What are the various kinds of diagrams you use as a business analyst? How do they impact the work?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;业务分析师最常用的图表模型是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**流程图–**这些是系统完整流程的示意图。它们使所有利益相关者（无论是技术人员还是技术人员）都易于理解操作。&lt;/li&gt;
&lt;li&gt;**活动图–**这些图说明了各种活动及其在各个部门之间的流程。&lt;/li&gt;
&lt;li&gt;**用例图–**这些图使用系统/项目需要执行的一组动作，功能和服务来对系统的功能进行建模。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些图有利于可视化系统的功能需求并最终确定开发优先级。他们还确定了可能影响项目的任何外部/内部因素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顺序图-&lt;/strong&gt; 这些图说明了不同对象之间的交互以及它们之间消息流的时间顺序。&lt;/li&gt;
&lt;li&gt;**协作图-**这些也称为交互图或通讯图。它们说明了统一建模语言中软件对象之间的关系和交互作用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;许多图可用于业务分析，并且可以说您遵循了一种更一致的方法，即合并不同的模型以产生结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;32-what-is-the-exception-and-alternate-flow-in-a-use-case-diagram用例图-how-are-they-different-from-basic-flow&#34;&gt;32. What is the exception and alternate flow in a use-case diagram(用例图)? How are they different from basic flow?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基本流程&lt;/strong&gt;是公司要求的活动操作的表示。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;替代流程&lt;/strong&gt;是除了基本流程以外的动作或活动的表示。它导致使用不同的步骤来实现用例的目标。用例的替代解决方案或活动，如果系统发生任何故障，应遵循该替代方案或活动。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常流&lt;/strong&gt;表示发生错误时执行的操作。这导致无法实现用例的目标。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;33-what-are-personas-and-how-they-are-useful-in-user-centred-design-methodology&#34;&gt;33. What are personas, and how they are useful in user-centred design methodology?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;创建Personas来替代真实用户理解他们在不同场景下的行为模式。&lt;/p&gt;
&lt;p&gt;在以用户为中心的设计方法中，开发了一个系统，同时牢记最终用户的观点。&lt;/p&gt;
&lt;p&gt;Personas帮助创建这样的系统。&lt;/p&gt;
&lt;p&gt;Personas代表以用户为中心的设计方法。为了使应用程序能够基于人口统计数据执行，业务分析人员将虚构Personas概念化，并在设计过程中基于其可能的人口统计特定行为场景进行创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;34-how-can-you-manage-the-post-implementation-and-pre-implementation-problems-of-a-project&#34;&gt;34. How can you manage the post-implementation and pre-implementation problems of a project?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;项目实施之前声明其存在的问题称为实施前问题。项目实施后出现的困难称为实施后问题，而大多数问题都属于此类。&lt;/p&gt;
&lt;p&gt;之后，您可以解释业务分析师无法克服所有这些问题，但是可以在最短的时间内将它们限制在最大范围内。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;35-during-the-development-of-a-system-how-do-you-manage-frequently-changing-customers-requirements&#34;&gt;35. During the development of a system, how do you manage frequently changing customers&#39; requirements?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;业务分析师的首要任务是起草一份文件，阐明所允许的更改数量，并且在特定时间点之后，将不接受任何修改。让该文件由用户签名至关重要。&lt;/p&gt;
&lt;p&gt;如果接受了所需的更改，请确保记下所有更改，并找出它们对项目的总体影响。计算此更改所需的时间表，成本和资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;36-what-is-use-case&#34;&gt;36. What is Use case?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;用例是系统的图形表示，它描述用户如何使用系统来实现目标。它是软件工程和软件建模技术不可或缺的一部分，该技术定义了目标功能以及用户可能遇到的任何错误的解决方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;37-what-is-requirement-prioritization-what-are-the-different-techniques-used-for-it&#34;&gt;37. What is requirement prioritization? What are the different techniques used for it?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;需求优先级排序是根据业务紧急程度将需求分配到不同阶段，进度，成本等的过程。&lt;/p&gt;
&lt;p&gt;有多种技术可用于需求优先级划分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MoSCoW技术&lt;/li&gt;
&lt;li&gt;需求排序方法&lt;/li&gt;
&lt;li&gt;100美元的方法&lt;/li&gt;
&lt;li&gt;卡诺分析及更多&lt;/li&gt;
&lt;li&gt;五个原因&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;38-what-are-non-functional-requirements-and-how-do-you-capture-them&#34;&gt;38. What are non-functional requirements and how do you capture them?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;非功能性需求代表性能水平特征，例如它可以响应的速度，正在开发的应用程序（AUD）的用户界面，安全性，平滑度等。SRS文档的指定部分中未包含任何功能要求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;39-what-are-the-skills-that-a-business-analyst-must-possess&#34;&gt;39. What are the skills that a business analyst must possess?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;We can broadly categorize the skills of a business analyst in three types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fundamental skills&lt;/li&gt;
&lt;li&gt;Technical skills&lt;/li&gt;
&lt;li&gt;Business Analysis skills&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For each of the above categories a business analyst should possess some skills as mentioned below:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Skill category&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Skills&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Fundamental skills&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Problem Solving&lt;/strong&gt; &lt;strong&gt;Communication&lt;strong&gt;&lt;strong&gt;Management skills&lt;/strong&gt;&lt;/strong&gt;Research&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Technical skills&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;IT skills like MS Office, Operating systems, Programming languages, Knowledge of database, SDLC knowledge, Domain knowledge&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Business Analysis skills&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Requirement Elicitation****Documentation&lt;/strong&gt; &lt;strong&gt;Decision making****Creativity&lt;/strong&gt; &lt;strong&gt;Analytical skills&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;40-which-documents-are-used-to-capture-non-functional-requirements&#34;&gt;40. Which documents are used to capture non-functional requirements?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;有两个文档用于捕获非功能性需求，它们是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SDD（系统设计文件）&lt;/li&gt;
&lt;li&gt;FRD（功能需求文件）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;41-what-is-an-activity-diagram-and-what-are-the-important-elements-of-it&#34;&gt;41. What is an activity diagram and what are the important elements of it?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;活动图是业务用例工作流的可视化表示。此图显示了组织中不同部门（如HR，销售，客户等）发生的各种活动。该活动图突出显示了部门之间的差异。活动图中的重要元素是初始节点，活动，控制流，决策，派生，保护条件，连接和结束节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;42-what-are-the-best-practices-to-follow-while-writing-a-use-case&#34;&gt;42. What are the best practices to follow while writing a use case?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;编写用例的一些最佳实践如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了成为有效的用例，用例必须向参与者或涉众提供一些价值。&lt;/li&gt;
&lt;li&gt;在用例中必须适当地捕获功能需求和非功能需求。&lt;/li&gt;
&lt;li&gt;用例必须与主流一起具有一个或多个替代流。&lt;/li&gt;
&lt;li&gt;用例应该只描述系统的功能，而不是系统的完成方式，这意味着它不会描述设计。从演员的角度来看，它将充当黑匣子。&lt;/li&gt;
&lt;li&gt;用例不应有任何用例，即应是独立的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;43-what-is-the-difference-between-exception-flow-and-alternate-flow&#34;&gt;43. What is the difference between exception flow and alternate flow?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;替代流程是可以针对主流分开执行的替代动作，可以将其视为可选流程。异常流是在发生任何异常或错误时遍历的路径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;44-do-you-think-a-business-analyst-should-be-involved-in-testing&#34;&gt;44. Do you think a business analyst should be involved in testing?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;可以。因为业务分析师非常了解整体系统要求和与之相关的挑战。因此，他可以在测试阶段发挥作用，以适当地运行它并解决任何与系统相关的查询。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;45-what-is-pareto-analysis&#34;&gt;45. What is Pareto Analysis?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;帕累托分析（也称为80/20规则）是一种决策技术。这是用于缺陷解决和质量控制的有用技术。根据此分析规则，20％的原因会在系统中产生80％的效果，因此将其命名为80/20规则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;46-what-is-bpmn-and-what-are-its-basic-elements&#34;&gt;46. What is BPMN and what are its basic elements?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;BPMN是业务流程模型和表示法。它是业务流程的图形表示。&lt;/p&gt;
&lt;p&gt;BPMN有五个基本要素，它们是–&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流对象&lt;/li&gt;
&lt;li&gt;数据&lt;/li&gt;
&lt;li&gt;连接对象&lt;/li&gt;
&lt;li&gt;泳道&lt;/li&gt;
&lt;li&gt;伪像&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;47-what-is-kano-analysis&#34;&gt;47. What is Kano analysis?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Kano Analysis用于分析系统的需求，以确定其对客户满意度的影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;48-what-are-the-different-types-of-actors-you-know-in-use-case-diagram&#34;&gt;48. What are the different types of actors you know in use case diagram?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在用例中主要可以描述两种类型的参与者：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要参与者–开始流程&lt;/li&gt;
&lt;li&gt;次要演员–协助主要演员&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，我们可以将参与者分为四种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人类&lt;/li&gt;
&lt;li&gt;系统&lt;/li&gt;
&lt;li&gt;硬件&lt;/li&gt;
&lt;li&gt;计时器&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;49-what-is-benchmarking基准&#34;&gt;49. What is Benchmarking(基准)?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;基准测试是衡量组织在行业中竞争的绩效。在此过程中，公司可能会评估其政策，绩效，规则和其他措施。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;50-what-is-the-difference-between-business-analysis-and-business-analytics&#34;&gt;50. What is the difference between Business analysis and Business Analytics?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The key difference between Business analysis and Business analytics is the first one is more functions and process related whereas the second one is data related.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Business analysis&lt;/strong&gt; – recognizes business needs and determine the solutions to that problems. Tools and techniques like SWOT, PESTEL, CATWOE, MOST, FIVE WHY, etc. are used for business analysis.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Business analytics&lt;/strong&gt; – handles data and analyze data to get insights into a business. Finally, it generates reports. Mainly four types of business analytics are used, and they are – descriptive analytics, decisive analytics, prescriptive analytics, and predictive analytics Tools and technologies like Big data, BI is used for this purpose.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;51-what-is-process-design&#34;&gt;51. What is process design?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;流程设计是一种帮助企业分析业务挑战并为这些挑战找到有效解决方案的方法。通过流程设计，可以创建工作流程，以在最短的时间内获得最佳的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;52-what-are-the-essential-qualities-of-an-agile-ba&#34;&gt;52. What are the essential qualities of an Agile BA?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;领导才能&lt;/li&gt;
&lt;li&gt;优秀的沟通能力&lt;/li&gt;
&lt;li&gt;问题分析技巧&lt;/li&gt;
&lt;li&gt;技术知识&lt;/li&gt;
&lt;li&gt;领域知识&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;53-how-do-you-decide-that-as-a-business-analyst-you-have-gathered-all-the-requirements&#34;&gt;53. How do you decide that as a business analyst you have gathered all the requirements?&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;只有在以下情况下才能收集所有要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它由业务用户验证和批准。&lt;/li&gt;
&lt;li&gt;这些要求与项目的业务要求适当匹配。&lt;/li&gt;
&lt;li&gt;可以使用可用资源来实现要求。&lt;/li&gt;
&lt;li&gt;所有关键业务利益相关者均符合所提出的要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;53-how-do-you-perform-requirement-gathering&#34;&gt;53. How do you perform requirement gathering?&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;需求收集过程通常分为多个步骤，这些步骤与SDLC周期无关。 每个步骤都涉及：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要执行的特定任务&lt;/li&gt;
&lt;li&gt;遵循的原则&lt;/li&gt;
&lt;li&gt;产生文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;步骤如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**步骤1：**收集背景信息–这可能包括收集有关项目的背景信息，分析与项目相关的任何潜在风险。可以使用PESTLE分析，波特的五力框架等技术来实现此目的。&lt;/p&gt;
&lt;p&gt;**步骤2：**确定利益相关者–他们是项目的决策者，是需求和优先级的批准者。利益相关者的范围可能从项目所有者到高级经理，最终用户，甚至是竞争对手。&lt;/p&gt;
&lt;p&gt;**步骤3：**发现业务目标–这是在深入项目之前了解项目的业务需求。SWOT分析，基准测试，分析业务目标SMART和列出业务目标是用于此目的的一些技术。&lt;/p&gt;
&lt;p&gt;**步骤4：**评估选项–这是确定实现业务目标的选项。影响分析，风险分析，成本效益分析是用于此目的的一些方法。&lt;/p&gt;
&lt;p&gt;**步骤5：**范围定义–范围是基于业务目标设置的项目开发目标。范围定义文档用于详细说明项目每个阶段的目标。&lt;/p&gt;
&lt;p&gt;**步骤6：**业务分析师交付计划–根据项目范围，利益相关者的可用性和项目方法，在此步骤中将创建一个称为业务分析师的文档。该文档提供了有关可交付成果及其时间表的信息。&lt;/p&gt;
&lt;p&gt;**步骤7：**定义项目需求–在此步骤中，使用两种类型的文档–功能需求文档和非功能需求文档。根据项目中使用的开发方法，业务分析师需要通过与利益相关者进行面谈，与利益相关者明确需求，并在需求上达成一致。&lt;/p&gt;
&lt;p&gt;**步骤8：**通过SDLC实施支持–这是需求的技术实施步骤，业务分析员需要与不同的团队合作。这包括与开发团队和测试团队进行协调，以确保按预期实现需求，并针对所有可能的业务场景进行适当的测试。他们还需要处理可能在以后的时间点由利益相关者提出的变更请求。&lt;/p&gt;
&lt;p&gt;**步骤9：**评估项目的增值–这是对项目的持续评估，以评估业务目标的实施是否正确地满足了业务需求的结果和时间表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.indeed.com/career-advice/interviewing/business-analyst-interview-questions&#34;&gt;Top 8 Business Analyst Interview Questions and Answers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.simplilearn.com/business-analyst-interview-questions-article&#34;&gt;Top 30 Business Analyst Interview Questions and Answers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.whizlabs.com/blog/business-analyst-interview-questions/&#34;&gt;Top 50 Business Analyst Interview Questions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhcn.chalized.com/%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E4%B8%9A%E5%8A%A1%E5%88%86%E6%9E%90%E5%B8%88%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/&#34;&gt;如何回答业务分析师面试问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.srcmini.com/32722.html&#34;&gt;最新业务分析师面试问题精华汇总&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.netinbag.com/cn/education/what-are-common-business-analyst-interview-questions.html&#34;&gt;什么是常见的业务分析师面试问题？&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>How To Prepare for a Behavioral Interview</title>
      <link>http://www.yezheng.pro/post/interview/behavioral-interview/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/interview/behavioral-interview/</guid>
      
        <description>&lt;h2 id=&#34;what-is-a-behavioral-interview&#34;&gt;What is a Behavioral Interview?&lt;/h2&gt;
&lt;p&gt;A behavioral interview is a popular interview technique employers use to assess job candidates &lt;strong&gt;based on their past behavior&lt;/strong&gt;. For example, instead of asking &lt;strong&gt;hypothetical questions&lt;/strong&gt; like, “How would you react if you were under a lot of pressure at work?” they would instead ask &lt;strong&gt;situational questions&lt;/strong&gt; like, “Describe a time you were under a lot of pressure at work. How did you react?”&lt;/p&gt;
&lt;h2 id=&#34;behavioral-interview-tips&#34;&gt;Behavioral Interview Tips&lt;/h2&gt;
&lt;p&gt;Here are some important tips to consider when preparing for your next behavioral interview:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Study the job description.&lt;/li&gt;
&lt;li&gt;Review major projects you’ve worked on.&lt;/li&gt;
&lt;li&gt;Revisit previous job performance reviews.&lt;/li&gt;
&lt;li&gt;Make a list of your professional accomplishments.&lt;/li&gt;
&lt;li&gt;Use the STAR method to structure your response.&lt;/li&gt;
&lt;li&gt;Be open and honest in your answer.&lt;/li&gt;
&lt;li&gt;Practice your interview responses aloud.&lt;/li&gt;
&lt;li&gt;Keep your answers under two minutes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With these kinds of questions, interviewers are usually trying to learn three things: First, they want to know how you behaved in a real-world situation. Second, they want to understand the measurable value you added to that situation. Finally, they are trying to learn how you define something like “pressure at work”—a concept different people might interpret differently.&lt;/p&gt;
&lt;p&gt;Success in a behavioral interview is all about preparation. There aren’t necessarily wrong answers. These questions are aimed at getting to know the real you. The important thing is to be honest and to practice structuring your responses in a way that communicates what you have to offer.&lt;/p&gt;
&lt;h3 id=&#34;use-the-star-method-to-structure-answers-to-behavioral-questions&#34;&gt;Use the STAR method to structure answers to behavioral questions&lt;/h3&gt;
&lt;p&gt;You can use the STAR interview method to prepare for behavioral interviews—a technique that helps you structure your response to behavioral interview questions. Using this method, you create a deliberate story arc that your interviewer can easily follow. Here’s how it works:&lt;/p&gt;
&lt;h4 id=&#34;situation&#34;&gt;Situation&lt;/h4&gt;
&lt;p&gt;What is the context of your story? In setting the situation, you are telling your listener when or where this event took place. For example, “&lt;em&gt;We were working on a six-month contract for a high-value client when our agency merged with another, larger firm…&lt;/em&gt;”&lt;/p&gt;
&lt;h4 id=&#34;task&#34;&gt;Task&lt;/h4&gt;
&lt;p&gt;What was your role in this situation? For example, “It was my role to lead the transition for my group while also communicating with our client to keep the project on track.”&lt;/p&gt;
&lt;h4 id=&#34;action&#34;&gt;Action&lt;/h4&gt;
&lt;p&gt;What did you do? For example, “I set up weekly check-ins with the client to update them on the progress of the merger. This cemented an important level of trust between us. I also had regular one-on-ones with each person on the team, both to assess how they were handling the change and to make sure we would meet our deadlines.”&lt;/p&gt;
&lt;h4 id=&#34;result&#34;&gt;Result&lt;/h4&gt;
&lt;p&gt;What did your actions lead to? For example, “We ended up completing the project on time, meeting all of their specifications. It was incredibly rewarding to navigate a lot of change and succeed under pressure.”&lt;/p&gt;
&lt;h3 id=&#34;how-to-prepare&#34;&gt;How to prepare&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Read the job description carefully. Make a list of the top skills or qualifications it calls for. Think of a story that demonstrates your ability in each area. Following the STAR technique, write your stories down, including the situation, task, action and result. Then, practice saying them out loud several times, either by yourself or with a friend.&lt;/strong&gt; Keep in mind that your answer should only take about 1 1/2 to 2 minutes. As you include each of the elements, try to be succinct.&lt;/p&gt;
&lt;p&gt;If you’re feeling shy or lacking confidence, this practice is all the more important. You should get comfortable with these stories. Remember, you won’t be able to anticipate every behavioral question you get, but with a strong set of anecdotes, you’ll be able to answer each one with confidence.&lt;/p&gt;
&lt;h2 id=&#34;behavioral-interview-questions&#34;&gt;Behavioral interview questions&lt;/h2&gt;
&lt;p&gt;Here are several examples of questions you might be asked in your next behavioral interview. Take some time to prepare sample answers for each both to practice and plan so you will be prepared for future interviews.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Give me an example of a difficult problem you solved. How did you solve this problem?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编程开发时Pandas的Dataframe用Django的ORM写入数据库。Google查资料和翻源码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tell me about a mistake that you’ve made. How did you handle it?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Can you tell me about a challenging situation you overcame at work?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;会议的引导能力，会议总会被各种各样的问题打断，需要能够及时把主题带回到会议议题上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tell me about a time you learned a new skill. How did you approach it and how to did you apply your new learnings?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Has there been a time when you had to pitch an idea to a manager or senior leader? What was the outcome?&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tell me about a time when you overcame a conflict at work.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Explain a situation in which you would have handled things differently.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tell me about a time you handled a stressful situation when you were under a lot of pressure.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;工作至今最大的压力是2020年Q4在华为做课程融合专项时。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Can you tell me about a time you set and achieved a certain goal?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设定并实现特定目标&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What is your proudest professional accomplishment and why?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最自豪的职业成就&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;behavioral-interview-sample-answer&#34;&gt;Behavioral interview sample answer&lt;/h2&gt;
&lt;p&gt;Using the above techniques, here is an example of how you might answer a behavioral interview question:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; Tell me about a time when you overcame a conflict at work.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; &lt;em&gt;“At my last job, my colleague and I disagreed on how to handle a sensitive situation with our client. We made a mistake in their campaign that resulted in poor overall performance. While my colleague wanted to move forward without explaining the mistake, I thought it would be best to let the client know what happened.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;After going back and forth, I asked him if we could set some time aside to weigh the costs and benefits of each option. In the end, we needed to see each other’s motivations and fears to get a better understanding of the other.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;We decided to let the client know what had happened and agreed to provide them with another campaign at no cost. While it did result in a short-term loss for the company, the client appreciated our honesty and booked an annual campaign exceeding their spending with us in the past. My colleague and I were also recognized for our teamwork and ended up counseling other client teams on conflict resolution.”&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.indeed.com/career-advice/interviewing/how-to-prepare-for-a-behavioral-interview&#34;&gt;How To Prepare for a Behavioral Interview&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>distributed systems</title>
      <link>http://www.yezheng.pro/post/specialization/web-application/distribute-systems/distribute-systems/</link>
      <pubDate>Sat, 27 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/specialization/web-application/distribute-systems/distribute-systems/</guid>
      
        <description>&lt;ol&gt;
&lt;li&gt;Java分布式应用如何入门以及有哪些资料？&lt;/li&gt;
&lt;li&gt;怎样才是一个基本水平的java程序员？&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>summarization</title>
      <link>http://www.yezheng.pro/post/specialization/artificial-intelligence/natural-language-processing/summarization/</link>
      <pubDate>Sat, 27 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/specialization/artificial-intelligence/natural-language-processing/summarization/</guid>
      
        <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/huggingface/transformers/tree/master/examples/seq2seq&#34;&gt;https://github.com/huggingface/transformers/tree/master/examples/seq2seq&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tensorflow/models/tree/master/research/textsum&#34;&gt;https://github.com/tensorflow/models/tree/master/research/textsum&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/atulkum/pointer_summarizer&#34;&gt;https://github.com/atulkum/pointer_summarizer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/vrindav/just-news-it&#34;&gt;https://github.com/vrindav/just-news-it&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/pytorch/fairseq&#34;&gt;https://github.com/pytorch/fairseq&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/abisee/pointer-generator&#34;&gt;https://github.com/abisee/pointer-generator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>code quality gate</title>
      <link>http://www.yezheng.pro/post/specialization/devops/checker/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/specialization/devops/checker/</guid>
      
        <description>&lt;p&gt;sourcemonitor
simian&lt;/p&gt;
&lt;p&gt;coverity
fotify
klocwork&lt;/p&gt;
&lt;p&gt;Sonar
checkstyle-idea
findbugs-idea
PMDPlugin
Save Actions&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>domain-driven design read me</title>
      <link>http://www.yezheng.pro/post/specialization/web-application/domain-driven-design/readme/</link>
      <pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/specialization/web-application/domain-driven-design/readme/</guid>
      
        <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/32459776&#34;&gt;https://zhuanlan.zhihu.com/p/32459776&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/25089273/answer/233316164&#34;&gt;https://www.zhihu.com/question/25089273/answer/233316164&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/343388831&#34;&gt;https://zhuanlan.zhihu.com/p/343388831&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/75931257&#34;&gt;https://zhuanlan.zhihu.com/p/75931257&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/348706530&#34;&gt;https://zhuanlan.zhihu.com/p/348706530&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/334999899&#34;&gt;https://zhuanlan.zhihu.com/p/334999899&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/31687912/answer/95842364&#34;&gt;https://www.zhihu.com/question/31687912/answer/95842364&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/VaughnVernon/IDDD_Samples&#34;&gt;https://github.com/VaughnVernon/IDDD_Samples&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>domain-driven design with python</title>
      <link>http://www.yezheng.pro/post/specialization/web-application/domain-driven-design/python/</link>
      <pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/specialization/web-application/domain-driven-design/python/</guid>
      
        <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cosmicpython/code/branches/all&#34;&gt;https://github.com/cosmicpython/code/branches/all&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Architecture Patterns with Python: Enabling Test-Driven Development, Domain-Driven Design, and Event-Driven Microservices&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>products</title>
      <link>http://www.yezheng.pro/post/specialization/product/product/</link>
      <pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/specialization/product/product/</guid>
      
        <description>&lt;p&gt;APM(Application Performance Management)
ADS(Application Deploy Service)
WAS(WebSphere Application Server)&lt;/p&gt;
&lt;p&gt;Dynatrace
Pinpoint&lt;/p&gt;
&lt;p&gt;UEM用户体验运营&lt;/p&gt;
&lt;p&gt;ADS
RDS&lt;/p&gt;
&lt;p&gt;用户行为分析: Google Analysis&lt;/p&gt;
&lt;p&gt;AS SAAS:&lt;/p&gt;
&lt;p&gt;API Gateway:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kong/Kong&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Centralized config server:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apollo&lt;/li&gt;
&lt;li&gt;Nacos&lt;/li&gt;
&lt;li&gt;Spring Cloud Config&lt;/li&gt;
&lt;li&gt;Go Microservices, Part 8: Centralized Configuration With Viper and Spring Cloud Config&lt;/li&gt;
&lt;li&gt;spring-cloud-alibaba&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;APM：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pinpoint&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CodeHub:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitLab&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SCS (Stream Compute Service):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Flink&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>[转]数据库系统概念</title>
      <link>http://www.yezheng.pro/post/specialization/systems/data-management-and-data-systems/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Fri, 19 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/specialization/systems/data-management-and-data-systems/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/</guid>
      
        <description>&lt;p&gt;第一章、引言&lt;/p&gt;
&lt;p&gt;1.1 文件管理系统坏处&lt;/p&gt;
&lt;p&gt;1.2 数据视图&lt;/p&gt;
&lt;p&gt;1.3 数据模型&lt;/p&gt;
&lt;p&gt;1.4 数据库语言&lt;/p&gt;
&lt;p&gt;第二章、关系模型介绍&lt;/p&gt;
&lt;p&gt;2.1 关系数据库的结构&lt;/p&gt;
&lt;p&gt;2.2 数据库模式&lt;/p&gt;
&lt;p&gt;2.3 码&lt;/p&gt;
&lt;p&gt;第三章、SQL&lt;/p&gt;
&lt;p&gt;3.1 SQL 查询语言概览&lt;/p&gt;
&lt;p&gt;3.2 SQL数据定义&lt;/p&gt;
&lt;p&gt;3.2.1基本类型&lt;/p&gt;
&lt;p&gt;3.2.2基本模式定义&lt;/p&gt;
&lt;p&gt;3.3 sql查询的基本结构&lt;/p&gt;
&lt;p&gt;3.3.1 单关系查询&lt;/p&gt;
&lt;p&gt;3.3.2 多关系查询&lt;/p&gt;
&lt;p&gt;3.3.3 自然连接&lt;/p&gt;
&lt;p&gt;3.4 附加基本运算&lt;/p&gt;
&lt;p&gt;3.5 集合运算&lt;/p&gt;
&lt;p&gt;3.6 空值&lt;/p&gt;
&lt;p&gt;3.7 聚集函数&lt;/p&gt;
&lt;p&gt;3.8 嵌套子查询，&lt;/p&gt;
&lt;p&gt;第四章、中级SQL&lt;/p&gt;
&lt;p&gt;4.1 连接表达式&lt;/p&gt;
&lt;p&gt;4.2 视图&lt;/p&gt;
&lt;p&gt;4.2.3 物化视图&lt;/p&gt;
&lt;p&gt;4.2.4 视图更新&lt;/p&gt;
&lt;p&gt;4.3 事务&lt;/p&gt;
&lt;p&gt;4.4 完整性约束&lt;/p&gt;
&lt;p&gt;4.5 SQL的数据类型和模式&lt;/p&gt;
&lt;p&gt;4.6 模式的授权&lt;/p&gt;
&lt;p&gt;第六章、 形式化关系查询语言&lt;/p&gt;
&lt;p&gt;6.1 关系代数&lt;/p&gt;
&lt;p&gt;6.1.1 基本运算&lt;/p&gt;
&lt;p&gt;6.1.2 关系运算的形式化定义&lt;/p&gt;
&lt;p&gt;6.1.3 附加的关系代数运算&lt;/p&gt;
&lt;p&gt;6.1.4 扩展的关系代数运算&lt;/p&gt;
&lt;p&gt;第七章、数据库设计和E-R模型&lt;/p&gt;
&lt;p&gt;7.1 设计过程概览&lt;/p&gt;
&lt;p&gt;7.2 E-R模型&lt;/p&gt;
&lt;p&gt;7.3 约束&lt;/p&gt;
&lt;p&gt;7.3.1 映射基数&lt;/p&gt;
&lt;p&gt;7.3.2 参与约束&lt;/p&gt;
&lt;p&gt;7.3.3 码more&lt;/p&gt;
&lt;p&gt;7.5 实体-联系图&lt;/p&gt;
&lt;p&gt;7.5.1 基本结构&lt;/p&gt;
&lt;p&gt;7.5.3 复杂的属性&lt;/p&gt;
&lt;p&gt;7.5.4 角色&lt;/p&gt;
&lt;p&gt;7.5.5 非二元的联系集&lt;/p&gt;
&lt;p&gt;7.5.6 弱实体集&lt;/p&gt;
&lt;p&gt;7.6 转换为关系模式&lt;/p&gt;
&lt;p&gt;7.6.1 具有简单属性的强实体集的表示&lt;/p&gt;
&lt;p&gt;7.6.2 具有复杂属性的强实体集的表示&lt;/p&gt;
&lt;p&gt;7.6.3 弱实体集的表示&lt;/p&gt;
&lt;p&gt;第八章、 关系数据库设计&lt;/p&gt;
&lt;p&gt;8.1 好的关系设计的特点&lt;/p&gt;
&lt;p&gt;8.2 原子域和第一范式&lt;/p&gt;
&lt;p&gt;8.3 使用函数依赖进行分解&lt;/p&gt;
&lt;p&gt;8.3.1 码和函数依赖&lt;/p&gt;
&lt;p&gt;8.3.2 范式&lt;/p&gt;
&lt;p&gt;8.4 函数依赖理论&lt;/p&gt;
&lt;p&gt;第十二章、事务管理&lt;/p&gt;
&lt;p&gt;12.1 事务概念&lt;/p&gt;
&lt;p&gt;12.2 事务的原子性和持久性&lt;/p&gt;
&lt;p&gt;12.3 事务的隔离性&lt;/p&gt;
&lt;p&gt;12.4 可串行化&lt;/p&gt;
&lt;p&gt;12.5 可恢复性&lt;/p&gt;
&lt;p&gt;12.6 并发控制&lt;/p&gt;
&lt;p&gt;12.6.1 基于锁的协议&lt;/p&gt;
&lt;p&gt;12.6.2 保证可串行性的封锁协议（两阶段封锁协议）&lt;/p&gt;
&lt;p&gt;12.6.3 多粒度封锁的必要性&lt;/p&gt;
&lt;p&gt;12.7 恢复系统&lt;/p&gt;
&lt;p&gt;12.7.1 故障分类&lt;/p&gt;
&lt;p&gt;12.7.2 数据访问&lt;/p&gt;
&lt;p&gt;12.7.3  恢复和原子性&lt;/p&gt;
&lt;p&gt;第一章、引言
数据库系统有一个相互关联的数据的集合和一组用以访问这些戴护具的程序组成。这个数据集合通常称为数据库。DBS主要的目的是提供一种方面、高效的存取是数据库通常称为数据库。
数据库系统：DBMS数据库管理系统，管理员，开发的软件。
1.1 文件管理系统坏处
数据的冗余和不一致
数据访问困难
数据孤立
完整性问题
原子性问题
并发访问异常
安全性问题
1.2 数据视图
数据抽象：物理层描述数据实际上是怎样存储的。 逻辑层描述数据库中存储什么数据及这些数据间存在什么关系。视图层只描述数据库的某个部分。物理数据独立性、逻辑数据独立性
最后，在视图层。计算机用户看见的是为其屏蔽了数据类型细节的一组应用程序。除了屏蔽数据库的逻辑层细节之外，视图还提供了防止用户访问数据库的某些部分的安全性机制。
特定时刻存储在数据库中的信息的集合称作数据库的一个实例，而数据库的总体设计称作数据库模式。
1.3 数据模型
数据库结构的基础是数据模型。数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。数据模型提供了一种描述物理层、逻辑层及视图表达层数据库设计的方式。
关系模型。用表的集合表示数据和数据之间的联系。是基于记录的模型的一种
E-R实体-联系模型
基于对象的数据模型
半结构化数据模型
1.4 数据库语言
DDL定义数据库模式，以及数据库操纵语言（DML）来表达数据库查询和更新
DDL的一些一致性约束：域约束、参照完整性、断言、授权。DDL的输出放在数据字典中，数据字典包含了元数据，元数据是关于数据的数据。
DML分为过程化DML，要求用户指定需要什么数据及如何获得这些数据。声明式DML（非过程化）只要求用户指定需要什么数据，而不指明如何获得这些数据。
查询是要求对信息进行检索的语句。DML中涉及信息检索部分称作查询语言。
第二章、关系模型介绍
数据模型是描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。
2.1 关系数据库的结构
关系数据库由表的集合组成表中一行代表了一组值之间的一种联系。由于一个表就是这种联系的一种集合，表这个概念和数学上的关系这个概念是紧密相连的，元组只是一组值的序列。
关系用来指代表，而元组用来指代行。属性指代的表中的列。属性位置不重要。因为关系是元组集合，所以元组在关系中出现的顺序是无关紧要的。
对于关系的每个属性，都存在一个取值的集合，称为该属性的域
关系实例这个术语用来代表一个关系的特定实例。
关系是笛卡儿积的子集
要求对所有关系r而言，r的所有属性的域都是原子的。如果域中元素被看作是不可再分的单元，而域是原子的。
null空值代表一种特殊的值，一种状态。表示未知或不存在。
2.2 数据库模式
数据库模式是数据库的逻辑设计，数据库实例是给定时刻数据库中数据的一个快照
关系的概念对应程序设计语言中变量的概念，关系模式对应于类型定义的概念，关系实例的概念是变量的值的概念
2.3 码
r(R) r是关系实例，R是关系模式
一个元组的属性值必须是能唯一区分元组的，一个关系中没有两个元组在所有属性上的取值都相同
超码是一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一标识一个元组。
有一些超码，他们的任意真子集都不能称为超码，这样的最小超码称为候选码。出现在任何一个候选码中的属性&amp;ndash;&amp;gt;主属性
几个不同的属性集都可以用作候选码的情况是存在的。
用主码这个术语来代表被数据库设计者选中的、主要用来在一个关系中区分不同元组的候选码。码是整个关系的一种性质，而不是单个元组的性质。
主码应该选那些值从不或很少变化的属性。
完整性约束包括完整性约束：主码的属性不能为空，参照完整性约束/子集依赖：在参照关系上的任意元组在特定属性上的取值必然等于被参照关系中某个元组在特定属性上的取值或null。不同于外码依赖，参照完整性约束不要求依赖的一定是主码。
一个关系模式（r1)可能在他的属性中包括另一个关系模式（r2)的主码。这个属性在r1上称作参照r2的外码。关系r1也称为外码依赖的参照关系，r2叫做外码的被参照关系。
第三章、SQL
3.1 SQL 查询语言概览
sql是数据库查询语言。有以下几个部分：&lt;/p&gt;
&lt;p&gt;数据定义语言（DDL）：定义关系模式、删除关系、修改关系模式、每个属性的取值类型、每个关系维护的索引集合、每个关系的安全性和权限信息、每个关系在磁盘上的物理存储结构。
数据操纵语言（DML）：从数据库中查询信息，在数据库中插入元组、删除元组、修改元组的部分。
完整性：sql DDL包括定义完整性约束的命令，破坏完整性的更新是不被允许的。
视图定义
事务控制
嵌入式sql忽然动态sql：sql如何嵌入到通用编程语言。
授权：sql DDL包括定义对关系和视图的访问权限的命令。
3.2 SQL数据定义
3.2.1基本类型
char(n) 固定长度字符串。空格补位
varchar(n) 可变长度字符串。不补位
int
smallint
numeric(p,d)定点数
real,double precision :浮点数和双精度浮点数
float(n)精度至少为n位的浮点数
char和char比较时，长度不同追加空格 。char和varchar比较可能返true、false。建议使用varchar而不是char来解决问题。&lt;/p&gt;
&lt;p&gt;3.2.2基本模式定义
primary key(A1,A2&amp;hellip;An)
foreigh key(A1,A2&amp;hellip;An) references:
not null
create
sql允许为属性指定默认值
mysql&amp;gt; create table d(
-&amp;gt; good varchar(20),
-&amp;gt; g varchar(20) not null,
-&amp;gt; primary key(good,g)
-&amp;gt; );&lt;/p&gt;
&lt;p&gt;create table b(
course_id varchar(20),
tot_cred numeric(3,0) default 0,
foreign key(course_id) references d
);
insert。可以在查询结果的基础上加入元组。在执行插入前执行完select语句很重要。没有被赋值的属性为空。
insert into wang values(&amp;ldquo;L&amp;rdquo;,15,69);&lt;/p&gt;
&lt;p&gt;insert intp wang(a,b,c) values(&amp;ldquo;L&amp;rdquo;,15,69); //推荐&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; insert into list(id)
-&amp;gt; select id
-&amp;gt; from consumer;
delete,删除关系中所有元祖。
drop删除表
alter  在表中增加、删除列。新属性的值为null
在执行删除前先执行所有元组的测试很重要
delete from wang where name=&amp;lsquo;Liu&amp;rsquo;;&lt;/p&gt;
&lt;p&gt;drop table wang;&lt;/p&gt;
&lt;p&gt;alter table user add good varchar(20);&lt;/p&gt;
&lt;p&gt;alter table user drop good;&lt;/p&gt;
&lt;p&gt;update,必须在更新前检查关系中的所有元组&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; update list
-&amp;gt; set days=1
-&amp;gt; where days=2;
case语句可以用在任何应该出现值的地方。有条件没有被覆盖，返回null
mysql&amp;gt; update student S
-&amp;gt; set tot_cred=(
-&amp;gt;             select case when sum(credits) is not null then sum(credits)
else 0
end
-&amp;gt;             from takes natural join course
-&amp;gt;             where S.ID=takes.ID and
-&amp;gt;             takes.grade&amp;lt;&amp;gt;&amp;lsquo;F&amp;rsquo; and takes.grade is not null);
3.3 sql查询的基本结构
3.3.1 单关系查询
一般sql不去重distinct 显示去重，all显示不去重
select distinct id from list;
select all id from list;
支持+，-，&lt;em&gt;，/。逻辑词and,or,not。比较运算符&amp;lt;,&amp;gt;,&amp;lt;=,&amp;gt;=,&amp;lt;&amp;gt;.
mysql&amp;gt; select no&lt;/em&gt;2 from list
-&amp;gt; where no&amp;gt;1000 and days&amp;lt;&amp;gt;1;
3.3.2 多关系查询
from语句定义了一个在该语句中所列出关系的笛卡尔集。where中的谓词限制笛卡尔集的集合。在属性前加前缀区分属性来自哪个关系。sql会通过只产生满足where子句的笛卡尔元素优化执行。
逻辑顺序   from&amp;ndash;where&amp;ndash;group by&amp;ndash;having&amp;ndash;order by&amp;ndash;select   所有运算都是表运算，输入输出都是一个表。
select name,course_id
from instructor,teachers
where instructor.ID=teaches.ID
3.3.3 自然连接
只取在共同属性上取值相同的元组对。列出的属性顺序：共同的&amp;ndash;第一个&amp;ndash;第二个
join&amp;hellip;using需要一个属性列表，允许用户来确定哪些列相等
mysql&amp;gt; select *
-&amp;gt; from consumer natural join list;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select *
-&amp;gt; from consumer join list using(id)
-&amp;gt; ;
3.4 附加基本运算
更名运算 as.可以出现在select、from中
字符串运算。用双引号代表单引号。大小写敏感。串接||、upper(s)、lower(s)、trim(s).    like/not like模式匹配。百分号：匹配任意字串。_匹配任意一个字符.   允许转义字符，直接在特殊字符前面，表示特殊字符为普通字符，escape定义转义字符
order  by. 默认升序    desc降序      asc升序&lt;br&gt;
[not]between&amp;hellip;.and闭区间
(a,b,&amp;hellip;c)n维元组，可以按字典序比较运算
mysql&amp;gt; select T.sex as bala
-&amp;gt; from consumer as c,consumer as t
-&amp;gt; where c.sex=t.sex and t.name=&amp;lsquo;王文萱&amp;rsquo;;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select * from list where id like &amp;lsquo;211%&#39;;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select * from list
-&amp;gt; order by id desc,no asc;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select * from list
-&amp;gt; where no not between 1000 and 1001;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select * from instructor,teaches
-&amp;gt; where (instructor.ID,dept_name)=(teaches.ID,&amp;lsquo;Biology&amp;rsquo;);
3.5 集合运算
union
intersect
except
全部自动去重，后面加上all不去重。&lt;/p&gt;
&lt;p&gt;3.6 空值
算术表达式的任一输入为空，结果为空。
SQL设计控制任何比较运算的结果为unknown（既不是is null,也不是is not null),这创建了除true和false外的第三个逻辑值。
如果子句谓词对一个元组计算出false或unknown，则该院组不能加入结果集中。
用is null和not is null判断是否是null值。用is unknown和not is unknown判断是否是unknow值
当一个查询使用select distinct 语句时，重复元组将被去除。为了达到这个目的，当比较两个元组对应的属性值时，如果这两个元组都是非空且值相等，或者都是为空，那么它们是相同的。所以诸如{（A,null),(A,null)}这样的两个元组拷贝被认为是相同的，即使在某些属性上存在空值。使用distinct子句会保留这样的相同元组的一份拷贝。
mysql&amp;gt; select * from list
-&amp;gt; where no is unknown;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select * from list
-&amp;gt; where no is null;
3.7 聚集函数
avg
min
max
count
sum
sum和avg的输入必须是数字集
聚集函数以以下规则处理空值：除了count(&lt;em&gt;)外所有的聚集函数都忽略输入集合的空值。规定空集的count为0，其它所有聚集函数在输入为空集的情况下返回一个空值。
任何出现在having子句中，但没有被聚集的属性必须出现在group by中
任何出现在select子句中，但没有被聚集的属性必须出现在group by中
having子句中的谓词只有在形成分组后才起作用
使用关键字distinct可以删除重复元素，不允许在count(&lt;/em&gt;)时使用distinct.
group by子句中给出一个或多个属性是用来构造分组的。
3.8 嵌套子查询，
子查询在where子句中，通常对成员资格、集合的比较以及集合的基数进行检查。
集合成员资格：in  /not in  测试是否是集合中的成员。也可用于枚举集合，在SQL测试任意关系的成员资格也是可以的。
mysql&amp;gt;
mysql&amp;gt; select distinct course_id
-&amp;gt; from section
-&amp;gt; where semester=&amp;lsquo;Fall&amp;rsquo; and year=&amp;lsquo;2009&amp;rsquo;
-&amp;gt; and course_id in(select distinct course_id
-&amp;gt;                  from section
-&amp;gt;                  where semester=&amp;lsquo;Spring&amp;rsquo; and year=2010);&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select distinct name
-&amp;gt; from instructor
-&amp;gt; where name not in(&amp;lsquo;Wang&amp;rsquo;,&amp;lsquo;Wen&amp;rsquo;);&lt;/p&gt;
&lt;p&gt;mysql&amp;gt;
mysql&amp;gt; select count(distinct ID)
-&amp;gt; from takes
-&amp;gt; where (course_id,sec_id,semester,year)in(select course_id,sec_id,semester,year
-&amp;gt;                                          from teaches
-&amp;gt;                                          where teaches.ID=10101);
集合的比较
至少比某一个要大/小/相等用some表示。&amp;lt;&amp;gt;some不等价not in,=some等价in
至少比所有要大/小/相等用all表示。&amp;lt;&amp;gt;all等价not in,=some不等价in
mysql&amp;gt; select name
-&amp;gt; from instructor
-&amp;gt; where salary&amp;gt;some(select salary
-&amp;gt;                  from instructor
-&amp;gt;                  where dept_name=&amp;lsquo;Biology&amp;rsquo;)
-&amp;gt; ;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select dept_name
-&amp;gt; from instructor
-&amp;gt; group by dept_name
-&amp;gt; having avg(salary)&amp;gt;all(
-&amp;gt;             select avg(salary)
-&amp;gt;             from instructor
-&amp;gt;             group by dept_name);
空关系测试   exists 参数的子查询非空时返回true/not exists
来自外层循环的一个相关名称可以用在where的子查询中。使用了外层查询相关名称的查询为相关子查询。如果一个相关名称在外层和子查询中定义，则子查询中定义有效。
关系A包含关系B   not exists(B except A)
select name
from student
where not exists(
(
select course_id
from course
where dept_name=&amp;lsquo;Biology&amp;rsquo;
)
except
(
select T.course_id
from takes as T
where S.ID=T.ID
)
);
重复元组存在性测试。sql提供一个布尔函数，用于测试在一个子查询的结果中是否存在重复元组。如果作为参数的子查询结果中没有重复的元组、unique结构将返回true值。在空集上计算出真值。还有not unique.对一个unique测试结果为假的定义是，当且仅当在关系中存在这两个元组t1和t2,且t1=t2.由于在t1或t2的某个域为空时，判断t1=t2为假，所以尽管一个元组有多个副本，只要该元组有一个属性为空unique测试可能为真。
select T.course_id
from course as T
where unique(select R.course_id
from section as R
where T.course_id=R.course_id and R.year=2009);
from语句中的子查询。任何select-from-where表达式返回的结果都是关系，因而可以被插入到另一个select-from-where中任何关系可以出现的位置。
可以用as子句给子查询的结果关系起个名字。
from子句嵌套的子查询中不能使用来自from子句其它关系的相关变量。加入lateral作为前缀，可以访问from子句中在它前面的表或子查询中的属性。
with子句提供定义临时关系的方法。
SQL允许子查询出现在单个值的表达式可以出现的任何地方，只要子查询只返回单个属性的单个元组；这样的子查询称为标量子查询。select、where、having子句都可以使用标量子查询。
select dept_name
from (select dept_name,avg(salary) as avg_salary
from instructor
group by dept_name)
as dept_avg(dept_name,avg_salary)
where avg_salary&amp;gt;42000;&lt;/p&gt;
&lt;p&gt;select dept_name
from (select dept_name,avg(salary) as avg_salary
from instructor
group by dept_name)
where avg_salary&amp;gt;42000;&lt;/p&gt;
&lt;p&gt;select name
from instructor I1,lateral (select avg(salary) as avg_salary
from instructor I2
where I2.dept_name=I1.dept_name);&lt;/p&gt;
&lt;p&gt;with dept_total(dept_name,value) as
(select sept_name,sum(salary)
from instructor
group by dept_name),&lt;/p&gt;
&lt;p&gt;dept_total_avg(value) as
(select avg(value)
from dept_total)&lt;/p&gt;
&lt;p&gt;select dept_name
from dept_total,dept_total_avg
where dept_total.val&amp;gt;=dept_total_avg.value;
3.8 其他sql
展示建表语句
show create table XXX&lt;/p&gt;
&lt;p&gt;第四章、中级SQL
4.1 连接表达式
on条件允许在参与连接的关系上设置通用的谓词
外连接运算与我们已经学过的连接运算类似，但通过在结果中创建空值元组的方式，保留了那些在连接中丢失的元组。
实际上有三种形式的外连接
左外连接(left join)	只保留出现在左连接之前的关系中的元组
右外连接(right join)	只保留出现在右外连接之后的关系中的元组
全外连接(full join)	保留出现在两个关系中的元组
我们之前学过的不保留未匹配元组的连接运算称为内连接运算
我们可以按照如下方式计算左外连接运算：&lt;/p&gt;
&lt;p&gt;首先，像前面那样计算出内连接的结果；然后，对于在内连接的左侧关系中任意一个与右侧关系中任何元组都不匹配的元组t,向连接结果中加入一个元组r,r的构造如下：&lt;/p&gt;
&lt;p&gt;元组r从左侧关系得到的属性为t中的值
r的其它属性被设为空值
on子句可以与外连接一起使用，与where中使用条件表现不同
当join子句中没有使用outer前缀，默认的连接类型就是inner join
任意的连接形式可以与任意的连接条件进行组合
连接类型	连接条件
inner join、left outer join、right outer join、full outer join	natural、on、using&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select *
-&amp;gt; from consumer join list on consumer.id=list.id;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select *
-&amp;gt; from(select *
-&amp;gt;      from list)
-&amp;gt; natural full outer join
-&amp;gt;     (select *
-&amp;gt;      from consumer);
4.2 视图
为了向用户隐藏部分信息
&lt;a href=&#34;https://blog.csdn.net/kanglovejava/article/details/52961244&#34;&gt;https://blog.csdn.net/kanglovejava/article/details/52961244&lt;/a&gt;
SQL允许通过查询来定义“虚关系”。它在概念上包含查询的结果。虚关系并不预先计算并存储，而是在使用虚关系的时候才通过查询被计算出来。任何不是逻辑模型的一部分，但作为虚关系对用户可见的关系称为视图。
视图关系在概念上包含查询结果中的元组，但并不预先计算和存储。相反，数据库系统存储与视图关系相关联的查询表达式。当视图关系被访问时，其中的元组是计算查询结果而被创建出来的。
一旦创建了视图，我们就可以使用视图名指代该视图生成的虚关系，视图名可以出现在任何关系名出现的地方。视图的属性名可以限定。
可以在视图定义的末尾加上with check option.这样，如果不满足check约束，更新被拒绝。
mysql&amp;gt; create view f as
-&amp;gt; select * from list;
Query OK, 0 rows affected (0.13 sec)&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; create view w(id) as
-&amp;gt; select id from list;
Query OK, 0 rows affected (0.05 sec)&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select * from w；
mysql&amp;gt; select * from f；&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; create view g as
-&amp;gt; select *
-&amp;gt; from list
-&amp;gt; where no&amp;lt;2000
-&amp;gt; with check option;
Query OK, 0 rows affected (0.08 sec)&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; insert into g(id,no) values(&amp;lsquo;211022199906030548&amp;rsquo;,5000);
ERROR 1369 (HY000): CHECK OPTION failed &amp;lsquo;haha.g&amp;rsquo;
4.2.3 物化视图
特定数据库系统允许存储视图关系，但是它们保证：如果用于定义视图的实际关系改变,视图也跟着修改。这样的视图成为物化视图&lt;/p&gt;
&lt;p&gt;保护物化视图一直在更新状态的过程称为物化视图维护，或者简称视图维护&lt;/p&gt;
&lt;p&gt;那些需要快速响应基大于关系上聚集运算的特定查询也会从创建和查询对应物化视图受益良多。&lt;/p&gt;
&lt;p&gt;物化视图带来的好处还需要和存储代价和增加的更新开销相权衡。&lt;/p&gt;
&lt;p&gt;4.2.4 视图更新
如果定义视图的查询对下列条件满足，我们称视图是可更新的：&lt;/p&gt;
&lt;p&gt;from 子句中只有一个数据库关系
select 子句中只包括关系的属性名，不包含任何表达式、聚集和distinct声明
任何没有出现在select子句中的属性可以取空值；即这些属性上没有not null约束，也不构成主码的一部分。
查询中不含有group by 和having子句
4.3 事务
&lt;a href=&#34;https://blog.csdn.net/w_linux/article/details/79666086&#34;&gt;https://blog.csdn.net/w_linux/article/details/79666086&lt;/a&gt;
SQL规定当一条SQL语句被执行，就隐式的开始了一个事务&lt;/p&gt;
&lt;p&gt;下列SQL语句会结束一个事务&lt;/p&gt;
&lt;p&gt;commit work：提交当前事务，也就是将该事物所做的更新在数据库中持久保存。在事物被提交后，一个新的事物自动开始&lt;/p&gt;
&lt;p&gt;rollback work：回滚当前事务，也就是撤销该事务中所有SQL语句对数据库的更新，就恢复到执行该事务第一语句之前的状态。&lt;/p&gt;
&lt;p&gt;关键词work可选&lt;/p&gt;
&lt;p&gt;一个事务或者在完成所有步骤后提交其行为，或者在不能成功完成其所有动作的情况下回滚其所有动作，通过这种方式数据库提供了对事务具有原子性的抽象，原子性即不可分割性。&lt;/p&gt;
&lt;p&gt;要么所有事务的所有影响被反映到数据库中，要么任何影响都没有（在回滚之后）
允许将所有SQL语句加载begin atomic……end之间。关键字之间的语句构成了单一事务。&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; start transaction;
Query OK, 0 rows affected (0.08 sec)&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; insert into exam values(2);
Query OK, 1 row affected (0.03 sec)&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; rollback;
Query OK, 0 rows affected (0.06 sec)&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select * from exam;
+&amp;mdash;&amp;mdash;+
| id   |
+&amp;mdash;&amp;mdash;+
|    1 |
+&amp;mdash;&amp;mdash;+&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; start transaction;
Query OK, 0 rows affected (0.00 sec)&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; update exam set id=2 where id=1;
Query OK, 1 row affected (0.03 sec)
Rows matched: 1  Changed: 1  Warnings: 0&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; commit;
Query OK, 0 rows affected (0.06 sec)&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select * from exam;
+&amp;mdash;&amp;mdash;+
| id   |
+&amp;mdash;&amp;mdash;+
|    2 |
+&amp;mdash;&amp;mdash;+
1 row in set (0.00 sec)
4.4 完整性约束
alter语句可以更改约束条件，add也是在加入列的同时加入约束条件。不是直接加约束条件的意思。当执行命令时，系统首先保证关系满足指定的约束条件。不满足，拒绝执行命令。
也可以alter table A add constraint。如果之前的关系不满足这个约束将拒绝执行该命令。
unique约束：在关系中没有2个元组能在所有列出的属性上取值相同，然而候选码可以为空
check子句：check（P）子句指定一个谓词，关系中的每一个元组都必须满足谓词P，check子句保证属性值满足指定的条件。check子句中的谓词可以是包括子查询在内的任意谓词
references可以显示指定被参照关系的属性列表，然而这个指定的属性列表必须声明为被参照关系的候选码。当违反参照完整性约束时，通常是拒绝执行导致完整性破坏的操作（即进行更新操作的事务被回滚）&lt;/p&gt;
&lt;p&gt;on delete cascade ,若删除department中的元组导致了此参照完整性约束被违反，则删除并不被系统拒绝，而是对course关系作级联删除&lt;/p&gt;
&lt;p&gt;事务中对完整性约束的违反，SQL允许将initially deffrred子句加入到约束声明中，这样完整性约束不是在事务的中间步骤上检查，而是在事务结束的时候检查。默认情况下它会被立即检查&lt;/p&gt;
&lt;p&gt;复杂check条件检测开销很大，我们可以使用断言，表达数据库总能满足某一个条件&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; alter table example change id id varchar(10) primary key;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; alter table example add id varchar(20) primary key;
ERROR 1060 (42S21): Duplicate column name &amp;lsquo;id&amp;rsquo;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; create table x(
-&amp;gt; id varchar(20,
-&amp;gt; check(id in (&amp;lsquo;Fall&amp;rsquo;,&amp;lsquo;Winter&amp;rsquo;));
mysql&amp;gt; create table wang(
-&amp;gt; id varchar(20)
-&amp;gt; check(id in(select id from list))
-&amp;gt; );&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; create table e(
-&amp;gt; id int,
-&amp;gt; unique(id));&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; create table wang(
-&amp;gt; id varchar(20),
-&amp;gt; foreign key(id) references list
-&amp;gt;             on delete cascade);&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; create assertion a check
-&amp;gt; (not exists(select *
-&amp;gt;             from list
-&amp;gt;             where no&amp;gt;9000)
-&amp;gt; );
4.5 SQL的数据类型和模式
SQL允许指定默认值&lt;/p&gt;
&lt;p&gt;SQL中的日期和时间类型&lt;/p&gt;
&lt;p&gt;一些获取当前日期和时间的函数&lt;/p&gt;
&lt;p&gt;current_date返回当前日期&lt;/p&gt;
&lt;p&gt;current_time返回当前时间&lt;/p&gt;
&lt;p&gt;localtime返回当前的本地时间&lt;/p&gt;
&lt;p&gt;时间戳（日期加上时间）由current_timestamp(带有时区)&lt;/p&gt;
&lt;p&gt;localtimestamp(本地日期和时间，不带时区)&lt;/p&gt;
&lt;p&gt;SQL允许在上面列出的所有类型上进行比较运算，也允许在各种数字类型上进行算术运算和比较运算&lt;/p&gt;
&lt;p&gt;还支持interval数据类型，允许在日期、时间、和时间间隔上进行运算&lt;/p&gt;
&lt;p&gt;x,y都是date类型，那x-y就是时间间隔类型，其值为日期x到日期y间隔的天数&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select current_date - date&#39;2001-05-24&amp;rsquo;;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select current_date;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; select date&#39;2001-04-25&#39;,time&#39;09:30:00&#39;,timestamp&#39;2001-04-25 09:30:00&#39;;&lt;/p&gt;
&lt;p&gt;//从date中提取域。有year,month,day,hour,minute,second
mysql&amp;gt; select extract(year from date&#39;2001-05-24&#39;);&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; cast(&amp;lsquo;2001-05-24&amp;rsquo; as DATE);  //将字符串转化称DATE
创建索引
mysql&amp;gt; create index i on wang(id);
大对象类型
一个应用通常使用一个SQL查询来检索一个大对象的定位器，然后在宿主语言中用这个定位器来操纵对象。&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; create table wen(
-&amp;gt; a clob(10KB),
-&amp;gt; b blob (10MB));
用户定义的类型
SQL支持用户两种形式的用户自定义类型。第一种称为独特类型，第二种成为结构化数据类型
可以用create type子句来定义新类型。不能为一种类型的变量赋予另一种类型的值。新创建的类型就可以用作关系属性的类型
SQL提供了drop type 和 alter type子句来删除或修改以前创建过的类型
mysql&amp;gt; create type Dollars as numeric(12,2);
mysql&amp;gt; create type Dollar as numeric(12,2);
create table department(
budget Dollars
);&lt;/p&gt;
&lt;p&gt;//如果不转换的话，Dollars=Dollar会报错
cast(department.Dollars to numeric(12,2);&lt;/p&gt;
&lt;p&gt;在把用户定义类型加入到SQL之前，有一个相似但稍有不同的概念，域，它可以在基本类型上施加完整性约束
域和类型的差别：&lt;/p&gt;
&lt;p&gt;1.在域上，可以声明约束，也可以为域类型变量定义默认或默认值&lt;/p&gt;
&lt;p&gt;2.域不是强类型，一种域类型的值可以被赋给另一种域类型的变量，只要他们基本类型相同&lt;/p&gt;
&lt;p&gt;把check子句用到域上，被声明为来自该域的任何变量都必须满足这个谓词&lt;/p&gt;
&lt;p&gt;constraint salary_value_test子句可选，用来将该约束命名为salary_value_test&lt;/p&gt;
&lt;p&gt;create domain DDollaers as numeric(12,2) not null;&lt;/p&gt;
&lt;p&gt;create domain YearlySalary numeric(8,2)
constrait salary check(value&amp;gt;=29000);
create table 的扩展&lt;/p&gt;
&lt;p&gt;创建与现有的表模式相同的表&lt;/p&gt;
&lt;p&gt;把查询的结果存储成一个新表&lt;/p&gt;
&lt;p&gt;一条用于创建表，另一条用于把查询结果插入到表中&lt;/p&gt;
&lt;p&gt;create table&amp;hellip;as与create view语句非常相似&lt;/p&gt;
&lt;p&gt;区别在于当表被创建时表的内容被加载，但视图总是反应当前查询的结果&lt;/p&gt;
&lt;p&gt;模式，目录和环境&lt;/p&gt;
&lt;p&gt;当代数据库系统提供了三层结构的关系命名机制。最顶层由目录构成，每个目录可以包含模式。诸如关系、视图都包含在模式中&lt;/p&gt;
&lt;p&gt;create schema和drop schema来创建和删除模式。&lt;/p&gt;
&lt;p&gt;4.6 模式的授权
权限包括select、insert、update、delete&lt;/p&gt;
&lt;p&gt;all privileges所有权限可以用作所有权限的简写形式&lt;/p&gt;
&lt;p&gt;一个创建了新关系的用户将自动被授予该关系上的所有权限&lt;/p&gt;
&lt;p&gt;展示当前用户权限&lt;/p&gt;
&lt;p&gt;show grants;
grant用来授予权限&lt;/p&gt;
&lt;p&gt;update可以在关系的所有属性上授予，也可以只在某些属性上授予&lt;/p&gt;
&lt;p&gt;insert也可以指定属性列表，系统将其他属性要么赋予默认值要么赋值为null&lt;/p&gt;
&lt;p&gt;用户名public指系统的所有当前用户和将来用户&lt;/p&gt;
&lt;p&gt;默认情况下，被授予权限的用户和角色无权把此权限授予其他用户/角色&lt;/p&gt;
&lt;p&gt;SQL允许用授予权限的接受者可以进一步把权限授予其他人&lt;/p&gt;
&lt;p&gt;不允许对一个关系的指定元组授权&lt;/p&gt;
&lt;p&gt;远程连接时:&lt;/p&gt;
&lt;p&gt;GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP ON 你的数据库.* TO &amp;lsquo;用户名&amp;rsquo;@&#39;%&#39; identified by &amp;lsquo;密码&amp;rsquo;
使用revoke语句来收回权限&lt;/p&gt;
&lt;p&gt;grant select on department to Amith;&lt;/p&gt;
&lt;p&gt;grant update(no) on department tomith;&lt;/p&gt;
&lt;p&gt;grant select on department to public;&lt;/p&gt;
&lt;p&gt;revoke select on department to Amith;&lt;/p&gt;
&lt;p&gt;revoke update(no) on department tomith;&lt;/p&gt;
&lt;p&gt;revoke select on department to public;
角色&lt;/p&gt;
&lt;p&gt;在数据库中建立一个角色集，可以给角色授予权限，就和给每一个用户授权的方式完全一样&lt;/p&gt;
&lt;p&gt;创建角色&lt;/p&gt;
&lt;p&gt;授权给角色&lt;/p&gt;
&lt;p&gt;角色可以授权给用户，也可以授权给其他角色&lt;/p&gt;
&lt;p&gt;一个用户或一个角色的权限包括：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    所有直接授予用户/角色的权限
    所有授予给用户/角色所拥有角色的权限
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;create role instructor;
grant select on takes to instructor;&lt;/p&gt;
&lt;p&gt;grant dean to Amith;
create role dean;
grant indtructor to dean;
grant dean to Satoshi;
视图的授权。在这个例子中，视图的创建者必须在instructor关系上具有select权限，否则系统会拒绝这样的视图创建请求&lt;/p&gt;
&lt;p&gt;create view geo_instructor as
(
select *
from instructor
);&lt;/p&gt;
&lt;p&gt;模式的授权&lt;/p&gt;
&lt;p&gt;只有模式的拥有则才能执行对模式的修改。&lt;/p&gt;
&lt;p&gt;//允许Amith创建参照department的dept_name的关系
grant references (dept_name) on department to Amith;&lt;/p&gt;
&lt;p&gt;权限的转移，允许权限的接受者将该权限授予给其他用户&lt;/p&gt;
&lt;p&gt;grant select on department to Amith with grant option;
权限的收回&lt;/p&gt;
&lt;p&gt;revoke select on department to Amith restrict;&lt;/p&gt;
&lt;p&gt;revoke select on department to Amith cascade;&lt;/p&gt;
&lt;p&gt;set role me;
granted by current_role;
restrict防止权限的级联收回&lt;/p&gt;
&lt;p&gt;替换成cascade表示需要级联收回，默认需要级联收回。&lt;/p&gt;
&lt;p&gt;授予权限时将授权人设置为一个会话所关联的当前角色，并且当角色不为空时，可在授权语句后加&lt;/p&gt;
&lt;p&gt;收回角色/权限时任然能保持当前角色&lt;/p&gt;
&lt;p&gt;第六章、 形式化关系查询语言
关系代数、元组关系演算、域关系演算&lt;/p&gt;
&lt;p&gt;6.1 关系代数
6.1.1 基本运算
关系代数基本运算：选择、投影、并、集合差、笛卡尔积、更名&lt;/p&gt;
&lt;p&gt;选择运算，一元运算&lt;/p&gt;
&lt;p&gt;选出满足给定谓词的元组，用sigma(σ)来表示，将谓词写作σ的下表&lt;/p&gt;
&lt;p&gt;例如：属于物理系的元组可以这样写&lt;/p&gt;
&lt;p&gt;通常，我们允许在选择谓词中进行比较，使用的是=、≠、&amp;lt;、≤、&amp;gt;、≥&lt;/p&gt;
&lt;p&gt;另外，我们可以用连词将多个谓词合并为一个较大的谓词。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;投影运算&lt;/p&gt;
&lt;p&gt;投影运算是一元运算，它返回作为参数的关系，但把某些属性排除在外。重复行去除&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;关系运算的组合&lt;/p&gt;
&lt;p&gt;例如：找出物理系的所有教师的名字&lt;/p&gt;
&lt;p&gt;并运算&lt;/p&gt;
&lt;p&gt;就是将两个集合并起来。去重&lt;/p&gt;
&lt;p&gt;例如：找出开设在2009年秋季学期或者2010年春季学期或者这两者皆开的所有课程的集合&lt;/p&gt;
&lt;p&gt;另一方面，设r和s是数据库关系或者作为关系代数表达式结果的临时关系。要使r U s有意义，需满足以下两个条件：&lt;/p&gt;
&lt;p&gt;（1）关系r和s必须是同元的，即它们的属性数目必须相同&lt;/p&gt;
&lt;p&gt;（2）对所有的i，r的第i个属性的域必须和s的第i个属性的域相同&lt;/p&gt;
&lt;p&gt;集合差运算&lt;/p&gt;
&lt;p&gt;用 - 表示集合差运算，可以找出在一个关系中而不在另一个关系中的那些元组。&lt;/p&gt;
&lt;p&gt;例如：找出所有开设在2009年秋季学期但是在2010年春季学期不开的课程&lt;/p&gt;
&lt;p&gt;另一方面，设r和s是数据库关系或者作为关系代数表达式结果的临时关系。要使r - s有意义，需满足以下两个条件：&lt;/p&gt;
&lt;p&gt;（1）关系r和s必须是同元的，即它们的属性数目必须相同&lt;/p&gt;
&lt;p&gt;（2）对所有的i，r的第i个属性的域必须和s的第i个属性的域相同&lt;/p&gt;
&lt;p&gt;笛卡尔积运算&lt;/p&gt;
&lt;p&gt;用X表示笛卡尔积，可以将任意两个关系的信息组合在一起。&lt;/p&gt;
&lt;p&gt;更名运算&lt;/p&gt;
&lt;p&gt;关系代数表达式的结果没有可供我们引用的名字，我们可以通过小写希腊字母rho(ρ)表示的更名运算来完成这一任务。&lt;/p&gt;
&lt;p&gt;返回表达式E的结果，并把名字x赋给了它&lt;/p&gt;
&lt;p&gt;返回表达式E的结果，并赋给它名字x，同时将各属性更名为A1，A2，&amp;hellip; ，An&lt;/p&gt;
&lt;p&gt;6.1.2 关系运算的形式化定义
关系代数中基本的表达式是如下二者之一：&lt;/p&gt;
&lt;p&gt;数据库的一个关系
一个常数关系
若E1，E2是关系代数表达式，则一下这些都是关系代数表达式：&lt;/p&gt;
&lt;p&gt;6.1.3 附加的关系代数运算
集合交运算&lt;/p&gt;
&lt;p&gt;例如：在2009年秋季和2010年春季都开设的课程&lt;/p&gt;
&lt;p&gt;集合交运算与集合差运算的关系：&lt;/p&gt;
&lt;p&gt;自然连接运算&lt;/p&gt;
&lt;p&gt;用连接符号来表示&lt;/p&gt;
&lt;p&gt;自然连接运算首先形成它的两个参数的笛卡尔积，然后基于两个关系模式中都出现的属性上的相等性进行选择，最后还要去除重复属性。&lt;/p&gt;
&lt;p&gt;例如：找出所有教师的姓名，连同他们教的所有课程的course_id&lt;/p&gt;
&lt;p&gt;自然连接是可结合的&lt;/p&gt;
&lt;p&gt;theta连接是自然连接的扩展，它使得我们可以把一个选择运算和一个笛卡尔积运算合并为单独的一个运算，即自然连接是选出笛卡尔积中相同的属性，而theta连接是选出笛卡尔积中满足该选择运算的属性。&lt;/p&gt;
&lt;p&gt;赋值运算&lt;/p&gt;
&lt;p&gt;将R x S的结果赋给temp1&lt;/p&gt;
&lt;p&gt;外连接运算&lt;/p&gt;
&lt;p&gt;外连接是连接运算的扩展，可以处理确实的信息。有左外连接、右外连接和全外连接&lt;/p&gt;
&lt;p&gt;左外连接（）：取出左侧关系中所有与右侧关系的任一元组都不匹配的元组，用空值填充所有来自右侧关系的属性，再把产生的元组加到自然连接的结果中。&lt;/p&gt;
&lt;p&gt;右外连接（）：与左外连接相对称&lt;/p&gt;
&lt;p&gt;全外连接（）：既做左外连接又做右外连接，既填充左侧关系中与右侧关系的任一元组都不匹配的元组，又填充右侧关系中与左侧关系的任一元组都不匹配的元组，并把结果都加到连接的结果中。&lt;/p&gt;
&lt;p&gt;6.1.4 扩展的关系代数运算
广义投影&lt;/p&gt;
&lt;p&gt;广义投影允许在投影列表中使用算术运算和字符串函数等来对投影进行扩展。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;聚集&lt;/p&gt;
&lt;p&gt;聚集运算可以用来对值的集合使用聚集函数，例如计算最小值或者求平均值&lt;/p&gt;
&lt;p&gt;聚集函数：输入值的一个汇集，将单一值作为结果返回。比如输入几个数的集合，返回他们的和作为结果&lt;/p&gt;
&lt;p&gt;将distinct添加在函数名后，可以去除重复&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;元组关系演算&lt;/p&gt;
&lt;p&gt;元组关系演算表达式具有如下形式：&lt;/p&gt;
&lt;p&gt;其中P是一个公式，公示中可以出现多个元组变量。如果元组不被“存在”或“任意”修饰，则称为自由变量。&lt;/p&gt;
&lt;p&gt;域关系演算&lt;/p&gt;
&lt;p&gt;域关系演算是从属性域中取值的域变量，而不是整个元组的值。&lt;/p&gt;
&lt;p&gt;第七章、数据库设计和E-R模型
7.1 设计过程概览
概念设计：E-R图创建&lt;/p&gt;
&lt;p&gt;逻辑设计：E-R模型映射到关系模式&lt;/p&gt;
&lt;p&gt;物理设计。&lt;/p&gt;
&lt;p&gt;设计一个数据库模式的时候，必须避免的两个主要的缺陷&lt;/p&gt;
&lt;p&gt;（1）冗余：一个不好的设计可能会重复信息。信息的冗余表达的最大问题是当对一条信息进行更新，但没有将这条信息的所有拷贝都更新时这条信息的拷贝会变得不一致。&lt;/p&gt;
&lt;p&gt;（2）不完整：如字面意思，一个不好的设计可能会使得企事业机构的某些方面难于甚至无法建模。&lt;/p&gt;
&lt;p&gt;7.2 E-R模型
实体-联系（E-R）数据模型的提出旨在方便数据库的设计，它是通过允许定义代表数据库全局逻辑结构的企业模式实现的。&lt;/p&gt;
&lt;p&gt;实体：是现实世界中可区别于所有其他对象的一个“事物”或“对象”。&lt;/p&gt;
&lt;p&gt;实体集：是相同类型即具有相同性质（或属性）的一个实体集合。例如一所给定大学的所有教师的集合可定义为实体集instructor。实体集不必互不相交&lt;/p&gt;
&lt;p&gt;实体集的外延：属于实体集的实体的实际集合&lt;/p&gt;
&lt;p&gt;联系：是指多个实体间的相互关联，也可以具有描述性属性&lt;/p&gt;
&lt;p&gt;联系集：是相同类型联系的集合。&lt;/p&gt;
&lt;p&gt;参与：实体集之间的关联称为参与。也就是说，实体集E1,E2,&amp;hellip;,En参与联系集R&lt;/p&gt;
&lt;p&gt;角色：实体在联系中扮演的功能称为实体的角色。&lt;/p&gt;
&lt;p&gt;属性：实体集的属性是将实体集映射到域的函数。由于一个实体集可能有多个属性，因此每个实体可以用一组（属性，数据值）对来表示，实体集的每个属性对应一个这样的对。&lt;/p&gt;
&lt;p&gt;联系集的度：参与联系集的实体集的数目。&lt;/p&gt;
&lt;p&gt;给定的联系集中的联系实例必须是由其参与实体唯一标识的。&lt;/p&gt;
&lt;p&gt;相同的 实体集可能会参与到多于一个联系集中&lt;/p&gt;
&lt;p&gt;每个属性都有一个可取值的集合，称为该属性的域，或则值集&lt;/p&gt;
&lt;p&gt;E-R模型中的属性可以按照如下的属性类型来划分&lt;/p&gt;
&lt;p&gt;（1）简单和复合属性：简单属性指不能划分为更小的部分；复合属性指可以再划分为更小的部分（即其他属性）。例如属性name可设计为一个包含first_name、middle_initial和last_name的复合属性&lt;/p&gt;
&lt;p&gt;（2）单值和多值属性：我们直接用例子说明：对某个特定的学生实体而言，student_ID属性只对应于一个学生ID，这样的属性为单值；在教师实体中，每个教师可以有0个、1个或多个电话号码，这个phone_number属性就是多值的。{}&lt;/p&gt;
&lt;p&gt;（3）派生属性：这类属性的值可以从别的相关属性或实体派生出来。派生属性的值不存储，在需要的时候计算出来&lt;/p&gt;
&lt;p&gt;7.3 约束
7.3.1 映射基数
映射基数：表示一个实体通过一个联系集能关联的实体的个数。&lt;/p&gt;
&lt;p&gt;（1）一对一：A中的一个实体至多与B中的一个实体相关联，并且B中的一个实体也至多与A中的一个实体相关联&lt;/p&gt;
&lt;p&gt;（2）一对多：A中的一个实体至多与B中的零个或多个实体相关联，而B中的一个实体也至多与A中的一个实体相关联&lt;/p&gt;
&lt;p&gt;（3）多对一：A中的一个实体至多与B中的一个实体相关联，而B中的一个实体可以与A中的零个或多个实体相关联&lt;/p&gt;
&lt;p&gt;（4）多对多：A中的一个实体至多与B中的零个或多个实体相关联，而且B中的一个实体也可以与A中的零个或多个实体相关联&lt;/p&gt;
&lt;p&gt;7.3.2 参与约束
如果实体集E中的每个实体都参与到联系集的至少一个联系之中，实体集E在联系集R中的参与称为全部的。如果实体集E中只有部分实体参与到联系集的之中，实体集E在联系集R中的参与称为部分的。&lt;/p&gt;
&lt;p&gt;7.3.3 码more
关系模式中的超码、候选码、主码的概念同样适用于实体集&lt;/p&gt;
&lt;p&gt;7.5 实体-联系图
7.5.1 基本结构
分成两部分的矩形：代表实体集，上面的第一部分为实体集的名字，下面的第二部分包含实体集中所有属性的名字&lt;/p&gt;
&lt;p&gt;菱形：代表联系集&lt;/p&gt;
&lt;p&gt;未分割的矩形：代表联系集的属性，构成主码的属性以下划线表明&lt;/p&gt;
&lt;p&gt;线段：将实体集连接到联系集&lt;/p&gt;
&lt;p&gt;虚线：将联系集属性连接到联系集&lt;/p&gt;
&lt;p&gt;双线：显示实体在联系集中的参与度&lt;/p&gt;
&lt;p&gt;双菱形：代表连接到弱实体集的标志性联系集&lt;/p&gt;
&lt;p&gt;联系集和实体集之间也有映射基数，意思同约束中的映射技术，联系集为实体A，实体集为实体B&lt;/p&gt;
&lt;p&gt;约束的方式有两种：&lt;/p&gt;
&lt;p&gt;一、&lt;/p&gt;
&lt;p&gt;二、用l..h的形式表示一个关联的最小和最大的映射基数&lt;/p&gt;
&lt;p&gt;7.5.3 复杂的属性
表示方法：&lt;/p&gt;
&lt;p&gt;name、address、street为复合属性&lt;/p&gt;
&lt;p&gt;{phone_number}为多值属性&lt;/p&gt;
&lt;p&gt;{age()}为派生属性age&lt;/p&gt;
&lt;p&gt;7.5.4 角色
通过在菱形和矩形之间的连线上进行标注来表示角色，例如下图中的course_id和prereq_id&lt;/p&gt;
&lt;p&gt;7.5.5 非二元的联系集
我们至多允许一个箭头&lt;/p&gt;
&lt;p&gt;7.5.6 弱实体集
弱实体集：没有足够的属性以形成主码的实体集称作弱实体集&lt;/p&gt;
&lt;p&gt;强实体集：有主码的实体集称作强实体集&lt;/p&gt;
&lt;p&gt;弱实体集必须与另一个称作标识或属主实体集的实体集关联才能有意义。每个弱实体必须和一个标识实体关联；也就是说，弱实体集存在依赖于标识实体集。我们称标识实体集拥有它所标识的弱实体集。将弱实体集与其标识实体集相联的联系称为标识性联系。&lt;/p&gt;
&lt;p&gt;标识性联系是从弱实体集到强实体集多对一的，并且弱实体集在联系中的参与是全部的。标识性联系集不应该有任何描述性属性，因为这种属性中的任意一个都可以与弱实体集相关联。&lt;/p&gt;
&lt;p&gt;分辨符：虽然弱实体集没有主码，但是我们仍然需要区分依赖于特定强实体集的弱实体集中的实体的方法。弱实体集的分辨符是使我们进行这种区分的属性集合，也称为该实体集的部分码。&lt;/p&gt;
&lt;p&gt;弱实体集的主码由标识实体集的主码加上弱实体集的分辨符构成。&lt;/p&gt;
&lt;p&gt;图形表示：&lt;/p&gt;
&lt;p&gt;弱实体集的分辨符以虚下划线标明，而不是实线。&lt;/p&gt;
&lt;p&gt;关联弱关系集和标识性强实体集的联系集用双菱形表示。&lt;/p&gt;
&lt;p&gt;弱实体集可以参与标识性联系意外的联系。弱实体集可以作为属主与另一个弱实体集参与一个标识性联系。一个弱实体集也可能与不止一个标识实体集相关联。这样，一个特定的弱实体集将被一个实体的组合标识，其中每个标识实体集有一个实体在组合中。弱实体集的主码可以由标识实体集的主码加上弱实体集的分辨符构成。&lt;/p&gt;
&lt;p&gt;如果弱实体集属性少，直接归并到实体集中。否则自成一家。&lt;/p&gt;
&lt;p&gt;7.6 转换为关系模式
7.6.1 具有简单属性的强实体集的表示
设E是只具有简单描述性属性a1,a2,&amp;hellip;,an的强实体集。我们用具有n个不同属性的模式E来表示这个实体集。该模式的关系中的每个远足同实体集E的一个实体相对应。&lt;/p&gt;
&lt;p&gt;7.6.2 具有复杂属性的强实体集的表示
这个就比上面的情况复杂一点，我们通过为每个子属性创建一个单独的和属性来处理符合属性，我们并不为复合属性自身创建一个单独的属性。&lt;/p&gt;
&lt;p&gt;例如instructor实体集，里面有复合属性name，为instructor生成的末世包括属性first_name、middle_initial和last_name；没有单独的属性或末世表示name。其他属性类似。&lt;/p&gt;
&lt;p&gt;对于一个多值属性M，构建关系模式R，该模式包含一个对应与M的属性A，以及对应于M所在的实体集或联系集的属性。&lt;/p&gt;
&lt;p&gt;在一个实体集只有两个属性的情况下——一个主码B和多值属性M——该实体集的关系模式只含有一个属性，即主码属性B，可以删除这个关系，同时保留属性B和对应M的属性A的关系模式。&lt;/p&gt;
&lt;p&gt;7.6.3 弱实体集的表示
设A是具有属性a1,a2,&amp;hellip;,am的弱实体集，设B是A所依赖的强实体集，设B的主码包括属性b1,b2,&amp;hellip;,bn。我们用名为A的关系模式表示实体集A，该模式的每个属性对应以下集合中的一个成员：&lt;/p&gt;
&lt;p&gt;所以A的模式的属性有：A的属性和B的主码。&lt;/p&gt;
&lt;p&gt;该模式的主码由实体集B的主码和A的分辨符组成。&lt;/p&gt;
&lt;p&gt;7.6.4 联系的表示
若实体间联系是1:1，可以在两个实体类型转换成的两个关系模式中任意一个关系模式的属性中加入另一个关系模式的键（作为外键）和联系类型的属性。
若实体间联系是1:N，则在N端实体类型转换成的关系模式中加入1端实体类型的键（作为外键）和联系类型的属性。
若实体间联系是M:N，则将联系类型也转换成关系模式，其属性为两端实体类型的键（作为外键）加上联系类型的属性，而键为两端实体键的组合
7.6.5 模式的合并
考虑实体集A，B和联系集AB。假设A在该联系中的参与是全部的，那么我们可以将A和AB合并称单个包含两个模式所有属性的并集的模式。&lt;/p&gt;
&lt;p&gt;8.1 好的关系设计的特点
有损分解：分解关系的时候损失了信息。&lt;/p&gt;
&lt;p&gt;无损分解：分解关系的时候没有损失了信息。&lt;/p&gt;
&lt;p&gt;8.2 原子域和第一范式
第一范式（1NF）&lt;/p&gt;
&lt;p&gt;如果某个域的元素被认为是不可再分的单元，那么这个域就是原子的(atomic)。如果一个关系模式R的所有的属性域都是原子的，我们称关系模式R属于第一范式(first normal form, 1NF)。&lt;/p&gt;
&lt;p&gt;8.3 使用函数依赖进行分解
8.3.1 码和函数依赖
设R(U)是属性集U上的关系模式，α,β含于 U， r是R(U) 上的任意一个关系，如果成立&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   对于r中所有元组对t , s ∈ r，若t[α] = s[]，则t[β] = s[β]

   那么称“α函数决定β”，或“β函数依赖于α”，记作αβ

   称α为决定因素，β为被决定因素。说该函数依赖在关系模式R(U)上成立
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;平凡函数依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   如果αβ，但β不含于α，则称其为非平凡的函数依赖，否则(即β含于α)称为平凡(trivial)的函数依赖。如(sno，sname)sname是平凡的函数依赖。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8.3.2 范式
范式是对关系的不同数据依赖程度的要求。通过模式分解将一个低级范式转换为若干个高级范式的过程称作规范化。
1NF&lt;/p&gt;
&lt;p&gt;关系中每一分量不可再分。即不能以集合、序列等作为属性值。
2NF&lt;/p&gt;
&lt;p&gt;若R∈1NF，且每个属性满足下列准则之一：&lt;/p&gt;
&lt;p&gt;它出现在一个候选码中&lt;/p&gt;
&lt;p&gt;它没有部分依赖于一个候选码，则称R∈2NF。&lt;/p&gt;
&lt;p&gt;2NF消除了非主属性对码的部分依赖.
3NF&lt;/p&gt;
&lt;p&gt;关系模式R&amp;lt; U , F &amp;gt;中，F+中所有函数依赖αβ ，至少有以下之一成立 ：&lt;/p&gt;
&lt;p&gt;① αβ是平凡的函数依赖；&lt;/p&gt;
&lt;p&gt;② α是超码；&lt;/p&gt;
&lt;p&gt;③  β-α的每一个属性A都包含在R的候选码中，则称R∈3NF。&lt;/p&gt;
&lt;p&gt;3NF消除了非主属性对码的传递依赖。&lt;/p&gt;
&lt;p&gt;作为判断3NF时的一种优化，可以只考虑F上的函数依赖，而不是F+,也可以分解F上的函数依赖，让它们的右半部只包含一个属性，并用这个结果代替F。&lt;/p&gt;
&lt;p&gt;3NF的判断被证明是无法求解的，是NP问题。
BCNF&lt;/p&gt;
&lt;p&gt;关系模式R&amp;lt; U , F &amp;gt;中，所有的形如αβ的函数依赖（ α∈U，β∈U ），下面至少有一个成立：&lt;/p&gt;
&lt;p&gt;① αβ是平凡的函数依赖；&lt;/p&gt;
&lt;p&gt;2.α是模式R的一个超码，则称R∈BCNF。&lt;/p&gt;
&lt;p&gt;如SPC ∉ BCNF，因为tnocno，而tno不是超码。&lt;/p&gt;
&lt;p&gt;改造：将S分解为：（sno，tno），（tno，cno）。&lt;/p&gt;
&lt;p&gt;BCNF分解：&lt;/p&gt;
&lt;p&gt;我们对函数依赖进行数据库设计的目标：&lt;/p&gt;
&lt;p&gt;无损
BDNF
保持依赖
无损分解：&lt;/p&gt;
&lt;p&gt;8.4 函数依赖理论
被F所逻辑蕴涵的函数依赖的全体所构成的集合称作F的闭包。
Armstrong公理系统&lt;/p&gt;
&lt;p&gt;各希腊字母都为属性集&lt;/p&gt;
&lt;p&gt;自反律：若β含于α，则αβ&lt;/p&gt;
&lt;p&gt;增补率：若αβ，则αγβγ&lt;/p&gt;
&lt;p&gt;传递率：若αβ，βγ，则αγ&lt;/p&gt;
&lt;p&gt;合并率：若αβ，αγ，则αβγ&lt;/p&gt;
&lt;p&gt;分解率：若αβγ，则αβ，αγ&lt;/p&gt;
&lt;p&gt;伪传递率：若αβ，γβδ，则γαδ&lt;/p&gt;
&lt;p&gt;属性集的闭包&lt;/p&gt;
&lt;p&gt;令α为属性集，将函数依赖集F下被α函数确定的所有属性的集合称作F下α的闭包，记作α+&lt;/p&gt;
&lt;p&gt;α+= {A |αA能由F根据Armstrong公理导出}。可以求候选码&lt;/p&gt;
&lt;p&gt;范式是对关系的不同数据依赖程度的要求。通过模式分解将一个低级范式转换为若干个高级范式的过程称作规范化。
1NF&lt;/p&gt;
&lt;p&gt;关系中每一分量不可再分。即不能以集合、序列等作为属性值。
2NF&lt;/p&gt;
&lt;p&gt;若R∈1NF，且每个属性满足下列准则之一：&lt;/p&gt;
&lt;p&gt;它出现在一个候选码中&lt;/p&gt;
&lt;p&gt;它没有部分依赖于一个候选码，则称R∈2NF。&lt;/p&gt;
&lt;p&gt;2NF消除了非主属性对码的部分依赖.
3NF&lt;/p&gt;
&lt;p&gt;关系模式R&amp;lt; U , F &amp;gt;中，F+中所有函数依赖αàβ ，至少有以下之一成立 ：&lt;/p&gt;
&lt;p&gt;① αàβ是平凡的函数依赖；&lt;/p&gt;
&lt;p&gt;② α是超码；&lt;/p&gt;
&lt;p&gt;③  β-α的每一个属性A都包含在R的候选码中，则称R∈3NF。&lt;/p&gt;
&lt;p&gt;3NF消除了非主属性对码的传递依赖。&lt;/p&gt;
&lt;p&gt;作为判断3NF时的一种优化，可以只考虑F上的函数依赖，而不是F+,也可以分解F上的函数依赖，让它们的右半部只包含一个属性，并用这个结果代替F。&lt;/p&gt;
&lt;p&gt;3NF的判断被证明是无法求解的，是NP问题。
BCNF&lt;/p&gt;
&lt;p&gt;关系模式R&amp;lt; U , F &amp;gt;中，所有的形如αàβ的函数依赖（ α∈U，β∈U ），下面至少有一个成立：&lt;/p&gt;
&lt;p&gt;1.αàβ是平凡的函数依赖，&lt;/p&gt;
&lt;p&gt;2.α是模式R的一个超码，则称R∈BCNF。&lt;/p&gt;
&lt;p&gt;如SPC ∉ BCNF，因为tnoàcno，而tno不是超码。&lt;/p&gt;
&lt;p&gt;改造：将S分解为：（sno，tno），（tno，cno）。
多值依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   对称性，函数依赖是多值依赖的特例，传递性
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数依赖好多值依赖区别&lt;/p&gt;
&lt;p&gt;函数依赖规定某些元组不能出现在关系中，也称为相等产生依赖。&lt;/p&gt;
&lt;p&gt;多值依赖要求某种形式的其它元组必须在关系中，称为元组产生依赖。
闭包&lt;/p&gt;
&lt;p&gt;令D表示函数依赖和多值依赖的集合，D的闭包D+是由D逻辑蕴涵的所有函数依赖和多值依赖的集合。
4NF&lt;/p&gt;
&lt;p&gt;函数依赖和多值依赖集为D的关系模式R属于4NF的条件是：对于所有D+中形如： αààβ的多值依赖（其中α包含于R∧β包含于R），至少有以下条件之一成立：&lt;/p&gt;
&lt;p&gt;1.αàà β是一个平凡的多值依赖；&lt;/p&gt;
&lt;p&gt;2.α是模式R的超码，则称R∈4NF。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   如关系模式TEACH，cnoààtno，cnoààbno，码为(cno, tno, bno)，所以CTB∉4NF。改造：将CTB分解为CT（cno，tno），CB（cno，bno），在分解后的关系中分量为Ci的元组共有m + n个
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4NF的本质&lt;/p&gt;
&lt;p&gt;(在只考虑函数和多值依赖的前提下)，4NF只讲一件事，非码的多值决定关系讲述了另外一件事。&lt;/p&gt;
&lt;p&gt;R(cno,bno,tno)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                cno→→bno

                cno→→tno

   R讲述了(cno,bno)和(cno,tno)两件事。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有效且完备的公理系统&lt;/p&gt;
&lt;p&gt;范式之间的关系&lt;/p&gt;
&lt;p&gt;1NF：数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。&lt;/p&gt;
&lt;p&gt;2NF：1NF的基础上，非码属性必须完全依赖于码。在1NF基础上消除非主属性对主码的部分函数依赖。&lt;/p&gt;
&lt;p&gt;3NF：在1NF基础上，任何非主属性不依赖于其它非主属性。在2NF基础上消除传递依赖。&lt;/p&gt;
&lt;p&gt;BCNF：在1NF基础上，任何非主属性不能对主键子集依赖，在3NF基础上消除对主码子集的依赖。&lt;/p&gt;
&lt;p&gt;4NF：在多值依赖的视角评价关系模式。
解除规范化&lt;/p&gt;
&lt;p&gt;把一个规范化的模式变成非规范化的过程。目的：用于调整系统的性能&lt;/p&gt;
&lt;p&gt;第十二章、事务管理
事务是作为单个逻辑工作单元执行的一系列数据库操作。这些操作要么都做，要么都不做，是一个不可分割的工作单位&lt;/p&gt;
&lt;p&gt;12.1 事务概念
事务是访问并可能更新各种数据项的一个程序执行单元。&lt;/p&gt;
&lt;p&gt;事物特性（ACID）&lt;/p&gt;
&lt;p&gt;原子性(Atomicity)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   事务中包含的所有操作要么全做，要么全不做。原子性由恢复系统实现。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一致性(Consistency)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   事务的隔离执行必须保证数据库的一致性。事务开始前，数据库处于一致性的状态；事务结束后，数据库必须仍处于一致性状态；事务的执行过程中可以暂时的不一致。数据库的一致性状态由用户来负责，由并发控制系统实现。

    如银行转账，转账前后两个帐户金额之和应保持不变。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;隔离性(Isolation)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   系统必须保证事务不受其它并发执行事务的影响。对任何一对事务T1，T2，在T1看来，T2要么在T1开始之前已经结束，要么在T1完成之后再开始执行。隔离性通过并发控制系统实现。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;持久性(Durability)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   一个事务一旦提交之后，它对数据库的影响必须是永久的。系统发生故障不能改变事务的持久性。持久性通过恢复系统实现。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于故障，系统的状态不再反应数据库本应描述的现实世界的真实状态，我们把这种状态称为不一致状态。
恢复系统保证原子性和持久性。&lt;/p&gt;
&lt;p&gt;并发控制系统保证隔离性和一致性。&lt;/p&gt;
&lt;p&gt;12.2 事务的原子性和持久性
一旦事务已提交，我们不能通过中止他来撤销其造成的影响，撤销已提交事务造成的影响的唯一方法就是执行一个补偿事务。书写一个补偿事务的责任留给用户&lt;/p&gt;
&lt;p&gt;事务的几种状态：
1、活跃的：初始状态，事务开始执行时处于这个状态
2、部分提交的：最后一条语句执行后。可能发生硬件故障。当数据库往磁盘上写了足够的信息，确保即使发生硬件故障更新也能在系统重启时创建。当最后一条这样的信息写完之后，事务进入提交状态。
3、失败的：发现正常的执行不能继续后
4、中止的：事务回滚并且数据库恢复到事务执行之前的状态后
5、提交的：成功执行后
状态转换图如下：&lt;/p&gt;
&lt;p&gt;如果事务是提交的或则终止的，我们称事务是已经结束的&lt;/p&gt;
&lt;p&gt;事务进入中止状态后，系统这时候有两种选择：
1、重启事务：当且仅当中止是由硬件错误造成的或者不是事物本身逻辑所产生的错误时。重启的事务会被看成一个新的事务
2、杀死事务：如果中止是由事务内部逻辑错误导致的那么事务就会被杀死。&lt;/p&gt;
&lt;p&gt;当处理可见的外部写，比如写到屏幕上一定要小心。大多数系统只允许在操作在事务进入提交状态后发生。&lt;/p&gt;
&lt;p&gt;12.3 事务的隔离性
两条很好的理由允许并发：&lt;/p&gt;
&lt;p&gt;提高吞吐量和资源利用率
减少等待时间
事务调度&lt;/p&gt;
&lt;p&gt;事务的执行顺序称为一个调度(schedule)，表示事务的指令在系统中执行的时间顺序。
串行调度：属于同一事务的指令在调度中紧挨在一起&lt;/p&gt;
&lt;p&gt;可串行化调度：并发执行中，保证所执行的任何调度的效果与没有并发执行的调度效果一样。这样可以保证数据库的一致性。调度应该在某种意义上等价与一个串行调度。这种调度称为可串行化调度。&lt;/p&gt;
&lt;p&gt;12.4 可串行化
串行调度是可串行化的。&lt;/p&gt;
&lt;p&gt;冲突指令：&lt;/p&gt;
&lt;p&gt;当两条指令是不同事务在相同数据项上的操作，并且其中至少有一个是write指令时，则称这两条指令是冲突的。&lt;/p&gt;
&lt;p&gt;冲突等价：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   如果调度S可以经过一系列非冲突指令交换转换成调度S&#39;，则称调度S与S&#39;是冲突等价的(conflictequivalent)。不是所有的串行调度都冲突等价。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;冲突可串行化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   当一个调度S与一个串行调度冲突等价时，则称该调度S是冲突可串行化的
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;12.5 可恢复性
一个事务失败了，应该能够撤消该事务对数据库的影响。如果有其它事务读取了失败事务写入的数据，则该事务也应该撤消。&lt;/p&gt;
&lt;p&gt;可恢复调度：&lt;/p&gt;
&lt;p&gt;对于每对事务T1与T2，如果T2读取了T1所写的数据，则T1必须先于T2提交。&lt;/p&gt;
&lt;p&gt;级联调度：&lt;/p&gt;
&lt;p&gt;由于一个事务故障而导致一系列事务回滚。&lt;/p&gt;
&lt;p&gt;无级联调度：&lt;/p&gt;
&lt;p&gt;对于每对事务T1与T2，如果T2读取了T1所写的数据，则T1必须在T2读取之前提交。&lt;/p&gt;
&lt;p&gt;&amp;lt;注&amp;gt;无级联调度必是可恢复调度&lt;/p&gt;
&lt;p&gt;并发操作带来的数据不一致性
（1）丢失修改（Lost Update）
两个事务T1和T2读入同一数据并修改，T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失。
（2）不可重复读（Non-repeatable Read）
不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。&lt;/p&gt;
&lt;p&gt;不可重复读包括三种情况：&lt;/p&gt;
&lt;p&gt;事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时，得到与前一次不同的值
事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录神秘地消失了。
事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。
后两种不可重复读有时也称为幻影现象（Phantom Row）
（3）读“脏”数据（Dirty Read）
读“脏”数据是指：
事务T1修改某一数据，并将其写回磁盘
事务T2读取同一数据后，T1由于某种原因被撤销
这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致
T2读到的数据就为“脏”数据，即不正确的数据。&lt;/p&gt;
&lt;p&gt;事务隔离性&lt;/p&gt;
&lt;p&gt;按照隔离级别从低到高的顺序：&lt;/p&gt;
&lt;p&gt;未提交读：允许读取未提交数据。（当事务A更新某条数据时，不容许其他事务来更新该数据，但可以读取。）&lt;/p&gt;
&lt;p&gt;已提交读：只允许读取已提交数据，但不要求可重复读。（当事务A更新某条数据时，不容许其他事务进行任何操作包括读取，但事务A读取时，其他事务可以进行读取、更新。）&lt;/p&gt;
&lt;p&gt;可重复读：只允许读取已提交数据，而且一个事务两次读取一个数据项期间，其他事务不得更新该数据，但是该事务不要求与其他事务可串行化。&lt;/p&gt;
&lt;p&gt;可串行化：保证可串行化调度。&lt;/p&gt;
&lt;p&gt;以上所有隔离级别都不允许脏写，即如果一个数据项已经被另外一个尚未提交的事务写入，则不允许对该数据项执行写操作。&lt;/p&gt;
&lt;p&gt;12.6 并发控制
并发控制机制的任务：对并发操作进行正确调度、保证事务的隔离性、保证数据库的一致性。&lt;/p&gt;
&lt;p&gt;12.6.1 基于锁的协议
基本封锁类型：&lt;/p&gt;
&lt;p&gt;排它锁（exclusive lock，简记为X锁）
共享锁（Share lock，简记为S锁）
共享锁&lt;/p&gt;
&lt;p&gt;共享锁又称为读锁。若事务T对数据对象Q加上S锁，事务T可读但不能写Q，其它事务只能再对Q加S锁，而不能加X锁，直到T释放Q上的S锁。
排它锁&lt;/p&gt;
&lt;p&gt;排它锁又称为写锁。若事务T对数据对象Q加上X锁，则事务T既可以读又可以写Q，其它任何事务都不能再对Q加任何类型的锁，直到T释放A上的锁。&lt;/p&gt;
&lt;p&gt;假设对于某对象，事物j请求A型锁，事物i拥有B型锁。如果事物j可以立刻得到A型锁。则称A与B锁是相容的。&lt;/p&gt;
&lt;p&gt;让事务在对数据项最后一次访问后立即释放锁也未必是可取的，因为可能不能保证可串行化。
死锁：一种哪个事物都不能正常执行的状态。当死锁发生时，必须回滚两个事务中的一个。&lt;/p&gt;
&lt;p&gt;饥饿/饿死：&lt;/p&gt;
&lt;p&gt;不断出现的申请并获得S锁的事务，使申请X锁的事务一直处在等待状态。&lt;/p&gt;
&lt;p&gt;饥饿的防止：&lt;/p&gt;
&lt;p&gt;对申请S锁的事务，如果有先于该事务且等待的加X锁的事务，令申请S锁的事务等待。&lt;/p&gt;
&lt;p&gt;12.6.2 保证可串行性的封锁协议（两阶段封锁协议）
定义：每个事务分两个阶段提出加锁和解锁申请。&lt;/p&gt;
&lt;p&gt;增长阶段(growing phase)：事务可以获得锁，但不能释放锁。&lt;/p&gt;
&lt;p&gt;缩减阶段(shrinking phase)：事务可以释放锁，但不能获得新锁。&lt;/p&gt;
&lt;p&gt;封锁点(lock point)：事务最后加锁的位置，称为事务的封锁点, 记作Lp(T)。&lt;/p&gt;
&lt;p&gt;并行执行的所有事务均遵守两段锁协议，则对这些事务的所有并行调度策略都是可串行化的。所有遵守两段锁协议的事务，其并行执行的结果一定是正确的。&lt;/p&gt;
&lt;p&gt;事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。可串行化的调度中，不一定所有事务都必须符合两段锁协议。&lt;/p&gt;
&lt;p&gt;两阶段封锁协议不保证不会发生死锁。&lt;/p&gt;
&lt;p&gt;严格两阶段封锁协议：除了要求封锁是两阶段之外，还要求事务持有的所有排他锁必须在事务结束后，方可释放。&lt;/p&gt;
&lt;p&gt;强两阶段封锁协议：事务提交之前，不得释放任何锁。在强两阶段封锁协议下，事务可以按其结束的顺序串行化。&lt;/p&gt;
&lt;p&gt;12.6.3 多粒度封锁的必要性
事务访问数据的粒度不同&lt;/p&gt;
&lt;p&gt;DB、Table、Tuple、…&lt;/p&gt;
&lt;p&gt;单一封锁粒度的问题&lt;/p&gt;
&lt;p&gt;封锁粒度大：并发性低&lt;/p&gt;
&lt;p&gt;封锁粒度小：访问大粒度数据加锁量巨大&lt;/p&gt;
&lt;p&gt;多粒度封锁：根据访问数据的粒度，确定封锁的粒度。以求加锁量有限，并可获得最大的并发性&lt;/p&gt;
&lt;p&gt;多粒度封锁的基本原则：&lt;/p&gt;
&lt;p&gt;大粒度数据由小粒度数据组成；&lt;/p&gt;
&lt;p&gt;允许对不同粒度数据进行封锁；&lt;/p&gt;
&lt;p&gt;事务对大粒度数据加锁，隐含地对组成大粒度数据的所有小粒度数据加锁。&lt;/p&gt;
&lt;p&gt;多粒度层次结构&lt;/p&gt;
&lt;p&gt;多粒度层次树，子节点表示的数据是父节点表示数据的一部分。&lt;/p&gt;
&lt;p&gt;意向锁(intention lock mode)&lt;/p&gt;
&lt;p&gt;如果一个节点加上了意向锁，则意味着要在树的较低层进行显示加锁。&lt;/p&gt;
&lt;p&gt;在一个节点显式加锁之前，该结点的全部祖先均加上了意向锁。&lt;/p&gt;
&lt;p&gt;事务判定是否能够成功地给一个结点加锁时，不必搜索整棵树。&lt;/p&gt;
&lt;p&gt;多粒度封锁相容矩阵&lt;/p&gt;
&lt;p&gt;共享意向锁（IS）/排他意向锁（IX）/共享排他意向锁（SIX）&lt;/p&gt;
&lt;p&gt;多粒度封锁协议：&lt;/p&gt;
&lt;p&gt;遵从锁的相容矩阵；
根结点必须首先加锁，可以加任何类型的锁；
仅当Ti对Q的父结点持有IX或IS锁时，Ti对于结点Q加S或者Is锁；
仅当Ti对Q的父结点持有IX或SIX锁时， Ti对于结点Q加X、SIX、IX锁；
仅当Ti未曾对任何结点解锁时，Ti可以对结点加锁（两阶段的）；
仅当Ti当前不持有Q的子节点的锁时，Ti可以对节点Q解锁。
特点：&lt;/p&gt;
&lt;p&gt;增加了并发行，减少了锁开销。&lt;/p&gt;
&lt;p&gt;适应范围：&lt;/p&gt;
&lt;p&gt;只存取几个数据项的短事务，&lt;/p&gt;
&lt;p&gt;由整个文件或一组文件形成报表的长事务。&lt;/p&gt;
&lt;p&gt;释放顺序：多粒度协议要求加锁按照自顶向下的顺序，而锁的释放按照自底向上的顺序&lt;/p&gt;
&lt;p&gt;12.7 恢复系统
12.7.1 故障分类
1.事务内部的故障:
（1）有的是可以通过事务程序本身发现的。
（2）有的是非预期的，不能由事务程序处理的。
事务内部更多的故障是非预期的，是不能由应用程序处理的
（1）运算溢出 逻辑错误
（2）并发事务发生死锁而被选中撤销该事务 系统错误
（3）违反了某些完整性限制而被终止等 逻辑错误
以后，事务故障仅指这类非预期的故障
2.系统崩溃
1、系统故障
称为软故障，是指造成系统停止运转的任何事件，使得系统要重新启动。
（1）整个系统的正常运行突然被破坏
（2）所有正在运行的事务都非正常终止
（3）不破坏数据库
（4）内存中数据库缓冲区的信息全部丢失
2、系统故障的常见原因
（1）特定类型的硬件错误（如CPU故障）
（2）操作系统故障
（3）数据库管理系统代码错误
（4）系统断电&lt;/p&gt;
&lt;p&gt;3.磁盘故障
称为硬故障，指外存故障
（1）磁盘损坏
（2）磁头碰撞
（3）瞬时强磁场干扰
介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务
介质故障比前两类故障的可能性小得多，但破坏性大得多&lt;/p&gt;
&lt;p&gt;我们把存储器分成3类：非易失性存储器、易失性存储器、稳定存储器
各类故障，对数据库的影响有两种可能性
一是数据库本身被破坏
二是数据库没有被破坏，但数据可能不正确，这是由于事务的运行被非正常终止造成的。&lt;/p&gt;
&lt;p&gt;恢复算法两部分：&lt;/p&gt;
&lt;p&gt;在正常事务处理时采取措施，保证有足够的信息可用于故障恢复
故障发生后采取措施，将数据库内容恢复到某个保证数据库ACID的状态。
12.7.2 数据访问
磁盘中的块：物理块。主存中的块：缓冲块。内存中临时用来存放块的区域：磁盘缓存区。&lt;/p&gt;
&lt;p&gt;缓冲块最终被写道磁盘上，要么是应为缓冲区管理器用于其它用途，要么是因为数据库系统希望将B的变化映射到磁盘上。后一种称为数据库系统对缓冲块强制输出。&lt;/p&gt;
&lt;p&gt;12.7.3  恢复和原子性
（1）恢复操作的基本原理：冗余
利用存储在系统别处的冗余数据来重建数据库中已被破坏或不正确的那部分数据
（2）恢复的实现技术：复杂
一个大型数据库产品，恢复子系统的代码要占全部代码的10%以上
恢复机制涉及的关键问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何建立冗余数据
数据转储（backup）：转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程
登记日志文件（logging）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2.转储方法&lt;/p&gt;
&lt;p&gt;静态转储
在系统中无运行事务时进行的转储操作&lt;/p&gt;
&lt;p&gt;动态转储
转储操作与用户事务并发进行&lt;/p&gt;
&lt;p&gt;海量转储: 每次转储全部数据库
增量转储: 只转储上次转储后更新过的数据
日志文件(log file)：是用来记录事务对数据库的更新操作的文件
以记录为单位的日志文件，每条日志记录的内容：&lt;/p&gt;
&lt;p&gt;事务标识（标明是哪个事务）
操作类型（插入、删除或修改）
操作对象（记录ID、Block NO.）
更新前数据的旧值（对插入操作而言，此项为空值）
更新后数据的新值（对删除操作而言, 此项为空值）
一些日志记录类型：&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;为什么要先写日志文件
写数据库和写日志文件是两个不同的操作
在这两个操作之间可能发生故障
如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了
如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的UNDO操作，并不会影响数据库的正确性&lt;/p&gt;
&lt;p&gt;为了保证故障恢复时能使用日志文件，日志必须存放在稳定存储器中。&lt;/p&gt;
&lt;p&gt;12.7.3.2 数据库修改&lt;/p&gt;
&lt;p&gt;如果一个事务直到提交时都没有修改数据库，我们称它采用了延迟修改。如果数据库修改数据库时事务仍活跃，我们称它使用了立即修改。
对于事物的undo完成后，写一个abort日志记录，表明撤销完成了&lt;/p&gt;
&lt;p&gt;当一个事务的commit日志记录输出到稳定存储器后，我们说这个事务提交了。如果系统崩溃在commit日志记录输出到稳定存储器之前，事务将回滚。
故障的恢复
系统故障造成数据库不一致状态的原因
（1）未完成事务对数据库的更新可能已写入数据库
（2）已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库
恢复方法
（1） Undo 故障发生时未完成的事务
（2） Redo 已完成的事务
系统故障的恢复由系统在重新启动时自动完成，不需要用户干预
（1）正向扫描日志文件（即从头扫描日志文件）    事务故障反向
重做(REDO) 队列: 在故障发生前已经提交的事务
这些事务既有BEGIN TRANSACTION记录，也有COMMIT记录或abort记录
撤销 (UNDO)队列:故障发生时尚未完成的事务
这些事务只有BEGIN TRANSACTION记录，无相应的COMMIT记录或abort记录
（2） 对撤销(UNDO)队列事务进行撤销(UNDO)处理
反向扫描日志文件，对每个撤销事务的更新操作执行逆操作
即将日志记录中“更新前的值”写入数据库
（3）对重做(REDO)队列事务进行重做(REDO)处理
正向扫描日志文件，对每个重做事务重新执行登记的操作
即将日志记录中“更新后的值”写入数据库&lt;/p&gt;
&lt;p&gt;1、两个问题
（1）搜索整个日志将耗费大量的时间
（2）重做处理：重新执行，浪费了大量时间
2、解决方案
具有检查点（checkpoint）的恢复技术
（1）在日志文件中增加检查点记（checkpoint）。
（2）增加重新开始文件。
（3）恢复子系统在登录日志文件期间动态地维护日志。&lt;/p&gt;
&lt;p&gt;10.6.2.检查点技术
1、检查点记录的内容
（1）建立检查点时刻所有正在执行的事务清单
（2）这些事务最近一个日志记录的地址
2、重新开始文件的内容
记录各个检查点记录在日志文件中的地址
3、动态维护日志文件的方法
周期性地执行如下操作：建立检查点，保存数据库状态。
具体步骤是：
（1）将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上
（2）在日志文件中写入一个检查点记录
（3）将当前数据缓冲区的所有数据记录写入磁盘的数据库中
（4）把检查点记录在日志文件中的地址写入一个重新开始文件
4、建立检查点
恢复子系统可以定期或不定期地建立检查点,保存数据库状态:
定期：按照预定的一个时间间隔，如每隔一小时建立一个检查点
不定期：按照某种规则，如日志文件已写满一半建立一个检查点&lt;/p&gt;
&lt;p&gt;10.6.3.利用检查点的恢复策略
1、使用检查点方法可以改善恢复效率
（1）当事务T在一个检查点之前提交，T对数据库所做的修改已写入数据库。
（2）写入时间是在这个检查点建立之前或在这个检查点建立之时。
（3）在进行恢复处理时，没有必要对事务T执行重做操作
2、利用检查点的恢复步骤
（1）从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录
（2）由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST
建立两个事务队列
UNDO-LIST
REDO-LIST
把ACTIVE-LIST暂时放入UNDO-LIST队列，REDO队列暂为空。
（3）从检查点开始正向扫描日志文件，直到日志文件结束
如有新开始的事务Ti，把Ti暂时放入UNDO-LIST队列
如有提交的事务Tj，把Tj从UNDO-LIST队列移到REDO-LIST队列;直到日志文件结束
（4）对UNDO-LIST中的每个事务执行UNDO操作
对REDO-LIST中的每个事务执行REDO操作&lt;/p&gt;
&lt;p&gt;————————————————
版权声明：本文为CSDN博主「头秃的女程序员」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_39326472/article/details/88420916&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>[转]数据库系统概念</title>
      <link>http://www.yezheng.pro/post/specialization/systems/data-management-and-data-systems/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 19 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/specialization/systems/data-management-and-data-systems/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/</guid>
      
        <description>&lt;p&gt;&lt;a href=&#34;https://feiybox.com/2020/11/25/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.png&#34;&gt;&lt;img src=&#34;https://feiybox.com/2020/11/25/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.png&#34; alt=&#34;数据库系统概念&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;数据库管理系统（DBMS）由一个互相关联的数据的集合（数据库）和一组用以访问这些数据的程序组成。&lt;/p&gt;
&lt;p&gt;数据库系统的一个主要目的是为用户提供数据的抽象视图，系统隐藏数据存储和维护的细节。&lt;/p&gt;
&lt;p&gt;数据库结构的基础是数据模型：一个用于描述数据、数据之间的联系、数据语义和数据约束的概念工具的集合。&lt;/p&gt;
&lt;p&gt;关系数据模型是最广泛使用的将数据存储到数据库中的模型。其他的数据模型有面向对象模型、对象-关系模型和半结构化数据模型。&lt;/p&gt;
&lt;p&gt;数据操纵语言（DML）是使得用户可以访问和操纵数据的语言。数据定义语言（DDL）是说明数据库模式和数据的其他特征的语言。&lt;/p&gt;
&lt;p&gt;数据库设计主要包括数据库模式的设计。实体-联系（E-R）数据模型是广泛用于数据库设计的数据模型，提供一种方便的图形化的方式来观察数据、联系和约束。&lt;/p&gt;
&lt;p&gt;数据库设计流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;制定出用户需求的规格文档&lt;/li&gt;
&lt;li&gt;在概念设计阶段开发出来的模式提供企业的详细概述：描述数据以及它们之间的联系，而不是指定无力的存储细节&lt;/li&gt;
&lt;li&gt;逻辑设计阶段：设计者将高层的概念模式映射到要使用的数据库系统的设计数据模式上&lt;/li&gt;
&lt;li&gt;物理设计阶段：指定数据库中的物理特性，这些特性包括文件组织的形式以及内部的存储结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据库系统由几个子系统构成：1、存储管理器子系统在数据库中存储的低层数据与应用程序和向系统提交的查询之间提供借口。2、查询处理器子系统编译和执行DDL和DML语句。&lt;/p&gt;
&lt;p&gt;事务是数据库应用中完成单一逻辑功能的操作结合。**每个事务是一个既具有原子性又具有一致性的单元。原子性和持久性的保证是数据库系统自身的职责。**事务管理负责保证不管是否有故障发生，数据库都要处于一致的（正确的）状态。事务管理器还保证并发事务的执行互不冲突。&lt;/p&gt;
&lt;p&gt;数据库系统的体系结构受支持其运行的计算机系统的影响很大。数据库系统可以是集中式的。或是客户-服务器方式的，即一个服务器及其为多个客户机执行工作。数据库系统还可以设计成具有能充分利用并行计算系统结构的能力。分布式数据库跨越多个地理上分布的互相分离的计算机。&lt;/p&gt;
&lt;p&gt;典型地，数据库应用可被分为运行在客户机上的前端和运行在后端的部分。在两层的系统结构中，前端直接和后端运行的数据库进行通信。在三层结构上，后端又被分为应用服务器和数据库服务器。&lt;/p&gt;
&lt;p&gt;知识发现技术试图自动地从数据中发现统计规律和模式。数据挖掘领域将人工智能和统计分析研究人员创造的知识发现技术，与使得知识发现技术能够在极大地数据库上高效实现的技术结合起来。数据挖掘指半自动地分析大型数据库并从中找出有用的模式的过程。&lt;/p&gt;
&lt;h2 id=&#34;关系数据库&#34;&gt;关系数据库&lt;/h2&gt;
&lt;h3 id=&#34;关系模型介绍&#34;&gt;关系模型介绍&lt;/h3&gt;
&lt;p&gt;**数据模型是描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。**数据库模式是指数据库的逻辑设计，数据库实例是指给定时刻数据库中数据的一个快照。&lt;/p&gt;
&lt;p&gt;关系数据模型建立在表的集合的基础上。数据库系统的用户可以对这些表进行查询，可以插入新元组、删除元组以及更新（修改）元组。表达这些操作的语言又几种。&lt;/p&gt;
&lt;p&gt;关系的模式是指它的逻辑设计。而关系的实例是指它的特定时刻的内容。数据库的模式和实例的定义的类似的。关系的模式包括它的属性，还可能包括属性类型和关系上的约束，比如主码和外码约束。&lt;/p&gt;
&lt;p&gt;关系的超码是一个或多个属性的集合，这些属性上的取值保证可以唯一识别出关系中的元组。候选码是一个最小的超码，也就是说，它是一组构成超码的属性集，但这组属性的任意子集都不是超码。关系的一个候选码被选作主码。&lt;/p&gt;
&lt;p&gt;在参照关系中的外码是这样的一个属性集合：对于参照关系中的每个元组来说，它在外码属性上的取值肯定等于被参照关系中某个元组在主码上的取值。&lt;/p&gt;
&lt;p&gt;模式图是数据库中模式的图形化表示，它显示了数据库中的关系，关系的属性、主码和外码。&lt;/p&gt;
&lt;p&gt;关系查询语言定义了一组运算集，这些运算可以作用于表上，并输出表作用结构。这些运算可以组合成表达式，表达所需的查询。&lt;/p&gt;
&lt;p&gt;关系代数提供了一组运算，它们以一个或多个关系为输入，返回一个关系作为输出。诸如SQL这样的实际查询语言的基于关系代数的，但增加了一些有用的句法特征。&lt;/p&gt;
&lt;h3 id=&#34;sql&#34;&gt;SQL&lt;/h3&gt;
&lt;p&gt;SQL是最有影响力的商用市场化的关系查询语言。包括以下几个部分：1、数据定义语言（DDL），提供了定义关系模式、删除关系以及修改关系模式的命令；2、数据操作语言（DML），提供查询语言，以及往数据库中插入元组、从数据库中删除元组修改数据库中元组的命令。&lt;/p&gt;
&lt;p&gt;SQL的数据定义语言用于创建具有特定模式的关系。除了声明关系属性的名称和类型之外，SQL还允许声明完整性的约束，例如主码约束和外码约束。&lt;/p&gt;
&lt;p&gt;SQL提供多种用于查询数据库的语言结构，其中包括select、form和where子句。SQL支持自然连接操作。&lt;/p&gt;
&lt;p&gt;SQL还提供了对属性的关系重命名，以及对查询结果按特定属性进行排序的机制。&lt;/p&gt;
&lt;p&gt;SQL支持关系上的基本集合运算，包括并、交和差运算。&lt;/p&gt;
&lt;p&gt;SQL通过在通用真值true和false外增加增值“unknown”，来处理对包含空值进行排序的机制。&lt;/p&gt;
&lt;p&gt;SQL支持在外层查询的where和from子句中嵌套子查询。它还在一个表达式返回的单个值所允许出现的任何地方支持标量子查询。&lt;/p&gt;
&lt;p&gt;SQL提供了用于更新、插入、删除信息的结构。&lt;/p&gt;
&lt;h3 id=&#34;中级sql&#34;&gt;中级SQL&lt;/h3&gt;
&lt;p&gt;SQL支持包括内连接、外连接在内的几种连接类型，以及几种形式的连接条件。&lt;/p&gt;
&lt;p&gt;视图关系可以定义为包含查询查询结果的关系。视图可以隐藏不需要的信息，可以把信息从多个关系收集到一个单一的视图中。&lt;/p&gt;
&lt;p&gt;事务是一个查询的更新的序列，它们共同执行某项任务。事务可以被提交或回滚。当一个事务被回滚，该事务执行的所有更新所带来的影响将被撤销。&lt;/p&gt;
&lt;p&gt;完整性约束保证授权用户对数据库所做的改变不会导致数据一致性的破坏。&lt;/p&gt;
&lt;p&gt;参照完整性约束保证出现在一个关系的给定属性集上的值同样出现在另一个关系的特定属性集上。&lt;/p&gt;
&lt;p&gt;域约束指定了在一个属性上可能取值的集合。这种约束也可以禁止在特定属性上使用空值。&lt;/p&gt;
&lt;p&gt;断言是描述性表达式，它指定了我们要求总是为真的谓词。&lt;/p&gt;
&lt;p&gt;SQL数据定义语言提供对定义诸如date和time那样的固有域类型以及用户定义域类型的支持。&lt;/p&gt;
&lt;p&gt;通过SQL授权机制，可以按照在数据库中不同数据值上数据库用户所允许的访问类型对他们进行区分。&lt;/p&gt;
&lt;p&gt;获得了某种形式授权的用户可能允许将此授权传递给其他用户。但是，对于权限怎样在用户间传递我们必须很小心，以保证这样的权限在将来的某个时候可以被收回。&lt;/p&gt;
&lt;p&gt;角色有助于根据用户在组织机构中扮演的角色，把一组权限分配给用户。&lt;/p&gt;
&lt;h3 id=&#34;高级sql&#34;&gt;高级SQL&lt;/h3&gt;
&lt;p&gt;SQL查询可以从宿住语言通过嵌入和动态SQL激发。ODBC和JDBC标准给C、Java等语言的应用程序定义接入SQL数据库的应用程序接口。&lt;/p&gt;
&lt;p&gt;函数和过程可以用SQL提供的过程来定义，它允许迭代和条件语句。&lt;/p&gt;
&lt;p&gt;触发器定义了当某个事件发生而且满足相应条件时自动执行的动作。触发器有很多用处，例如实现业务规则、审计日志，甚至执行数据库系统外的操作。&lt;/p&gt;
&lt;p&gt;联机分析处理（OLAP）工具帮助分析人员用不同的方式查看汇总数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OLAP工具工作在以维属性和度量属性为特性的多维数据之上。&lt;/li&gt;
&lt;li&gt;数据立方体由以不同方式汇总的多维度数据构成。预先计算数据立方体有助于提高汇总数据的查询数据。&lt;/li&gt;
&lt;li&gt;交叉表的显示允许用户一次查看多维数据的两个维及其汇总数据。&lt;/li&gt;
&lt;li&gt;下钻、上卷、切片和切块是用户使用OLAP工具时执行的一些操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;形式化关系查询语言&#34;&gt;形式化关系查询语言&lt;/h3&gt;
&lt;p&gt;关系代数定义了一套在表上运算且输出结果也是表的代数运算。这些运算可以凝合使用来得到表达所希望查询的表达式。关系代数定义了关系查询语言中使用的基本运算。&lt;/p&gt;
&lt;p&gt;关系代数运算可以分为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、基本运算；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关系代数基本运算有：选择、投影、并、集合差、笛卡尔积和更名。选择、投影和更名运算是一元运算符。选择：选出满足给定谓词的元组。&lt;/p&gt;
&lt;p&gt;二元运算自然连接使得我们可以将某些选择和笛卡尔积运算合并为一个运算。自然连接运算首先形成它的两个参数的笛卡尔积，然后基于两个关系模式中都出现的属性上相等性进行选择，最后还要去除重复属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、附加的运算，可以用基本运算的表达；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包括集合交、自然连接和赋值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、扩展的运算，其中的一些扩展了关系代数的表达能力。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;广义投影：允许在投影列表中使用算术运算和字符串函数等来对投影进行扩展。&lt;/p&gt;
&lt;p&gt;以下三种等价：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本关系代数（不包含扩展关系代数运算）&lt;/li&gt;
&lt;li&gt;限制在安全表达式范围内的元组关系演算&lt;/li&gt;
&lt;li&gt;限制在安全表达式范围内的域关系演算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;没有任何一个域关系演算等价于聚集运算，但是它可以扩展支持聚集。&lt;/p&gt;
&lt;p&gt;关系代数式一中简洁的、形式化的语言，不适合于那些偶尔使用数据库系统的用户。因此，商用数据库系统采用有更多“语言修饰”的语言。&lt;/p&gt;
&lt;p&gt;元组关系演算和域关系演算使非过程化语言，代表了关系查询语言所需的基本能力。基本关系代数式一种过程化语言，在能力上等价于被限制在安全表达式范围内的关系演算的这两种形式。&lt;/p&gt;
&lt;p&gt;关系演算的简洁的、形式化的语言，并不适合于那些偶尔使用数据库系统的用户。&lt;/p&gt;
&lt;h2 id=&#34;数据库设计&#34;&gt;数据库设计&lt;/h2&gt;
&lt;h3 id=&#34;数据库设计与e-r模型&#34;&gt;数据库设计与E-R模型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据库设计的最初阶段需要完整地刻画未来数据库用户的数据需求&lt;/li&gt;
&lt;li&gt;设计者选择数据模型，并采用所选数据模型的概念将这些需求转化为数据库的概念模式。在概念设计阶段所产生的模式提供了一个对企业的详细综述。&lt;/li&gt;
&lt;li&gt;完善的该你那模式还指明企业的功能需求。&lt;/li&gt;
&lt;li&gt;从抽象数据模型到数据库的实现的转化在最后两个设计阶段中进行
&lt;ul&gt;
&lt;li&gt;逻辑设计阶段：将高层概念模式映射到将使用的数据库系统的实现数据模式上。&lt;/li&gt;
&lt;li&gt;物理设计简单：指明数据库的物理特征。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在设计一个数据库模式时，需要确保避免两个主要缺陷：冗余、不完整。&lt;/p&gt;
&lt;p&gt;数据库设计主要涉及数据库模式的设计。实体-联系（E-R）数据库模型是一个广泛用于数据库设计的数据模型。提供了一个方便的图形化表示方法以查看数据、联系和约束。&lt;/p&gt;
&lt;p&gt;E-R模型主要用于数据库设计过程。它的发展是为了帮助数据库设计，这是通过允许定义企业模式实现的。这种企业模式代表数据库的全局逻辑结构，可以用E-R图形化表示。&lt;/p&gt;
&lt;p&gt;实体是在现实世界中存在并且区别于其他对象的对象。通过把每个实体同描述该实体的一组属性相关联来表示区别。&lt;/p&gt;
&lt;p&gt;联系是多个实体间的关联。相同类型的联系的集合为联系集，相同类型的实体的集合为实体集。&lt;/p&gt;
&lt;p&gt;每个属性都有一个可取值的集合，称为该属性的域，或者值集。&lt;/p&gt;
&lt;p&gt;术语超码、候选码以及主码同适用于关系模式一样适用于实体和联系集。&lt;/p&gt;
&lt;p&gt;映射的基数表示通过联系集可以和另一实体相关联的实体的个数。&lt;/p&gt;
&lt;p&gt;不具有足够属性构成的主码的实体集称为弱实体集。具有主码的实体集称为强实体集。&lt;/p&gt;
&lt;p&gt;E-R模型的各种性质为数据库设计者提供了大量的选择，使设计人员可以最好地表示被建模的企业。在某些情况下，概念和对象可以用实体、联系或属性来表示。企业总体结构的各方面可以用弱实体集、概化、特化或聚集很好地描述。设计者通常需要在简单的、紧凑的模型与更精确但也更复杂的模型之间进行权衡。&lt;/p&gt;
&lt;p&gt;用E-R图定义的数据库设计可以用关系模式的集合来表示。数据库的每个实体集和联系集都有唯一的关系模式与之对应，其名称即为相应的实体集或联系集的名称。这是从E-R图转换为关系数据库设计的基础。&lt;/p&gt;
&lt;p&gt;特化和概化定义了一个高层实体集和一个或多个低层实体集之间的包含关系。特花是取出高层实体集的一个子集来形成一个低层实体集。概化湿用两个或者多个不相交的（低层）实体集的并集形成一个高层实体集。高层实体集的属性被低层实体集继承。&lt;/p&gt;
&lt;p&gt;聚集是一种抽象，其中联系集（和它们相关的实体集一起）被看作高层实体集，并且可以参与联系。&lt;/p&gt;
&lt;p&gt;UML是一种常见的建模语言。UML类图广泛用于对类建模以及一般的数据建模。&lt;/p&gt;
&lt;h3 id=&#34;关系数据库设计&#34;&gt;关系数据库设计&lt;/h3&gt;
&lt;p&gt;冗余存储则存在不一致的风险。&lt;/p&gt;
&lt;p&gt;如果该域的元素被认为是不可分的单元，这个域是原子的。&lt;strong&gt;如果关系模式R的所有属性的域都是原子的，那么称R属于第一范式（1NF）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在许多含有复杂结构的实体域中，强制使用第一范式会给应用程序员造成不必要的负担。设计与开发时需要从当前业务考虑。&lt;/p&gt;
&lt;p&gt;一个关系的满足所有现实世界的约束的实例，称为关系的合法实例（满足业务要求的实例）。&lt;/p&gt;
&lt;p&gt;使用F+符号表示F集合的闭包，能够从给定F集合推导出所有函数依赖的集合。F+包含了F的所有函数依赖。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具有函数依赖集F的关系模式R属于BCNF的条件是，对于F+中所有形如a-&amp;gt;b的函数依赖（其中a与b都包含于R），下面至少一项成立：1、a-&amp;gt;b是平凡的函数依赖（即b包含于a）；2、a是模式R的一个超码。一个数据库设计属于BCNF的条件是，构成该设计的关系模式集中的每种模式都属于BCNF。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三范式：对于F+中所有形如a-&amp;gt;b的函数依赖（其中a，b都包含于R）以下至少一项成立：1、a-&amp;gt;b是一个平凡的函数依赖；2、a是R的一个超码；3、b-a中的每个属性A都包含于R的一个候选码中（候选码是最小的超码，且任意子集都不是超码）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定关系模式r(R)，如果r(R)的每一个满足F的实例都满足f，则R上的函数依赖f被r上的函数依赖F逻辑蕴涵。F的闭包是被F逻辑蕴涵的所有函数依赖的集合（F+）。&lt;/p&gt;
&lt;p&gt;函数依赖和多值依赖集为D的关系模式r(R)属于第四范式的条件是，对于D+中所有形如a–&amp;gt;b的多值依赖（其中a和b都包含于R），以下至少一项成立：1、a–&amp;gt;b是一个平凡的多值依赖；2、a是R的一个超码。&lt;/p&gt;
&lt;h3 id=&#34;应用设计和开发&#34;&gt;应用设计和开发&lt;/h3&gt;
&lt;h2 id=&#34;数据存储和查询&#34;&gt;数据存储和查询&lt;/h2&gt;
&lt;h3 id=&#34;存储和文件结构&#34;&gt;存储和文件结构&lt;/h3&gt;
&lt;p&gt;最快的存储介质（如高速缓冲存储器和主存储器）称为基本存储。层次结构中的基本存储介质的下一层介质（如磁盘）称为辅助存储或联机存储。层次结构中最底层的介质（如磁带机和自动光盘机）称为三级存储或脱机存储。&lt;/p&gt;
&lt;p&gt;易失性存储在设备断电后将丢失所有的内容。&lt;/p&gt;
&lt;p&gt;存储介质的可靠性由两个因素决定：1、电源故障或系统崩溃是否导致数据丢失；2、存储设备发生物理故障的可能性有多大。&lt;/p&gt;
&lt;p&gt;通过保留数据的多个拷贝，可以减少物理故障的可能性。对磁盘来说可以使用镜像技术。或者可以使用更复杂的基于独立磁盘冗余阵列（RAID）的方法。通过将数据拆分到多张磁盘上，可以提高大数据量访问的吞吐率；通过引入多张磁盘上的冗余存储，可以显著提高可靠性。&lt;/p&gt;
&lt;p&gt;可以把一个文件从逻辑上组织成映射到磁盘块上的一个记录序列。把数据库映射到文件的一种方法是使用多个文件，每个文件只存储固定长度的记录。另一种方法是构造文件。使之能适应多种长度的记录。分槽的页方法广泛应用于在磁盘块中处理变长记录。&lt;/p&gt;
&lt;p&gt;通过在多张磁盘上进行数据拆分来提高传速率。数据拆分最简单的形式是将每个字节按比特分开，存储到多个磁盘上。这种拆分称为比特级拆分。块级拆分是将块拆分到多张磁盘。&lt;/p&gt;
&lt;p&gt;磁盘系统并行有两个主要目的：1、负载平衡多个小的访问操作（块访问），以提高这种访问操作的吞吐量；2、并行执行大的访问操作，以减少大访问的响应时间。&lt;/p&gt;
&lt;p&gt;大对象常常存储到一个特殊的文件（或文件的集合）中而不是与记录的其他（短）属性存储在一起。然后一个指向该对象的（逻辑）指针存储到包含该大对象的记录中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;顺序文件是为了高效处理按某个搜索码的顺序排序的记录而设计的。搜索码是任何的一个属性或者属性的集合。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多表聚簇文件组织是一种在每一块中存储两个或者更多个关系的相关记录的文件结构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库系统的一个主要目的就是尽量减少磁盘和存储器之间传输的块数目。负责缓冲区空间分配的子系统称为缓冲区管理器。缓冲的是块而非数据。&lt;/p&gt;
&lt;h3 id=&#34;索引与散列&#34;&gt;索引与散列&lt;/h3&gt;
&lt;p&gt;数据库系统首先查找索引，找到相应记录所做的磁盘块，然后取出该磁盘块，得到所需的记录。&lt;/p&gt;
&lt;p&gt;如果包含记录的文件按照某个搜索码指定的顺序排序，那么该搜索码碎影的索引称为聚集索引。&lt;/p&gt;
&lt;p&gt;索引顺序文件是数据库系统中最古老的索引模式之一。为了允许按搜索码顺序快速检索记录，记录按顺序存储，而无序记录链接在一起。为了允许快速的随机访问，使用了索引结构。&lt;/p&gt;
&lt;p&gt;可以使用的索引类型有两种：稠密索引和稀疏索引。稠密索引对每个搜索码值都有索引项，而稀疏索引只对某些搜索码值包含索引项。利用稠密索引通常可以比稀疏索引更快地定位一条记录。但是，稀疏索引所占空间较小，并且插入和删除时所需的维护开销也较小。（折中方案：为每个块建一个索引项的稀疏索引）&lt;/p&gt;
&lt;p&gt;利用多级索引搜索记录与用二分法搜索记录相比需要的I/O操作要少得多。&lt;/p&gt;
&lt;p&gt;如果搜索码的排序序列和关系的排序序列相匹配，则该搜索码上的索引称为聚集索引，其他索引称为非聚集缩影或辅助索引。辅助索引可以提高不以聚集索引的搜索码作为搜索码的查询的性能。但是，辅助索引增加了修改数据库的开销（辅助索引必须是稠密索引，对每个搜索码值都有一个索引项，而且对文件中的每条记录都有一个指针）。&lt;/p&gt;
&lt;p&gt;候选码上的辅助索引看起来和稠密聚集索引没有太大区别，只不过索引中一系列的连续值执行的记录不是连续存放的。&lt;/p&gt;
&lt;p&gt;索引顺序文件组织的主要缺点是随着文件的增大，性能会下降。为了克服这个缺点，可以使用B+树索引。&lt;/p&gt;
&lt;p&gt;B+树索引采用平衡树的形式，即从树根到树叶的所有路径长度相等。B+树的高度与以关系中的记录数N为底的对数成正比，其中每个非叶子结点存储N个指针，N值通常约为50～100。因此，B+树比其他的平衡二叉树（比如AVL树）要矮喝多，故定位记录所需的磁盘访问次数也较少。&lt;/p&gt;
&lt;p&gt;B+树上的查询是直接而且高效的。然而插入和删除要更复杂一些，但是仍然很有效。在B+树中，查询、插入和删除所需的操作数与以关系中的记录数N为底的对数成正比，其中每个非叶子结点存储N个指针。&lt;/p&gt;
&lt;p&gt;可以用B+树去索引包含记录的文件，也可以用它组织文件中的记录。&lt;/p&gt;
&lt;p&gt;B树索引和B+树索引类型。B树的主要优点在于它去除了搜索码值存储中的冗余（当搜索码值唯一的情况下，只允许搜索码值出现一次）。主要缺点在于整体的复杂性以及节点大小给定时减小了扇出（直接连接下级个数，节点大导致扇出小，深度增加）。在实际应用中，系统设计者几乎无一例外的倾向于使用B+树索引。&lt;/p&gt;
&lt;p&gt;R树是B+树的扩展，用于处理在多个维度上的索引。&lt;/p&gt;
&lt;p&gt;覆盖索引存储一些属性（但不是搜索码属性）的值以及指向记录的职责。存储附加的属性值对于辅助索引是非常有用的，仅仅使用索引就能够回答一些查询，甚至不需要找到实际的记录。&lt;/p&gt;
&lt;p&gt;顺序文件组织需要一个索引结构来定位数据。相比之下，基于散列的文件组织允许我们通过计算所需记录搜索码值上的一个函数直接找出一个数据项的地址。由于设计时我们不能精确知道哪些搜索码值将存储在文件中，因此一个好的散列函数应该能均匀且随机地将搜索码值分散到各个桶中。&lt;/p&gt;
&lt;p&gt;静态散列所用散列函数和桶地址集合是固定的。这样的散列函数不容易适应数据库随时间的显著增长。有几种允许修改散列函数的动态散列技术。可扩充散列是其中之一，它可以在数据库增长或缩减时通过分裂或合并桶来应付数据库大小的变化。&lt;/p&gt;
&lt;p&gt;也可以用散列技术创建辅助索引：这样的索引称为散列索引。为使记法简便，假定散列文件组织中用户散列的搜索码上有一个隐式的散列索引。&lt;/p&gt;
&lt;p&gt;可扩充散列可以通过桶的分裂或合并来适应数据库的大小的变化。由于重组每次仅作用于一个桶，因此所带来的性能开销较低，可以接受。可扩充散列的最主要优点是其性能不随文件的增长而降低，其空间开销是最小的。缺点在于查找涉及一个附加的间接层。&lt;/p&gt;
&lt;p&gt;像B+树和散列索引这样的有序索引可以用作涉及单个属性且基于相等条件的选择操作。当一个选择条件中涉及多个属性时，可以取多个索引中检索到的记录标示符的交。&lt;/p&gt;
&lt;p&gt;对于索引属性只有少数几个不同值的情况，位图索引提供了一种非常紧凑的表达方式。位图索引的交操作相当得快，使得它成为一种支持多属性上的查询的理想方式（属性有限变量下）。&lt;/p&gt;
&lt;h3 id=&#34;查询处理&#34;&gt;查询处理&lt;/h3&gt;
&lt;p&gt;对于一个查询，系统首先要做的事就是将之翻译成系统内部的表示形式。对于关系数据库系统而言，内部形式通常是基于关系代数的。在产生查询的内部形式的过程中，语法分析器检查用户查询语句的语法，验证出现在查询语句中的关系名是数据库中的关系名等。如果查询语句是用视图表达的，语法分析器把所有对视图名的引用替换成计算该视图的关系代数表达式。&lt;/p&gt;
&lt;p&gt;查询处理步骤：1、语法分析与翻译；2、优化；3、执行。&lt;/p&gt;
&lt;p&gt;加了“如何执行”注释的关系代数运算称为计算原语。用于执行一个查询的原语操作序列称为查询执行计划或者查询计算计划。查询执行引擎接受一个查询执行计划，执行该计划并把结果返回给查询。&lt;/p&gt;
&lt;p&gt;给定一个查询，通常有许多计算它的方法。将用户输入的查询语句转化成等价的、执行效率更高的查询语句，这是优化器的责任。优化器通常努力去尽可能降低查询计划总的资源消耗，而不是尽可能缩低响应时间。&lt;/p&gt;
&lt;p&gt;辅助索引存储的是B+树文件组织中作为码值的属性值。通过这种辅助索引存取一条记录的代价将更大：首先必须搜索辅助索引以找到主索引的搜索码值，然后查找主索引来找到记录。&lt;/p&gt;
&lt;p&gt;对于包含简单选择的查询语句，可以通过线性扫描或者利用索引来处理。通过计算简单选择结果的并和交，可以处理复杂选择操作。&lt;/p&gt;
&lt;p&gt;数据排序：1、SQL查询会指明对结果进行排序；2、当输入的关系已排序时，关系运算中的一些运算（如连接运算）能够得到高效实现。&lt;/p&gt;
&lt;p&gt;可以用外部归并排序算法对大内存的关系进行排序。&lt;/p&gt;
&lt;p&gt;设计自然连接的查询语句可以有多种处理方法，如果处理取决于是否有索引可用以及关系的物理存储形式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若连接的结果大小几乎和两个关系的笛卡尔积相当，可以采用嵌套循环连接策略较好。&lt;/li&gt;
&lt;li&gt;若存在索引，则可用索引嵌套循环连接。&lt;/li&gt;
&lt;li&gt;若关系已排序，则归并连接比较可取。在连接计算前对关系排序是有利的（为了能使用归并连接算法）。&lt;/li&gt;
&lt;li&gt;散列连接算法把关系划分成多个部分，使每个部分都能被内存所容纳。划分过程是通过连接属性上的散列函数来进行的，这样相应的划分对可以独立地进行连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;嵌套循环连接算法不要求有索引，并且不管连接的条件是什么，该算法均可以使用。块嵌套循环连接是以块的方式而不是以元组的方式处理关系，可以减少不少块读写次数。索引嵌套循环连接，可以在已有索引或者为了计算该连接而专门建立临时索引的情况下使用。归并连接算法（排序-归并-连接算法）可用于计算自然连接和等值连接。混合归并-连接算法把已排序关系与B+树辅助索引叶结点进行归并。散列连接算法可用于实现自然连接和等值连接，基本思想是把这两个关系的元组划分成连接属性值上具有相同散列值的元组集合。&lt;/p&gt;
&lt;p&gt;去除重复、投影、集合操作（并、交、差）、聚集操作都可以用排序和散列实现。&lt;/p&gt;
&lt;p&gt;外连接操作可以通过对连接算法的简单扩展来实现。&lt;/p&gt;
&lt;p&gt;散列与排序在某种意义下是对偶的。因为任何能用散列实现的操作（如去除重复、投影、聚集、连接、外连接）也可用排序来实现，反之亦然；即任何能用排序来实现的操作也能用散列实现。&lt;/p&gt;
&lt;p&gt;可以采用物化方法进行表达式的计算。系统计算每个子表达式的结果并将其存在磁盘上，然后用它进行父表达式的计算。&lt;/p&gt;
&lt;p&gt;流水线方法在子表达式产生输出的同时就在父表达式的计算中使用其输出结果，帮助我们避免了将许多子查询的结果写到磁盘的操作。&lt;/p&gt;
&lt;p&gt;由于去除重复的代价相对较大，因此SQL查询语言要求用户显示指明需要去除重复，若不指明则保留重复。&lt;/p&gt;
&lt;p&gt;每次计算的结果都被物化到一个临时关系中已备后用。这个方法的缺点是需要构造临时关系，这些临时关系必须写到磁盘上（除非很小）。&lt;/p&gt;
&lt;p&gt;减少临时文件数是通过将多个关系操作组合成一个操作的流水线来实现的，其中一个操作结果将传送到下一个操作。&lt;/p&gt;
&lt;h3 id=&#34;查询优化&#34;&gt;查询优化&lt;/h3&gt;
&lt;p&gt;给定一个查询，一般有多种方法可以计算结果。系统负责将用户输入的查询转换成能够更有效执行的等价查询。为处理查询找出一个好的策略的过程称为查询优化。&lt;/p&gt;
&lt;p&gt;复杂查询的执行涉及多次存取磁盘的操作。由于从磁盘中传输数据相对于主存速度和计算机系统的CPU速度要慢，因此进行一定量的处理以选择一个能够从最小化磁盘存取的方法是完全值得的。&lt;/p&gt;
&lt;p&gt;查询执行计划的产生有三步：1、产生逻辑上与给定表达式等价的表达式；2、对所产生的表达式以不同方式作注释，产生不同的查询计划；3、估计每个执行计划的代价，选择估计代价最小的一个。&lt;/p&gt;
&lt;p&gt;有很多等价规则供我们用于将一个表达式转化成等价表达式。我们使用这些规则系统地产生与所给查询等价的所有表达式。（如果两个关系表达式在每一个有效数据库实例中都会产生相同的元组集，则我们称它们是等价的。）&lt;/p&gt;
&lt;p&gt;若一组等价规则中任意一条规则都不能由其他规则联合起来导出，称这组等价规则集为最小等价规则集。&lt;/p&gt;
&lt;p&gt;优化器采用两种关键思想可以极大地减少空间和时间上的开销：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果在子表达式e(i)上使用等价规则把表达式E1转化成E‘，则除了e(i)及其转换，E1与E‘有相同的子表达式。而且e(i)及其转换通常也有许多相同的子表达式。可以采用一些表达式表示技术，使两个表达式指向共享的子表达式，这样可以明显减少对空间的需求。&lt;/li&gt;
&lt;li&gt;不必总是用等价规则产生所有可以产生的表达式。如果考虑估计的执行代价，优化器可以避免检查某些表达式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个关系代数表达式都表示某个特定的操作序列。选择查询处理策略的第一步就是找到一个关系代数表达式，使它与所给的表达式等价并且据估计有更小的执行代价。&lt;/p&gt;
&lt;p&gt;基于代价的优化器从给定查询等价的所有查询执行计划空间中进行搜索，并选择估计代价最小的一个。&lt;/p&gt;
&lt;p&gt;数据库系统为执行一个操作所选择的策略依赖于每个关系的大小和列值的分布情况。数据库系统可以为每个关系r存储统计信息，从而能够基于这些可靠信息选择适合的策略。这些统计信息包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关系r中的元组数&lt;/li&gt;
&lt;li&gt;关系r中的一个记录（元组）的大小（按字节计数）&lt;/li&gt;
&lt;li&gt;关系r中的某个特定属性中出现的不同取值的数目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;许多数据库系统使用直方图来存储一个属性在每个区间上的取值个数。直方图通常采用取样来计算。&lt;/p&gt;
&lt;p&gt;这些统计信息使得我们可以估计各种操作的结果集的大小和执行操作的代价。当处理一个查询的过程中有多个索引可用于辅助的时候，关系的统计信息特别有用，这些信息对查询处理策略的选择有很大影响。&lt;/p&gt;
&lt;p&gt;物理等价规则允许将例如连接这样的逻辑操作转换成像散列连接或嵌套循环连接这样的物理操作。通过将这类规则添加到原来的等价规则中，程序可以产生所有可能的执行计划。&lt;/p&gt;
&lt;p&gt;对每个表达式，我们可以用一些等价规则产生多个可选的执行计划，然后从中选择代价最小的执行计划。不少优化技术可以减少需要产生的可选表达式和执行计划的数量。&lt;/p&gt;
&lt;p&gt;我们使用启发式方法来减少需要考虑的执行计划的数量，从而减少优化的代价。用于关系代数查询转换的启发式规则包括“尽早执行选择操作”、“尽早执行投影操作”、和“避免笛卡尔积操作”。&lt;/p&gt;
&lt;p&gt;用一个具有连接的查询（可能使用临时关系）去替代嵌套查询的过程称为去除相关。&lt;/p&gt;
&lt;p&gt;物化视图可以用来加速查询处理。当原关系发生修改时，需要用增量的视图维护来高效地更新物化视图。利用包含一个操作的输入的变化量的代数表达式，能够完成对该操作的变化量的计算。其他与物化视图相关的问题还包括如何借用物化视图进行查询优化和如何选择需要待物化的视图。查询优化器的工作应该包括知道何时可利用物化视图来提高查询处理速度。&lt;/p&gt;
&lt;p&gt;一些优化技术，包括top-K优化、连接极小化、更新优化、多查询优化和参数化查询优化。&lt;/p&gt;
&lt;p&gt;共享式扫描优化的工作方式如下：不是对于需要扫描一个关系的每一个查询，都从磁盘上重复地读取该关系，而是从磁盘上读取一次数据，然后流水线地传递给每一个查询。（一次读取，多次使用）&lt;/p&gt;
&lt;p&gt;如果最优计划受查询中的常数值影响不大，则通过计划缓存重用计划是合理的。然而如果计划受常数的影响，则可以使用参数化查询优化作为替代。&lt;/p&gt;
&lt;h2 id=&#34;事务管理&#34;&gt;事务管理&lt;/h2&gt;
&lt;p&gt;事务指的是构建单一逻辑工作单元的操作的集合。&lt;/p&gt;
&lt;h3 id=&#34;事务&#34;&gt;事务&lt;/h3&gt;
&lt;p&gt;事务时一个程序执行单位，它访问且可能更新不同的数据项。理解事物这个概念对于理解与实现数据库中的数据更新是很关键的，只有这样才能保证并发执行与各种故障不会导致数据库处于不一致状态。&lt;/p&gt;
&lt;p&gt;事务具有ACID特性：原子性、一致性、隔离性、持久性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性保证事务的所有影响在数据库中要么全部反映出来，要么根本不反应；一个故障不能让数据库处于事务部分执行后的状态。&lt;/li&gt;
&lt;li&gt;一致性保证若数据库一开始是一致的，则事务（单独）执行后数据库仍处于一致状态。&lt;/li&gt;
&lt;li&gt;隔离性保证并发执行提高了事务吞吐量和系统利用率，也减少了事务等待时间。&lt;/li&gt;
&lt;li&gt;持久性保证一旦一个事务提高后，它对数据库的改变不会丢失，即使系统可能出现故障。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务的并发执行提高了事务吞吐量和系统利用率，也减少了事务等待时间。&lt;/p&gt;
&lt;p&gt;计算机中不同存储介质包括异失性存储器、非易失性存储器和稳定性存储器。易失性存储器（例如RAM）中数据当计算机崩溃时丢失。非易失性存储器（如磁盘）中的数据在计算机崩溃时不会丢失，但是可能会由于磁盘崩溃而丢失。稳定性存储器中的数据永远不会丢失。&lt;/p&gt;
&lt;p&gt;为了一个事务能够持久，它的修改应该写入稳定性存储器。为了一个事务是原子的，日志记录需要在对磁盘上的数据库做任何改变之前写入稳定性存储器。&lt;/p&gt;
&lt;p&gt;必须支持在线访问的稳定性存储器与磁盘镜像或者其他形式的提供冗余数据存储的RAID接近。对于离线或归档的情况，稳定性存储器可以由存储在物理安全位置的数据的多个磁带备份所构成。&lt;/p&gt;
&lt;p&gt;撤销已提交事务所造成的影响的唯一方法是执行一个补偿事务。&lt;/p&gt;
&lt;p&gt;多个事务在数据库中并发执行时，数据的一致性可能不再维持。因此系统必须控制各并发事务之间的相互作用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于事务时保持一致性的单元，所以事务的串行执行能保持一致性。&lt;/li&gt;
&lt;li&gt;调度捕获影响事务并发执行的关键操作，如read和write操作，而忽略事务执行的内部细节。&lt;/li&gt;
&lt;li&gt;我们要求事务集的并发执行所产生的任何调度的执行效果等价于由这些事务按某种串行顺序执行的效果。&lt;/li&gt;
&lt;li&gt;保证这个特性的系统称为保证可串行化。&lt;/li&gt;
&lt;li&gt;存在几种不同的概念，从而引出了冲突可串行化与视图可串行化的概念。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务并发执行所产生的调度的可串行化可以通过多种并发控制机制中的一种来加以保证。&lt;/p&gt;
&lt;p&gt;给定一个调度，我们可以通过为该调度构造优先图几搜索是否无环来判定它是否冲突可串行化。然而，有更好的并发控制机制可用来保证可串行化。&lt;/p&gt;
&lt;p&gt;调度必须时可恢复的，以确保：若事务a看到事务b的影响，当b中止时，a也要中止。（一个可恢复调度应该满足：对于每个事务T(i)和T(j)，如果T(j)读取了之前由T(i)所写的数据项，则T(i)先于T(j)提交。）&lt;/p&gt;
&lt;p&gt;调度最好是无级联的，这样不会由于一个事务的中止引起其他事务的级联中止。无级联性是通过只允许事务读取已提交数据来保证的。（因单个事务故障导致一系列事务回滚的现象称为级联回滚。（无级联调度=可恢复调度）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可串行化&lt;/strong&gt;：通常保证可串行化调度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可重复读&lt;/strong&gt;：只允许读取已提交的数据，而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据项。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已提交读&lt;/strong&gt;：只允许读取已提交数据，但不要求可重复读。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;未提交读&lt;/strong&gt;：允许读取未提交数据。（脏读）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有隔离性级别都不允许&lt;strong&gt;脏写&lt;/strong&gt;，即如果一个数据项已经被另一个尚未提交或者中止的事务写入，则不允许对该数据项执行写操作。&lt;/p&gt;
&lt;p&gt;数据库的并发控制管理部件复杂处理并发控制机制。&lt;/p&gt;
&lt;p&gt;快照隔离可以保证读数据的尝试永远无须等待，但带来的问题是提供了太多的隔离。如果事务多次运用之间数据库发生改变，那么即使是同一个事务，在多次不同运行中也可能会使用不同的数据项。&lt;/p&gt;
&lt;h3 id=&#34;并发控制&#34;&gt;并发控制&lt;/h3&gt;
&lt;p&gt;当多个事务在数据库中并发执行时，数据的一致性可能不再维持。系统有必要控制各事务之间的相互作用，这是通过称为并发控制机制的多种机制中的一种来实现的。&lt;/p&gt;
&lt;p&gt;为保证可串行性，我们可以使用多种并发控制机制。所以这些机制要么延迟一个操作，要么中止发出该操作的事务。最常用的机制是多种封锁协议、时间戳排序机制、有效性检查技术与多版本机制。&lt;/p&gt;
&lt;p&gt;封锁协议是一组规则，这些规则阐明了事务何时对数据库中的数据项进行加速和解锁。&lt;/p&gt;
&lt;p&gt;两阶段封锁协议仅在一个事务未曾释放任何数据项上的锁时才允许该书屋封锁新数据项。该协议保证可串行化，但不能避免死锁。在没有关于数据项访问方式信息的情况下，两阶段封锁协议对于保证可串行性既是必要的又是充分的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两阶段封锁协议&lt;/strong&gt;：要求每个事务分两个阶段提出加锁和解锁申请。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增长阶段：事务可以获得锁，但不能释放锁。&lt;/li&gt;
&lt;li&gt;缩减阶段：事务可以释放锁，但不能获得新锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;严格两阶段封锁协议要求事务持有的所有排他锁必须在事务结束时方可释放，其目的是保证结果调度的可恢复性和无级联性，强两阶段封锁协议要求事务持有的所有锁必须在事务结束时方可释放。&lt;/p&gt;
&lt;p&gt;锁转换：提供一种将共享锁升级为排他锁，以及将排他锁降级为共享锁的机制。&lt;/p&gt;
&lt;p&gt;锁管理器可以实现一个过程，从事务接受消息并反馈消息。数据结构：为目前已加锁的每个数据项维护一个链表，每一个请求为链表中一条记录，按请求到达的顺序排序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个锁请求消息到达时，如果相应的数据项的链表存在，在该链表末尾增加一个记录；否则新建一个仅包含该请求记录的链表。
&lt;ul&gt;
&lt;li&gt;在当前没有加锁的数据项上总是授予第一次加锁请求，但当事务向已被加锁的数据项申请加锁时，只有当该请求与当前持有的锁相容，并且所有先前的请求都已授予锁的条件下，锁管理器才为该请求授予锁，否则该请求只好等待。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当锁管理器收到一个事务的解锁消息时，它将与该事务相对应的数据项列表中的记录删除，然后检查随后的记录，如果有，如前所述，就看该请求能否被授权，如果能，锁管理器授权该请求并处理气候记录，如果还有，类似地一个接一个处理。&lt;/li&gt;
&lt;li&gt;如果一个事务中止，锁管理器删除该事务产生的正在等待加锁的所有请求。一旦数据库系统采取适当动作撤销该事务，该中止事务持有的所有锁将被释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于图的封锁协议对访问数据项的顺序加以限制，从而不需要使用两阶段封锁还能够保证可串行性，而且又能够保证不会产生死锁。&lt;/p&gt;
&lt;p&gt;许多种封锁协议都不能防止死锁。一种可以防止死锁的方法是使用数据项的一种顺序，并且按与该顺序一致的次序申请加锁。另一种防止死锁的方法是使用抢占的事务回滚。为控制抢占，我们给每个事务赋予一个唯一时间戳，这些时间戳用于决定事务是等待还是回滚。如果一个事务回滚，它在重启时保持原有时间戳。wound-wait机制是一个抢占机制。&lt;/p&gt;
&lt;p&gt;如果没有预防死锁，系统必须用死锁检测与恢复机制来处理它们。为此，系统构造了一个等待图。当且仅当等待图包含环时，系统处于死锁状态。当一个检测算法判断死锁存在，系统必须从死锁种恢复。系统通过回滚一个或多个事务来解除死锁。&lt;/p&gt;
&lt;p&gt;某些情况下把多个数据项聚为一组，将它们作为聚集数据项来处理，其效果可能更好，这就导致了粒度的多个级别。我们允许各种大小的数据项，并定义数据项的层次，其中小数据项嵌套于大数据项之中。这种层次结构可以图形化地表示为树。封锁按从根结点到叶结点的顺序进行；解锁则按从叶结点到根结点的讯息进行。该协议保证可串行性，但不能避免死锁。&lt;/p&gt;
&lt;p&gt;时间戳排序机制通过事先对每对事务之间选择一个顺序来保证可串行性。系统中的每个事务对应一个唯一的固定时间戳。事务的时间戳决定了事务的可串行化顺序。这样，如果事务T(i)的时间戳小于事务T(j)的时间戳，则该机制保证产生的调度等价于事务T(i)出现在事务T(j)之前的一个串行调度。该机制通过回滚违反该次序的事务来保证这一点。&lt;/p&gt;
&lt;p&gt;在大部分事务时只读的情形下，冲突频率很低，这种情况下有效性检查机制是一个适当的并发控制机制。系统中的每个事务对应一个唯一的固定时间戳。串行性次序是由事务的时间戳决定的。在该机制中，事务不会延迟。不过，事务要完成必须通过有效性检查。如果事务未通过有效性检查，则该事务回滚到初始状态。&lt;/p&gt;
&lt;p&gt;有效性检查协议要求每个事务T(i)在其生命周期中按两个或三个阶段执行，这取决于该事务时一个只读事务还是一个更新事务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读阶段：系统执行事务T(i)。各数据项值被读取并保存在事务T(i)的局部变量中。所有的write操作都是对局部临时变量进行的，并不对数据库进行真正的更新。&lt;/li&gt;
&lt;li&gt;有效性检查阶段：对事务T(i)进行有效性测试。判断是否可以执行write操作而不违反可串行性。如果事务有效性测试失败，则系统终止这个事务。&lt;/li&gt;
&lt;li&gt;写阶段：若事务T(i)已通过有效性检查，则保存T(i)任何写操作结果的临时局部变量值被复制到数据库中。只读事务忽略这个阶段。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多版本并发控制机制基于在每个事务写数据项时为该数据项创建一个新版本。读操作发出时，系统选择其中的一个版本进行读取。利用时间戳，并发控制机制保证按确保可串行性的方式选取要读取的版本。读操作总能成功。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在多版本时间戳排序中，写操作可能引起事务的回滚。&lt;/li&gt;
&lt;li&gt;在多版本的两阶段封锁中，写操作可能导致封锁等待或者死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;快照隔离时一种基于有效性检验的多版本并发控制协议，与多版本两阶段封锁协议不同，它不需要将事务声明为只读或更新的。快照隔离不保证可串行化，但是许多数据库系统仍然支持它。&lt;/p&gt;
&lt;p&gt;仅当要删除元组的事务在该元组上具有排他锁时，delete操作才能够进行。数据库中插入新元组的事务在该元组上被授予排他锁。&lt;/p&gt;
&lt;p&gt;插入操作可能导致幻象现象，这是插入操作与查询操作发生逻辑冲突，尽管两个事务可能没有存取共同的元组。如果封锁仅加在事务访问元组上，这种冲突就检测不到。关系中用于查找元组的数据需要加锁，索引封锁技术要求对某些索引结点加锁来解决这个问题。所加的锁保证所有事务在实际的数据项上发生冲突，而不是在幻象上。索引封锁协议运作如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个关系至少有一个索引。&lt;/li&gt;
&lt;li&gt;只有首先在关系的一个或多个索引上找到元组后，事务T(i)才能访问关系上的这些元组。为了达到索引封锁协议的目的，全表扫描看作一个索引上所有叶结点的扫描。&lt;/li&gt;
&lt;li&gt;进行查找（不管区间查找还是点查找）的事务T(i)必须在它要访问的所有索引叶结点上获得共享锁。&lt;/li&gt;
&lt;li&gt;在没有更新关系r上的所有索引之前，事务T(i)不能插入、删除或更新关系r中的元组t(i)。该事务必须获得插入、删除或更新所影响的所有索引叶结点上的排他锁。对于插入和删除，受影响的叶结点时那些（插入后）包含或（删除前）包含元组搜索码值的叶结点。对于更新，受影响的叶结点时那些（修改前）包含搜索码旧值的叶结点，以及（修改后）包含搜索码新值的叶结点。&lt;/li&gt;
&lt;li&gt;元组照常获得锁。&lt;/li&gt;
&lt;li&gt;必须遵循两阶段封锁协议规则。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;弱级别的一致性用于一些应用中，在这些应用中，查询结果的一致性不是至关重要的，而使用可串行性会使查询对事务的处理起反作用。二级一致性是这种弱级别的一致性之一，游标稳定性是二级一致性的一个特例，而且已被广泛应用。&lt;/p&gt;
&lt;p&gt;游标稳定性保证：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正被迭代处理的元组被加上共享锁。&lt;/li&gt;
&lt;li&gt;任何被更改的元组被加上排他锁，直至事务提交。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;跨越用户交互的事务并发控制是一个有挑战性的任务。应用程序通常实现一种基于采用元组中存储的版本号来验证写操作的机制。这种机制提供了弱可串行化水平，而且可以实现在应用层，而无需修改数据库。&lt;/p&gt;
&lt;p&gt;可以为特殊的数据结构开发特色的并发控制技术。通常，特色的技术用到B+树上，以允许较大的并发性。这些技术允许对B+树进行非可串行化访问，但它们保证B+树结构是正确的，并保证对数据库本身的存取是可串行化的。&lt;/p&gt;
&lt;h3 id=&#34;恢复系统&#34;&gt;恢复系统&lt;/h3&gt;
&lt;p&gt;数据库系统的一个重要组成部分就是恢复机制，它负责检测故障以及将数据库恢复至故障发生前的某一状态。恢复机制必须提供高可用性，必须将数据库崩溃后不能使用的时间缩减到最短。&lt;/p&gt;
&lt;p&gt;计算机中的各种存储器类型有易失存储器、非易失存储器和稳定存储器。易失存储器（如RAM）中的数据在计算机发生故障时会丢失。非易失性存储器（如磁盘）中的数据在计算机发生故障时一般不丢失，只是偶尔由于某些故障如磁盘故障才会丢失。稳定存储器中的数据从不丢失。&lt;/p&gt;
&lt;p&gt;必须能联机访问的稳定存储器用镜像磁盘或RAID的其他形式模拟，它提供冗余数据存储。脱机或归档稳定存储器可能是数据的多个磁带备份，并存放在物理安全的地方。&lt;/p&gt;
&lt;p&gt;一旦故障发生，数据库系统的状态可能不再一致，即它不能反映数据库试图保存的显示世界的状态。为保持一致性，我们要求每个事务都必须是原子的。恢复机制的责任就是要保证原子性和持久性。&lt;/p&gt;
&lt;p&gt;在基于日志的机制中，所有的更新都记入日志，并存放在稳定存储器中。当事务的最后一个日志记录，即该事务的commit的日志记录。输出到稳定存储器时，就认为这个事务已提交。&lt;/p&gt;
&lt;p&gt;日志记录包括所有更新过的数据项项的旧值和新值。当系统崩溃后需要对更新进行重做时，就使用新值。如果在正常操作中事务中止，回滚事务所做的更新时需要用到旧值；在事务提交之前发生系统崩溃的情况下，回滚事务所做的更新也需要用到旧值。&lt;/p&gt;
&lt;p&gt;在演出修改机制下，事务执行时所有write操作都要延迟到事务提交时才执行，那时，系统在执行延迟写中会用到日志中与该事务有关的信息。在延迟修改机制中，日志记录不需要包含已更新的数据项的旧值。&lt;/p&gt;
&lt;p&gt;为减少搜索日志和重做事务的开销，我们可以使用检查点技术。（a）在执行检查点操作的过程中不允许执行任何更新，（b）在执行检查点的过程中将所有更新过的缓冲块都输出到磁盘中。检查点执行过程如下：1、将当前位于主存的所有日志记录输出到稳定存储器；2、将所有修改的缓冲块输出到磁盘；3、将一个日志记录输出到稳定存储器，其中L是执行检查点时正活跃的事务的列表。&lt;/p&gt;
&lt;p&gt;当前恢复算法基于重复历史的概念，在恢复的重做简单重演（自最后一个已完成的检查点以来）正常操作中所做的所有动作。重复历史的做法将系统状态恢复到系统崩溃之前的最后一个日志记录输出到稳定存储器时的系统状态。然后从这个状态开始执行一个撤销阶段，反向处理未完成事务的日志记录。&lt;/p&gt;
&lt;p&gt;不完全事务的撤销写出特殊的redo-only日志记录和一个abort日志记录。然后就认为该事务已完成，不必再对它进行撤销。&lt;/p&gt;
&lt;p&gt;在事务处理所基于的存储模型中，主存储器中有一个日志缓冲区，一个数据库缓冲区和一个系统缓冲区。系统缓冲区中有系统目标码页面和事务的局部工作区域。&lt;/p&gt;
&lt;p&gt;恢复机制的高效实现需要尽可能减少向数据库和稳定存储器写出的数目。日志记录在开始时可以保存在易失性的日志缓冲区中，但是当下述情况之一发生时必须写到稳定性存储器中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&amp;lt;T(i), commit&amp;gt;日志记录可以输出到稳定存储器之前，在事务T(i)相关的所有日志记录必须已经输出到稳定存储器中。&lt;/li&gt;
&lt;li&gt;在主存中的一个数据库输出到（非易失性存储器中的）数据库之前，与该块中的数据相关的所有日志记录必须已经输出到稳定存储器中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当前的恢复技术支持高并发性封锁技术，例如用户B+树并发控制的封锁记录。这些技术允许提前释放通过插入或删除这样的操作获得的低级别的锁，低级别的锁允许别的事务其他的这些操作可以执行。低级别的锁被释放之后，不能进行物理undo，而需要进行逻辑undo，例如，用删除来对一个插入操作undo。事务保持高级别的锁以确保并发的事务不会执行这样的动作，它可能导致一个操作的逻辑undo是不可能的。&lt;/p&gt;
&lt;p&gt;为从造成非易失性存储器中数据丢失的故障中恢复，我们必须周期性地将整个数据库的内容转储到稳定存储器中–例如每天一次。如果发生了导致物理数据库块丢失的故障，我们使用最近一次转储将数据库恢复至前面的某个一致状态。一旦完成该恢复，我们再用日志将数据库系统恢复至最当前的一致状态。&lt;/p&gt;
&lt;p&gt;ARIES恢复机制支持一些提供更大并发性，削减日志开销和最小化恢复时间的特性。它也是基于重复历史的，并允许逻辑undo操作。该机制连续不断地清洗页，从而不需要检查点时清洗所有页。它使用日志顺序号（LSN）来实现各种优化从而减少恢复所花的时间。从系统崩溃中恢复的过程经历三个阶段：1、分析阶段：决定哪些事务要撤销，哪些页在崩溃时时脏的，以及重做阶段应从哪个LSN开始；2、redo阶段：从分析阶段决定的位置开始，执行重做，重复历史，将数据库恢复到发生崩溃前的状态；3、undo阶段：回滚在发生崩溃时那些不完全的事务。&lt;/p&gt;
&lt;p&gt;远程备份系统提供了很高程度的可用性，允许事务处理即使在主站点遭受火灾、洪水或地震的破坏时也能继续。主站点上的数据和日志记录连续不断地备份到远程备份站点。如果主站点发生故障，远程备份站点就执行一定的恢复动作，然后接管事务处理。&lt;/p&gt;
&lt;h2 id=&#34;系统体系结构&#34;&gt;系统体系结构&lt;/h2&gt;
&lt;h3 id=&#34;数据库系统体系结构&#34;&gt;数据库系统体系结构&lt;/h3&gt;
&lt;p&gt;集中式数据库系统完全运行在单台计算机上。随着个人计算机和局域网的发展，数据库前端功能不断移向客户机，而后端功能由服务器系统提供。客户-服务器接口协议推动了客户-服务器数据库系统的发展。&lt;/p&gt;
&lt;p&gt;服务器可以是事务服务器，也可以是数据服务器。尽管在提供数据库服务方面，事务服务器的使用大大超过数据服务器的使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务服务器有多个进程，可能运行在多个处理器上。所以这些进程要访问公共数据，比如数据库缓冲区，系统将这些数据存放在共享内存中。除了处理查询的进程，还有执行诸如锁和日志管理以及检查点等任务的系统进程。&lt;/li&gt;
&lt;li&gt;数据服务器系统提供给用户的是为加工的数据。这样的系统通过把数据和锁高速缓存在客户端，来努力使客户端和服务器之间的通信最小化。并行数据库系统使用类似的优化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并行数据库系统由通过高数互联网连接在一起的多台处理器和多张硬盘构成。加速比衡量通过增加并行性可以得到的对单个事务的处理数据的增长。扩展比衡量通过增加并行性可以的带的处理大量事务的能力。干扰、偏斜和启动代价是得到理想的加速比和扩展比的障碍。&lt;/p&gt;
&lt;p&gt;并行数据库系统结构包括共享内存、共享硬盘、无共享以及层次的体系结构。这些体系结构在可扩展性以及通信速度方面各有千秋。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享内存的优点在于处理器之间的通信效率极高，存放在共享内存中的数据可以被任何处理器访问，而不需要由软件来移动。共享内存机器的缺点是这种体系结构的规模不能超过32个或64个处理器。因为总线或互联网络会变成瓶颈（因为它是所有处理器共享的）。&lt;/li&gt;
&lt;li&gt;共享硬盘体系结构有两个优点：1、由于每个处理器都有自己的主存储器，因此存储器总线不再是瓶颈了；2、这种体系结构给出了一个经济的方法来提供一定程度的容错性（如果一个处理器或者它的主存储器发生故障，其他处理器可以代替它的工作，这是因为数据库驻留在磁盘上，而磁盘是所有处理器都可以访问的）。虽然存储器总线不再是瓶颈，但与磁盘子系统互连现在成为了瓶颈。&lt;/li&gt;
&lt;li&gt;无共享提供的主要缺点是通信的代价和非本地磁盘访问的代价，这些代价比共享内存或共享硬盘体系结构中的代价要高，因为数据传送涉及两端的软件交互。&lt;/li&gt;
&lt;li&gt;层次的体系结构综合了共享内存、共享硬盘和无共享体系结构的特点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分布式数据库系统是部分独立的一组数据库系统，它们共享一个公共模式（理想情况下），并且协调地处理访问非本地数据库的事务。系统之间通过通信网络来相互通信。&lt;/p&gt;
&lt;p&gt;局域网连接分布在小的地理范围内的结点，比如连接单个建筑或几个相邻建筑。广域网连接分布在大的地理范围内的结点。现在Internet是使用最广泛的广域网。&lt;/p&gt;
&lt;p&gt;存储区域网是一种特殊形式的局域网，是为大型存储设备和多台计算机之间提供快速互连而设计的。&lt;/p&gt;
&lt;h3 id=&#34;并行数据库&#34;&gt;并行数据库&lt;/h3&gt;
&lt;p&gt;在I/O并行中，把关系划分到多张可用的磁盘中，从而使检索速度更快。三种常用的划分技术使轮转法划分，散列划分和范围划分。（一般而言，更倾向于使用散列划分和范围划分，而不是轮转法划分）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轮转法：适合于希望对每个查询顺序地读取整个关系的应用。&lt;/li&gt;
&lt;li&gt;散列划分：适合于机遇划分属性的点查询。&lt;/li&gt;
&lt;li&gt;范围划分：适合于在划分属性上的点查询和范围查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;偏斜式一个主要的问题，特别是当并行度增高时。平衡的划分向量、使用直方图以及虚处理器划分是用于减少偏斜的技术。属性值偏斜指的是某些值出现在许多元组的划分属性中。划分偏斜指的是，即使不存在属性值偏斜，划分也可能会出现负载不均衡。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过为每个关系的每个属性创建和存储该属性值的频率表或直方图，可以降低由于构建平衡的范围划分向量而产生的I/O开销。&lt;/li&gt;
&lt;li&gt;使用虚处理器，特别是针对范围划分带来的偏斜，可以使偏斜的影响达到最小。核心思想是：即使由于偏斜使得在一个范围内有比其他范围更多的元组，这些元组也将划分到多个虚处理器的范围上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在查询间并行中，并发地运行不同的查询以提高吞吐量。共享磁盘系统中协议保证，当事务对页面设置共享锁或排查锁时，能够得到该页面的正确版本：1、事务对一个页面进行任何读或写访问之前，先用相应的共享或排他模式封锁该页面。一旦事务获得了页面的共享锁或排他锁后，它立刻从共享磁盘中读取该页面的最新版本；2、在事务释放一个页面的排他锁之前，它将该页面刷新到共享磁盘中，然后释放锁。&lt;/p&gt;
&lt;p&gt;查询内并行指的是单个查询在多个处理器和磁盘上并行执行，试图减少运行查询的代价。两类查询内并行：1、操作内并行，通过并行地执行每一个运算来加快一个查询的处理速度；2、操作间并行，通过并行地执行一个查询表达式中的多个不同的运算，来加快一个查询的处理速度。&lt;/p&gt;
&lt;p&gt;采用操作内并行来并行地执行关系运算，例如排序和连接。因为关系运算是面向集合的，所以操作内并行对关系运算是很自然的。&lt;/p&gt;
&lt;p&gt;对于像连接这样的二元运算，有两种基本的并行化的方法（这两种并行技术都可以与任何一种连接技术结合使用）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在基于划分的并行中，两个关系分成几个部分，而且r(i)中的元组仅与s(i)中的元组进行连接。基于划分的并行仅适用于自然连接和等值连接。&lt;/li&gt;
&lt;li&gt;在分片和复制中，两个关系都被划分，并且每个划分都被复制。在非对称的分片和复制中，一个关系被复制，而另一个关系被划分。与机遇划分的并行不同，分片和复制以及非对称的分片和复制对于任何连接条件都是用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在独立的并行中，互不依赖的多个不同的操作按并行方式执行。&lt;/p&gt;
&lt;p&gt;在流水线并行中，处理器在计算一个操作结果的同时将结果发送给另一个操作，无须等待整个操作的完成。&lt;/p&gt;
&lt;p&gt;两个常用启发式方法来减少需要考虑的并行执行计划的数目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仅考虑那些利用所有的处理器，对每个运算都并行化，并且不采用任何流水线的执行计划。&lt;/li&gt;
&lt;li&gt;选择最搞笑的串行执行计划，然后将该执行计划中的运算并行化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式数据库&#34;&gt;分布式数据库&lt;/h3&gt;
&lt;p&gt;分布式数据库系统由站点的集合构成，每个站点维护一个本地数据库系统。各个站点能够处理局部事务：这些事务访问的数据仅位于该单个站点上。此外，站点可以参与到全局事务的执行中：这些全局事务访问多个站点上的数据。全局事务的执行需要在站点之间进行通信。&lt;/p&gt;
&lt;p&gt;分布式数据库可能是同构的，其中所有站点拥有共同的模式和数据库系统代码，或者是异构的，其中模式和系统代码可能不同。&lt;/p&gt;
&lt;p&gt;关于在分布式数据库中存储关系涉及几个问题，包括复制和分片。系统应尽量减小用户需要了解关系如何存储的程度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;水平分片：通过将r的每个元组分给一个或多个分片来划分关系&lt;/li&gt;
&lt;li&gt;垂直分片：通过对关系r的模式R进行分解来划分关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据透明性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分片透明性：用户不要求知道关系是如何分片的&lt;/li&gt;
&lt;li&gt;复制透明性：在用户看来，每个数据对象逻辑上都是唯一的。分布式系统可能为了提高系统性能或者数据可用性而复制对象，用户不必关系什么数据对象被复制了，也不必关系副本存放在何处。&lt;/li&gt;
&lt;li&gt;位置透明性：用户无须知道数据的物理位置。只要用户事务提供数据标示符，分布式数据库系统应能够找到任何数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;局部事务是那些只在一个局部数据库中访问和更新数据的事务；全局事务是那些多个局部数据库中访问和更新数据的事务。&lt;/p&gt;
&lt;p&gt;每个站点都有其自身的局部事务管理器，其功能是保证在该站点上执行的那些事务的ACID特性。各个事务管理器相互协作以执行全局事务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务管理器：管理那些访问存储在一个局部站点中的数据的事务（或子事务）的执行。注意每个这样的事务既可以是局部事务也可以是全局事务的一部分。
&lt;ul&gt;
&lt;li&gt;维护一个用于恢复目的的日志&lt;/li&gt;
&lt;li&gt;参与到一个合适的并发控制方案，以协调在该站点上执行的事务的并发执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事务协调器：协调在该站点上发起的各个事务的执行。
&lt;ul&gt;
&lt;li&gt;启动事务的执行&lt;/li&gt;
&lt;li&gt;将事务分成一些子事务，并将这些子事务分派给合适的站点去执行&lt;/li&gt;
&lt;li&gt;协调事务的中止，这可能导致事务在所有站点上都提交或者所有站点上都中止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分布式系统可能遭受与集中式系统相同类型的故障。但是，分布式环境中还有另外一些需要处理的故障，包括站点故障、链路故障、消息丢失以及网络划分。在分布式故障恢复模式的设计中需要考虑每个这样的问题。&lt;/p&gt;
&lt;p&gt;为了保证原子性，执行事务T的所有站点必须在执行的最终结果上取得一致。T要么在所有站点上提交，要么在所有站点上中止。为了保证这一特性，T的事务协调器必须执行一种提交协议。使用最广泛的提交协议是两阶段提交协议。&lt;/p&gt;
&lt;p&gt;两阶段提交协议可能导致阻塞，在这种情况下，事务的命运必须等到故障站点（协调器）恢复后才能确定。为了减少阻塞的可能性，可以使用三阶段提交协议。&lt;/p&gt;
&lt;p&gt;持久消息为分布式事务处理提供了一种可选模式。该模式将单个事务拆分成在不同数据库执行的多个部分。持久消息（无论是否发生故障。都保证正好只传送一次）被传送到需要采取动作的远程站点。虽然需要持久消息避免阻塞问题，但是应用程序开发者必须编写代码来处理各种类型的故障。&lt;/p&gt;
&lt;p&gt;在集中式系统中使用各种并发控制方案修改后可用于分布式环境。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;就封锁协议而言，须做的唯一改变是锁管理器的实现方式。可以采用一个或多个中央协调器。如果拆用分布式锁管理器，复制数据就必须特殊对待。&lt;/li&gt;
&lt;li&gt;处理已复制数据的协议包括主副本协议、多数协议、有偏协议和法定人数同意协议。它们在开销方面和发生故障时工作的能力方面各有不同的取舍权衡。&lt;/li&gt;
&lt;li&gt;就时间戳和有效性演奏方案而言，所需的唯一修改是开发一种产生全局唯一性时间戳的机制。&lt;/li&gt;
&lt;li&gt;许多数据库系统支持延迟复制，其中更新被传播到执行更新的事务的范围之外的副本。这样的工具必须小心使用，因为他们可能导致不可串行化的执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分布式锁管理器环境中的死锁检测需要多个站点之间的合作，因为甚至在没有局部死锁的情况下也可能有全局死锁。&lt;/p&gt;
&lt;p&gt;为了提高可用性，分布式诗句哭必须检测故障，重构系统以使计算机能够继续进行，并在处理器或链路修复之后能够恢复。由于要在网络划分和站点股掌之间进行区分是很困难的，因此这个任务就变得非常复杂。通过使用版本号，可以对多数协议进行扩展使其即使存在故障的情况下仍允许进行事务处理。虽然该协议代价昂贵，但它无论在何种类型的故障下都能工作。可以使用较小代价的协议来处理站点故障，但是它们艰涩不会发生网络划分。&lt;/p&gt;
&lt;p&gt;一些分布式算法需要使用协调器。为了提供高可用性，系统必须维护一个准备好的在协调器故障时能继续其支者的备份副本。另一种方法是在协调器发生故障后选出新的协调器。确定哪个站点应该作为协调器的算法称为选举算法。&lt;/p&gt;
&lt;p&gt;分布式数据库上的查询可能需要访问多个站点。可以使用集中优化技术来识别需要访问的最佳站点集。查询可以依据关系的分片来自动重写没然后可以在每个分片的副本之间做出选择。可以应用半连接技术减少跨不同站点的关系（或相应的分片或副本）连接中所涉及的数据传输。&lt;/p&gt;
&lt;p&gt;异构分布式数据库允许站点有它们自己的模式和数据库系统代码。多数数据库系统提供了一种环境，在其中新的数据库应用可以访问位于多重易购软硬件环境的各个先前存在数据库中的数据。局部数据库系统可以采用不同的逻辑模型以及数据定义和数据操纵语言，并且可以在它们的并发控制和事务管理机制上存在差别。多数据库系统虚拟了逻辑上的数据库集成，不需要物理上的数据库集成。&lt;/p&gt;
&lt;p&gt;为了响应超大规模Web应用对数据存储的需求，近年来在云上构建了大量数据存储系统。这些数据存储系统允许扩展到地里上分布的数千个结点上，而且具有高可用性。然而，它们并不支持通常的ACID特性，而且在划分时以副本一致性为代价来获得可用性。&lt;/p&gt;
&lt;p&gt;目录系统可视为一何总特殊形式的数据库，其中信息按照一种分层的方式组织，类似于文件系统中文件的组织方式。目录通过标准化目录访问协议（例如LDAP）来访问。目录可以分布到多个站点上来提供各个站点的自治。目录可以包含对其他目录的引用，这有助于建立集成视图，借此查询被发送给单个目录，并且在所有相关的目录上透明地执行。&lt;/p&gt;
&lt;h2 id=&#34;数据仓库数据挖掘和信息检索&#34;&gt;数据仓库、数据挖掘和信息检索&lt;/h2&gt;
&lt;h3 id=&#34;数据仓库与数据挖掘&#34;&gt;数据仓库与数据挖掘&lt;/h3&gt;
&lt;p&gt;数据仓库是从多个数据源种进行数据采集，并以一种共同的、统一的数据库模式进行存储的数据仓储。存放在数据仓库中的数据将用于各种复杂聚集和统计分析。&lt;/p&gt;
&lt;p&gt;决策支持系统分析由事务处理系统收集的在线数据，以帮助人们做出商业决策。由于现在大多数组织结构都进行了广泛的计算机化，因此有非常大量的信息可用于决策支持。决策支持系统有不同的形式，包括OLAP系统和数据挖掘系统。&lt;/p&gt;
&lt;p&gt;数据仓库有助于收集和归档重要的操作数据。数据仓库用于基于历史数据的决策支持和分析，例如趋势预测。对来自输入数据源的数据进行清理通常是数据仓库中的一项重要任务。数据仓库的模式一般是多维的，包括一个或一些非常大的事实表以及几个小得多的维表。&lt;/p&gt;
&lt;p&gt;在很多数据仓库应用程序中，面向列的存储系统能提供良好的性能。&lt;/p&gt;
&lt;p&gt;**数据挖掘是一个能半自动地分析大型数据库以找出有用的模式的过程。**数据挖掘的引用有许多，比如基于以往示例的数值预测，购买行为关联的发现，以及人和电影的自动聚类。&lt;/p&gt;
&lt;p&gt;分类处理的事：基于训练用例的属性和训练用例实际所属的类，通过利用测试用例的属性来预测测试用例所属类。分类器类型有很多种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;决策树分类器。这种分类器通过基于训练用例所构造的一棵树来执行分裂，该树的叶节点具有类别标签。对每个测试用例遍历这棵树以找到一个叶节点，该叶节点所属的类即是预测的类。有几种技术可用于构造决策树，其中大部分是基于贪心的启发式方法。&lt;/li&gt;
&lt;li&gt;贝叶斯分类器放入构造比决策树分类器更简单，并且在属性值缺失或为空的情况下工作得更好。&lt;/li&gt;
&lt;li&gt;支持向量机是另一种广泛应用的分类技术。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关联规则识别经常同时出现的项，比如同一位孤苦可能购买的一些商品。相互关联找出与期望关联等级的偏离。&lt;/p&gt;
&lt;p&gt;其他类型的数据挖掘包括聚类、文本挖掘和数据可视化。&lt;/p&gt;
&lt;h3 id=&#34;信息检索&#34;&gt;信息检索&lt;/h3&gt;
&lt;p&gt;信息检索系统用于存储和查询如文档那样的文本数据。与数据库系统相比，它们使用更将蛋的数据模型，但能够在首先的模型里提供更强大的查询能力。&lt;/p&gt;
&lt;p&gt;查询试图通过指定关键字集合来定位用户感兴趣的文档。用户心里所想的查询往往不能精确的表述，因此，信息检索系统基于潜在的相关性对答案的排名。&lt;/p&gt;
&lt;p&gt;相关性排名利用多种类型的信息。1、术语频率：每个术语对美分文档的重要性；2、逆文档频率；3、流行度排名。&lt;/p&gt;
&lt;p&gt;文档相似性用于检索与一个示例文档相似的文档。余弦度量值用于定义相似度，它基于向量空间模型。&lt;/p&gt;
&lt;p&gt;PageRank和链接中心/权威页排名是基于指向页面的链接对页面威望度赋值的两种方法。PageRank度量可以用随机游走模型来直观地理解。锚文本信息也可以用来计算单个关键字意义上的流行度。信息检索系统需要整合多种因素（包括TF-IDF和PageRank）来获得对页面的全局评分。&lt;/p&gt;
&lt;p&gt;搜索引擎作弊试图使一个页面得到高的（但不是应得的）排名。&lt;/p&gt;
&lt;p&gt;同义词和多义词使信息检索的任务复杂化。基于概念的查询旨在找到含有指定概念的文档，而与指定该概念所使用的确切的词（以及语言）无关。本体利用诸如is-a或者part-of这样的关系将概念联系起来。&lt;/p&gt;
&lt;p&gt;倒排索引用来对关键字查询做出应答。&lt;/p&gt;
&lt;p&gt;查准率和查全率是信息检索系统有效性的两种度量。&lt;/p&gt;
&lt;p&gt;Web搜索引擎使用爬虫搜索Web找到网页，然后分析它们以计算其威望度度量，并为它们建立索引。&lt;/p&gt;
&lt;p&gt;目录结构和分类用来将文档和其他相似的文档归类到一起。&lt;/p&gt;
&lt;h2 id=&#34;特种数据库&#34;&gt;特种数据库&lt;/h2&gt;
&lt;h3 id=&#34;基于对象的数据库&#34;&gt;基于对象的数据库&lt;/h3&gt;
&lt;h3 id=&#34;xml&#34;&gt;XML&lt;/h3&gt;
&lt;h2 id=&#34;高级主题&#34;&gt;高级主题&lt;/h2&gt;
&lt;h3 id=&#34;高级应用开发&#34;&gt;高级应用开发&lt;/h3&gt;
&lt;p&gt;调整数据库系统参数和更高级别的数据库设计（如模式、索引和事务）对于实现高性能至关重要。查询可以进行调整以提高集合面向性，而批量加载功能可以大大加快数据导入到数据库中的速度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调整的最好方法就是确定瓶颈所在，然后消除瓶颈。数据库系统通常有多种可调参数，如缓冲区大小、内存大小和磁盘数量。可以选择适当的缩影和物化试图集合，以使总体代价达到最小。可以调整事务使锁竞争达到最小。快照隔离和支持早起锁释放的序号编号功能是减少读写和写写竞争的有用工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性能基准程序在对数据库系统进行比较方面扮演了重要的角色，尤其在数据库系统变得越来越与标准兼容时。TPC基准程序集使用广泛，不同的TPC基准程序可以用于不同的工作负载下的数据库系统性能比较。&lt;/p&gt;
&lt;p&gt;应用程序在开发时和部署前需要进行大量大测试。测试用来捕获错误的，以及确保到达性能目标。&lt;/p&gt;
&lt;p&gt;遗产系统是基于老一代技术（如非关系数据库或甚至直接基于文件系统）的系统。当运行关键人物系统时，遗产系统与新一代系统之间的连接通常是很重要的。从遗产系统到新一代系统的移植必须非常小心以避免破坏，这种移植是非常昂贵的。&lt;/p&gt;
&lt;p&gt;由于数据库系统的复杂性和互操作的需要，标准对数据库系统来说很重要。SQL有其正式标准。事实标准（如ODBC和JDBC）和被行业组织所采纳的标准（如CORBA），在客户-服务器数据库系统的发展中发挥了重要作用。&lt;/p&gt;
&lt;h3 id=&#34;时空数据和移动性&#34;&gt;时空数据和移动性&lt;/h3&gt;
&lt;p&gt;存储关于真实世界的时间经历状态的信息的数据库叫做时态数据库。&lt;/p&gt;
&lt;p&gt;时态关系中的事实与当它们有效时的时间相关联，而时间可以用时段的并来表示。时态查询语言简化了时间建模以及与时间相关的查询。&lt;/p&gt;
&lt;p&gt;设计数据主要以矢量数据的形式存储；地理数据包含矢量数据和光栅数据的结合。空间完整性约束对于设计数据库十分重要。光栅数据由二维或更高维的位图或像素图组成。矢量数据由基本集合对象构成，如点、线段、折线、三角形和其他二维多边形，以及圆柱体、球体、立方体和其他三维多面体。&lt;/p&gt;
&lt;p&gt;矢量数据库可以编码成第一范式，或者用非第一范式结构来存储，如列表。专用索引结构对于访问空间数据和处理空间查询尤为重要。&lt;/p&gt;
&lt;p&gt;R树是B树的多维扩展；它和它的变体（如R+树和R*树）在空间数据库中得到了广泛的应用。将空间以某种固定方式进行划分和索引结构（如四叉树）有助于处理空间连接查询。&lt;/p&gt;
&lt;h3 id=&#34;高级事务处理&#34;&gt;高级事务处理&lt;/h3&gt;
&lt;h2 id=&#34;实例研究&#34;&gt;实例研究&lt;/h2&gt;
&lt;h3 id=&#34;postgresql&#34;&gt;PostgreSQL&lt;/h3&gt;
&lt;h3 id=&#34;oracle&#34;&gt;Oracle&lt;/h3&gt;
&lt;h3 id=&#34;ibm-db2-universal-database&#34;&gt;IBM DB2 Universal Database&lt;/h3&gt;
&lt;h3 id=&#34;microsoft-sql-server&#34;&gt;Microsoft SQL Server&lt;/h3&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://feiybox.com/2020/11/25/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/&#34;&gt;【笔记】数据库系统概念&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Data Management and Data Systems</title>
      <link>http://www.yezheng.pro/post/specialization/systems/data-management-and-data-systems/cs145/</link>
      <pubDate>Fri, 19 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/specialization/systems/data-management-and-data-systems/cs145/</guid>
      
        <description>&lt;h2 id=&#34;why-databases&#34;&gt;Why Databases?&lt;/h2&gt;
&lt;p&gt;Concepts: Data models, DB systems overview&lt;/p&gt;
&lt;h2 id=&#34;sql-i&#34;&gt;SQL I&lt;/h2&gt;
&lt;p&gt;Concepts: Schemas, Systems, Select-From-Where
See Course Info for general submission information and the regrade policy.&lt;/p&gt;
&lt;h2 id=&#34;sql-ii&#34;&gt;SQL II&lt;/h2&gt;
&lt;p&gt;Concepts: Joins, Set operators, Subqueries&lt;/p&gt;
&lt;h2 id=&#34;sql-iii&#34;&gt;SQL III&lt;/h2&gt;
&lt;p&gt;Advanced Concepts: Grouping, Aggregations, Nested queries
9:30 AM — 10:20 AM Remote&lt;/p&gt;
&lt;h2 id=&#34;scale-indexing-and-io-model&#34;&gt;Scale: Indexing and IO Model&lt;/h2&gt;
&lt;h2 id=&#34;sorting-building-indices-part-1&#34;&gt;Sorting, Building Indices Part 1&lt;/h2&gt;
&lt;h2 id=&#34;b-trees-query-optimization-part-1&#34;&gt;B+ Trees Query Optimization Part 1&lt;/h2&gt;
&lt;p&gt;See Course Info for general submission information and the regrade policy.&lt;/p&gt;
&lt;h2 id=&#34;query-optimization-part-2&#34;&gt;Query Optimization Part 2&lt;/h2&gt;
&lt;p&gt;9:30 AM — 10:20 AM Remote
Guest Lecture Dr. Girish Baliga &amp;ndash; On Presto and Vertica at Uber Dr. Theo Vassilakis (ex-CTO at Grab) &amp;ndash; early lead on Dremel/BigQuery, CEO of Metanautix&lt;/p&gt;
&lt;h2 id=&#34;systems-design-putting-it-all-together&#34;&gt;Systems Design: Putting it all together&lt;/h2&gt;
&lt;p&gt;Exam Review
Check out Piazza for more information!
See Course Info for general submission information and the regrade policy.&lt;/p&gt;
&lt;h2 id=&#34;transactions&#34;&gt;Transactions&lt;/h2&gt;
&lt;p&gt;9:30 AM — 10:20 AM Remote
Cancelled due to election day.
Transactions&lt;/p&gt;
&lt;h2 id=&#34;er-model-and-design-theory&#34;&gt;E/R Model and Design Theory&lt;/h2&gt;
&lt;p&gt;TBA&lt;/p&gt;
&lt;h2 id=&#34;design-theory-continued&#34;&gt;Design Theory Continued&lt;/h2&gt;
&lt;p&gt;9:30 AM — 10:20 AM Remote
Guest Lecture&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://cs145-fa20.github.io/&#34;&gt;Data Management and Data Systems&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Hands-On Docker for Microservices with Python</title>
      <link>http://www.yezheng.pro/post/specialization/web-application/microservices/hands-on_docker_for_microservices_with_python/</link>
      <pubDate>Fri, 19 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/specialization/web-application/microservices/hands-on_docker_for_microservices_with_python/</guid>
      
        <description>&lt;h2 id=&#34;preface&#34;&gt;Preface&lt;/h2&gt;
&lt;p&gt;For the technical aspects, we will use well-tailored tools, including the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Python&lt;/strong&gt;, to implement RESTful web services&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Git&lt;/strong&gt; source control, to track the changes in an implementation, and &lt;strong&gt;GitHub&lt;/strong&gt;, to share those changes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker&lt;/strong&gt; containers, to standardize the operation of each of the microservices&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubernetes&lt;/strong&gt;, to coordinate the execution of multiple services&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cloud services&lt;/strong&gt;, such as &lt;strong&gt;Travis CI&lt;/strong&gt; or &lt;strong&gt;AWS&lt;/strong&gt;, to leverage existing commercial solutions to problems&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will also cover practices and techniques for working effectively in a microservice oriented environment, the most prominent being the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Continuous integration&lt;/strong&gt;, to ensure that services are of a high quality and ready to be deployed&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GitOps&lt;/strong&gt;, for &lt;strong&gt;handling changes in infrastructure&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Observability&lt;/strong&gt; practices, to properly understand what is happening in a live system&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Practices and techniques&lt;/strong&gt; aimed at improving teamwork, both within a single team and across multiple teams&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;chapter-1-making-the-move--design-plan-and-execute&#34;&gt;Chapter 1: Making the Move – Design, Plan, and Execute&lt;/h2&gt;
&lt;h4 id=&#34;the-traditional-monolith-approach-and-its-problems&#34;&gt;The traditional monolith approach and its problems&lt;/h4&gt;
&lt;p&gt;Python Django application for our monolith example.&lt;/p&gt;
&lt;p&gt;The monolith example can be found at: &lt;a href=&#34;https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith&#34;&gt;https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In the context of web applications, that means creating deployable code that can be replicated so that &lt;strong&gt;requests can be directed to any of&lt;/strong&gt; the deployed copies.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;one or more servers (physical boxes, virtual machines, and cloud instances such as EC2 and more) running a web server application
(such as NGINX or Apache) to direct requests directed to HTTP port 80 or HTTPS port 443 toward one or more Python workers (normally, through
the WSGI protocol), run by mod_wsgi—https://github.com/GrahamDumpleton/mod_wsgi (Apache only), uWSGI, GNUnicorn, and so on.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;problems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The code will increase in size, the complexity naturally tends to increase, making it more difficult to change the code in certain ways.&lt;/li&gt;
&lt;li&gt;Inefficient utilization of resources&lt;/li&gt;
&lt;li&gt;Issues with development scalability, the development team grows, once several teams are working on the same code base, the probability of clashing will increase.&lt;/li&gt;
&lt;li&gt;Deployment limitations&lt;/li&gt;
&lt;li&gt;Interdependency of technologies&lt;/li&gt;
&lt;li&gt;A bug in a small part of the system can bring down the whole service.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;the-characteristics-of-a-microservices-approach&#34;&gt;The characteristics of a microservices approach&lt;/h4&gt;
&lt;p&gt;A system following a microservices architecture is &lt;strong&gt;a collection of loosely coupled specialized services&lt;/strong&gt;  (一组松散耦合的专用服务) that work in unison to provide a comprehensive service.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A collection of &lt;strong&gt;specialized services&lt;/strong&gt;, meaning that there are different, well defined modules.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loosely coupled&lt;/strong&gt;, meaning that each of the microservices can be independently deployed.&lt;/li&gt;
&lt;li&gt;That work in &lt;strong&gt;unison&lt;/strong&gt;—each microservice is capable of communicating with others.&lt;/li&gt;
&lt;li&gt;To provide a &lt;strong&gt;comprehensive service&lt;/strong&gt;, because our microservice system will need to replicate the same functionalities that were available using a monolith approach. There is an intent behind its design.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note that there may be multiple workers per microservice&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;There are several &lt;strong&gt;advantages&lt;/strong&gt; and implications to this architecture:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the communication between microservices is done through a standard protocol, each microservice can be programmed in different languages.&lt;/li&gt;
&lt;li&gt;Better resource utilization—if Microservice A requires more memory, we can reduce the number of worker copies.&lt;/li&gt;
&lt;li&gt;Each individual service is smaller and can be dealt with independently. That means fewer lines of code to maintain, faster builds, and a simpler design, with less technical debt to maintain.&lt;/li&gt;
&lt;li&gt;Some services can be hidden from external access. In some scenarios, that can improve security, reducing the attack surface area for sensitive data or services.&lt;/li&gt;
&lt;li&gt;As the systems are independent, a stability problem in one won&amp;rsquo;t completely stop the system.&lt;/li&gt;
&lt;li&gt;Each service can be maintained independently by different developers.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;docker-containers&#34;&gt;Docker containers&lt;/h4&gt;
&lt;p&gt;Containers are a packetized bundle of software that encapsulates everything that is required to run, including all dependencies. It only requires a compatible OS kernel to run autonomously.&lt;/p&gt;
&lt;p&gt;Working with Docker containers has two steps. First, we &lt;strong&gt;build the container&lt;/strong&gt;, executing layer after layer of changes on the filesystem, such as adding the software and configuration files that will be executed. Then, we &lt;strong&gt;execute it&lt;/strong&gt;, launching its main command.&lt;/p&gt;
&lt;p&gt;An important factor for dealing with containers is that &lt;strong&gt;containers should be stateless&lt;/strong&gt; (Factor VI—https://12factor.net/processes). Any state needs to be stored in a database and each container stores no persistent data.&lt;/p&gt;
&lt;p&gt;Another advantage of Docker is the availability of a lot of ready-to-use containers.&lt;/p&gt;
&lt;h4 id=&#34;container-orchestration-and-kubernetes&#34;&gt;Container orchestration and Kubernetes&lt;/h4&gt;
&lt;p&gt;Though Docker presents on how to deal with each of the individual microservices, we will need an &lt;strong&gt;orchestrator&lt;/strong&gt; to handle the whole cluster of services.&lt;/p&gt;
&lt;h4 id=&#34;parallel-deployment-and-development-speed&#34;&gt;Parallel deployment and development speed&lt;/h4&gt;
&lt;p&gt;The single most important element is the capacity to deploy independently. The objective is to increase the number of deployments and the speed of each of them.&lt;/p&gt;
&lt;p&gt;The microservice architecture is strongly related to Continuous Integration and Continuous Deployment principles.&lt;/p&gt;
&lt;p&gt;As deploying a microservice should be transparent for dependent services, special attention should be paid to &lt;strong&gt;backward compatibility&lt;/strong&gt;. Some changes will need to be escalated and coordinated with other teams to remove old, incorrect functionality without interrupting the system.&lt;/p&gt;
&lt;h4 id=&#34;challenges-and-red-flags&#34;&gt;Challenges and red flags&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Systems get started as monoliths&lt;/strong&gt;, as it is simpler and allows for quicker iteration in a small code base.  As more and more developers get involved, t&lt;strong&gt;he advantages of a monolith start to become less evident&lt;/strong&gt;, and the need for long- term strategy and structure becomes more important. More structure doesn&amp;rsquo;t necessarily mean moving toward a microservice architecture. A great deal can be achieved with a well- architected monolith.&lt;/p&gt;
&lt;p&gt;Moving to microservices also has its own problems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Migrating to microservices requires a lot of effort, actively changing the way an organization operates, and a big investment until it starts to pay off.&lt;/li&gt;
&lt;li&gt;Debugging a request that moves across services is more difficult than a monolithic system. Monitoring the life cycle of a request is important and some subtle bugs can be difficult to replicate and fix in development.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A bad division line&lt;/strong&gt; can make two services tightly coupled, not allowing independent deployment. A red flag in that means almost any change to one service requires a change in the other, even if, normally, it could be done independently.&lt;/li&gt;
&lt;li&gt;Solid communication between teams is required to allow consensus and the reuse of common solutions. &lt;strong&gt;Be careful&lt;/strong&gt; when introducing (引入) &lt;strong&gt;shared code&lt;/strong&gt; across services. If the code grows, it will make services dependent on each other. This can reduce the independence of the microservices.&lt;/li&gt;
&lt;li&gt;The best approach is to create &lt;strong&gt;self-documenting&lt;/strong&gt; services. how to use tools to allow documenting how to use a service with minimal effort.&lt;/li&gt;
&lt;li&gt;Each call to another service, such as internal microservices calling each other, can increase the &lt;strong&gt;delay&lt;/strong&gt; of responses, as multiple layers will have to be involved. This can produce &lt;strong&gt;latency&lt;/strong&gt; problems, with external responses taking longer. They will also be affected by the performance and capacity of the internal network connecting the microservices.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;analyzing-the-current-system&#34;&gt;Analyzing the current system&lt;/h4&gt;
&lt;p&gt;The objective of this phase is to determine whether a change to microservices will actually be beneficial and to get an initial idea of what microservices will be the result of the migration.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Searching&lt;/strong&gt;:  Search is also read-only, so it may be a good idea to detach.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Authentication&lt;/strong&gt;: Splitting it will allow us to keep on track for new security issues and have a team specifically dealing with those issues.&lt;/li&gt;
&lt;li&gt;the new microservice will be the &lt;strong&gt;frontend&lt;/strong&gt;, which will be served as static, precompiled code, and calls a backend API to render the pages.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These are just some ideas, which will need to be discussed and evaluated. What are the specific pain points for your monolithic app? What is the roadmap and the strategic future? What are the most important points and features for the present or the future?&lt;/p&gt;
&lt;p&gt;The system will be divided into the following modules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Users backend&lt;/strong&gt;: This will have the responsibility for all &lt;strong&gt;authentication&lt;/strong&gt; tasks and keep &lt;strong&gt;information about the users&lt;/strong&gt;. It will store its data in the database.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Thoughts backend&lt;/strong&gt;: This will create and store thoughts.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Search backend&lt;/strong&gt;: This will allow searching thoughts.&lt;/li&gt;
&lt;li&gt;A proxy that will route any request to the proper backend. This needs to be externally accessible.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTML frontend&lt;/strong&gt;: This will replicate the current functionality. This will ensure that we work in a backward-compatible way and that the transition can be made smoothly.&lt;/li&gt;
&lt;li&gt;Allowing clients to access the backends will allow the creation of other clients than our HTML frontend. A &lt;strong&gt;dynamic frontend server&lt;/strong&gt; will be created, and thereare talks with an external company to create a mobile app.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Static assets&lt;/strong&gt;: A web server capable of handling static files. This will serve the styling for the HTML frontend and the index files and JavaScript files for the dynamic frontend.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;preparing-and-adapting-by-measuring-usage&#34;&gt;Preparing and adapting by measuring usage&lt;/h4&gt;
&lt;p&gt;The ability to know how a live system is working is called &lt;strong&gt;observability&lt;/strong&gt;. The main tools for it are &lt;strong&gt;metrics&lt;/strong&gt; and &lt;strong&gt;logs&lt;/strong&gt;. The problem you&amp;rsquo;ll find is that they will normally be configured to reflect external requests and give no information about internal modules.&lt;/p&gt;
&lt;p&gt;Remember that the most important element for the long-term success of the move to microservices is to allow teams to be independent. If you split across modules that constantly &lt;strong&gt;need to be changed in unison, deployments won&amp;rsquo;t be truly independent&lt;/strong&gt;, and, after the transition, you&amp;rsquo;ll be forced to work with two tightly coupled services.&lt;/p&gt;
&lt;h6 id=&#34;strategic-planning-to-break-the-monolith&#34;&gt;Strategic planning to break the monolith&lt;/h6&gt;
&lt;p&gt;Being realistic, the company&amp;rsquo;s business activities will not stop. That&amp;rsquo;s why a plan should be in place to allow a smooth transition between one state and the other.&lt;/p&gt;
&lt;p&gt;This is known as the &lt;strong&gt;strangler pattern&lt;/strong&gt; (&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/architecture/patterns/strangler&#34;&gt;https://docs.microsoft.com/en-us/azure/architecture/patterns/strangler&lt;/a&gt;)—replacing parts of a system gradually &lt;strong&gt;until the old system is &amp;ldquo;strangled&amp;rdquo; and can be removed safely&lt;/strong&gt;.&lt;/p&gt;
&lt;h6 id=&#34;the-replacement-approach&#34;&gt;The replacement approach&lt;/h6&gt;
&lt;p&gt;This black-box approach completely replaces existing functionality coding with an alternative from scratch. Once the new code is ready, it gets activated and the functionality in the old system is deprecated.&lt;/p&gt;
&lt;h6 id=&#34;the-divide-approach&#34;&gt;The divide approach&lt;/h6&gt;
&lt;p&gt;If the system is well structured, maybe some parts of it can be cleanly split into its own system, maintaining the same code.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Copy the code into its own microservice and deploy it.&lt;/li&gt;
&lt;li&gt;The old calling system is using the old embedded code.&lt;/li&gt;
&lt;li&gt;Migrate a call and check that the system is working fine.&lt;/li&gt;
&lt;li&gt;Iterate until all old calls are migrated to the new system.&lt;/li&gt;
&lt;li&gt;Delete the divided code from the old system.&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;change-and-structured-approach&#34;&gt;Change and structured approach&lt;/h6&gt;
&lt;p&gt;These three approaches can be combined to generate full migration. In this phase of the project, the objective is to have a clear roadmap.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;As a prerequisite, a load balancer will need to be in front of the operation. Changing the configuration of this element, we will be able to route the requests toward the old monolith or any new microservice.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A static web server, it will be deployed as an independent microservice.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The code for authentication will be replicated in a new service.It will use a RESTful API to log in and generate a session, and to log out.&lt;/p&gt;
&lt;p&gt;Generate a package, shared across the externally faced microservices, which will allow checking to see whether a session has been generated with our own service. This will be achieved by &lt;strong&gt;signing the session cryptographically&lt;/strong&gt; and &lt;strong&gt;sharing the secret across services&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The Users Backend needs to be able to allow authentication using &lt;strong&gt;OAuth 2.0&lt;/strong&gt; schema, which will allow other external services, not based on web browsers, to authenticate and operate, for example, a mobile app.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The new API will be added externally to the load balancer and promoted as externally accessible.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;executing-the-move&#34;&gt;Executing the move&lt;/h4&gt;
&lt;p&gt;we want to keep the services running and not have outages that interrupt our business.&lt;/p&gt;
&lt;p&gt;The single most important idea during this phase is backward compatibility.&lt;/p&gt;
&lt;h4 id=&#34;web-services-best-friend--the-load-balancer&#34;&gt;Web services&#39; best friend – the load balancer&lt;/h4&gt;
&lt;p&gt;For our purposes, a group of old web services that are behind a load balancer can add one or more replacement services that are backward compatible, without interrupting the operation. The new service replacing the old one will be added in small numbers (maybe one or two workers) to split the traffic in a reasonable configuration, and ensure that everything is working as expected. After the verification, replace it completely by stopping sending new requests to the old services, draining them, and leaving only the new servers.&lt;/p&gt;
&lt;p&gt;Any web server capable of acting in &lt;strong&gt;reverse proxy&lt;/strong&gt; mode, such as NGINX, is capable of working as a &lt;strong&gt;load balancer&lt;/strong&gt;, but, for this task, probably the most complete option is &lt;strong&gt;HAProxy&lt;/strong&gt; (&lt;a href=&#34;http://www.haproxy.org/)&#34;&gt;http://www.haproxy.org/)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Because a load balancer is a single point of failure, you&amp;rsquo;ll need to load balance your load balancer. The easiest way of doing it is creating several identical copies of HAProxy, as you&amp;rsquo;d do with any other web service, and &lt;strong&gt;adding a cloud provider load balancer on top&lt;/strong&gt;.&lt;/p&gt;
&lt;h4 id=&#34;keeping-the-balance-between-new-and-old&#34;&gt;Keeping the balance between new and old&lt;/h4&gt;
&lt;p&gt;The pilot phase – setting up the first couple of microservices
The consolidation phase – steady migration to microservices
The final phase – the microservices shop&lt;/p&gt;
&lt;h2 id=&#34;chapter-2-creating-a-rest-service-with-python&#34;&gt;Chapter 2: Creating a REST Service with Python&lt;/h2&gt;
&lt;h4 id=&#34;technical-requirements&#34;&gt;Technical requirements&lt;/h4&gt;
&lt;h4 id=&#34;analyzing-the-thoughts-backend-microservice&#34;&gt;Analyzing the Thoughts Backend microservice&lt;/h4&gt;
&lt;h6 id=&#34;understanding-the-security-layer&#34;&gt;Understanding the security layer&lt;/h6&gt;
&lt;p&gt;This security layer will come in the shape of a header. This header will contain information that is signed by the user backend, verifying its origin. It will take the form of a JSON Web Token (JWT), &lt;a href=&#34;https://jwt.io/introduction/,&#34;&gt;https://jwt.io/introduction/,&lt;/a&gt; which is a standard for this purpose.&lt;/p&gt;
&lt;p&gt;A JWT is not the only possibility for the token, and there are other alternatives such as storing the equivalent data in a session cookie or in more secure environments using similar modules such as PASETO (&lt;a href=&#34;https://github.com/paragonie/paseto)&#34;&gt;https://github.com/paragonie/paseto)&lt;/a&gt;. Be sure that you review the security implications of your system, which are beyond the scope of this book.&lt;/p&gt;
&lt;p&gt;With an understanding of how the authentication system is going to work, we can start designing the API interface.&lt;/p&gt;
&lt;h4 id=&#34;designing-the-restful-api&#34;&gt;Designing the RESTful API&lt;/h4&gt;
&lt;p&gt;It&amp;rsquo;s always good to have a brief reminder about REST before starting an API design, so you can check &lt;a href=&#34;https://restfulapi.net/&#34;&gt;https://restfulapi.net/&lt;/a&gt; for a recap.&lt;/p&gt;
&lt;h6 id=&#34;specifying-the-api-endpoints&#34;&gt;Specifying the API endpoints&lt;/h6&gt;
&lt;h4 id=&#34;defining-the-database-schema&#34;&gt;Defining the database schema&lt;/h4&gt;
&lt;h6 id=&#34;working-with-sqlalchemy&#34;&gt;Working with SQLAlchemy&lt;/h6&gt;
&lt;p&gt;The first approach is well represented by the Python database API specification (PEP 249—https://www.python.org/dev/peps/pep-0249/), which is followed by all major databases, such as psycopg2 (&lt;a href=&#34;http://initd.org/psycopg/&#34;&gt;http://initd.org/psycopg/&lt;/a&gt;) for PostgreSQL.&lt;/p&gt;
&lt;p&gt;For the second approach, the best-known example is probably the Django ORM (&lt;a href=&#34;https://docs.djangoproject.com/en/2.2/topics/db/)&#34;&gt;https://docs.djangoproject.com/en/2.2/topics/db/)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;SQLAlchemy (&lt;a href=&#34;https://www.sqlalchemy.org/&#34;&gt;https://www.sqlalchemy.org/&lt;/a&gt;) is quite flexible and can work on both ends of the spectrum. it can take an existing, complicated legacy database and map it, allowing you to perform simple operations easily and complicated operations in exactly the way you want.&lt;/p&gt;
&lt;h4 id=&#34;implementing-the-service&#34;&gt;Implementing the service&lt;/h4&gt;
&lt;h6 id=&#34;introducing-flask-restplus&#34;&gt;Introducing Flask-RESTPlus&lt;/h6&gt;
&lt;p&gt;Flask-RESTPlus adds some very interesting capabilities that allow for good developing practices and speed of development.&lt;/p&gt;
&lt;p&gt;We will use the connector for SQLAlchemy, Flask-SQLAlchemy (&lt;a href=&#34;https://flask-sqlalchemy.palletsprojects.com/en/2.x/)&#34;&gt;https://flask-sqlalchemy.palletsprojects.com/en/2.x/)&lt;/a&gt;. Its documentation covers most of the common cases, while the SQLAlchemy documentation is more detailed and can be a bit overwhelming. To run the tests, the pytest-flask module (&lt;a href=&#34;https://pytest-flask.readthedocs.io/en/latest/&#34;&gt;https://pytest-flask.readthedocs.io/en/latest/&lt;/a&gt;) creates some fixtures ready to work with a Flask application. We will talk more about this in the Testing the code section.&lt;/p&gt;
&lt;h6 id=&#34;handling-resources&#34;&gt;Handling resources&lt;/h6&gt;
&lt;h6 id=&#34;parsing-input-parameters&#34;&gt;Parsing input parameters&lt;/h6&gt;
&lt;h6 id=&#34;serializing-results&#34;&gt;Serializing results&lt;/h6&gt;
&lt;h6 id=&#34;performing-the-action&#34;&gt;Performing the action&lt;/h6&gt;
&lt;h6 id=&#34;authenticating-the-requests&#34;&gt;&lt;strong&gt;Authenticating the requests&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;Note that we are using a private/public key schema, instead of a symmetric key schema, to encode and decode the tokens. This means that the decoding and encoding keys are different.&lt;/p&gt;
&lt;p&gt;In our microservice structure, only the signing authority requires the private key. This increases the security as any key leakage in other services won&amp;rsquo;t be able to retrieve a key capable of signing bearer tokens. We&amp;rsquo;ll need to generate proper private and public keys, though.&lt;/p&gt;
&lt;p&gt;To generate a private/public key, run the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ openssl genrsa -out key.pem 2048
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then, to extract the public key, use the following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ openssl rsa -in key.pem -outform PEM -pubout -out key.pub
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Reading them in text format will be enough to use them as keys for encoding/decoding the JWT token:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; with open(&#39;private.pem&#39;) as fp:
&amp;gt;&amp;gt; .. private_key = fp.read()
&amp;gt;&amp;gt; generate_token_header(&#39;peter&#39;, private_key)
&#39;Bearer &amp;lt;token&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;inject this secret using an environment variable, and in Chapter 11, Handling Change, Dependencies, and Secrets in the System, we&amp;rsquo;ll see how to properly deal with secrets in production environments.&lt;/p&gt;
&lt;h4 id=&#34;testing-the-code&#34;&gt;Testing the code&lt;/h4&gt;
&lt;h6 id=&#34;defining-the-pytest-fixtures&#34;&gt;Defining the pytest fixtures&lt;/h6&gt;
&lt;h6 id=&#34;understanding-test_token_validationpy&#34;&gt;Understanding test_token_validation.py&lt;/h6&gt;
&lt;h6 id=&#34;test_thoughtspy&#34;&gt;test_thoughts.py&lt;/h6&gt;
&lt;h2 id=&#34;chapter-3-build-run-and-test-your-service-using-docker&#34;&gt;Chapter 3: Build, Run, and Test Your Service Using Docker&lt;/h2&gt;
&lt;h4 id=&#34;technical-requirements-1&#34;&gt;Technical requirements&lt;/h4&gt;
&lt;h4 id=&#34;building-your-service-with-a-dockerfile&#34;&gt;Building your service with a Dockerfile&lt;/h4&gt;
&lt;h6 id=&#34;executing-commands&#34;&gt;Executing commands&lt;/h6&gt;
&lt;h6 id=&#34;understanding-the-docker-cache&#34;&gt;Understanding the Docker cache&lt;/h6&gt;
&lt;p&gt;This also means that an image will never get smaller in size, adding a new layer even if the layer removes data, as the previous layer is still stored on the disk.&lt;/p&gt;
&lt;p&gt;Keeping your containers small is quite important. In any Docker system, the tendency is to have a bunch of containers and lots of images. Big images for no reason will fill up repositories quickly. They&amp;rsquo;ll be slow to download and push, and also slow to start, as the container is copied around in your infrastructure.&lt;/p&gt;
&lt;p&gt;There are several practices for keeping your images small. Other than being careful to not install extra elements, the main ones are creating a single, complicated layer that installs and uninstalls, and multi-stage images. Multi-stage Dockerfiles are a way of referring to a previous intermediate layer and copying data from there. Check the Docker documentation (&lt;a href=&#34;https://docs.docker.com/develop/develop-images/multistage-build/)&#34;&gt;https://docs.docker.com/develop/develop-images/multistage-build/)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Compilers, in particular, tend to get a lot of space. When possible, try to use precompiled binaries. You can use a multi-stage Dockerfile to compile in one container and then copy the binaries to the running one.&lt;/p&gt;
&lt;p&gt;You can learn more about the differences between the two strategies in this article: https:/ /pythonspeed.com/articles/smaller-python-docker-images/.
A good tool to analyze a particular image and the layers that compose it is dive (&lt;a href=&#34;https://github.com/wagoodman/dive)&#34;&gt;https://github.com/wagoodman/dive)&lt;/a&gt;. It will also discover ways that an image can be reduced in size.&lt;/p&gt;
&lt;h6 id=&#34;building-a-web-service-container&#34;&gt;Building a web service container&lt;/h6&gt;
&lt;h6 id=&#34;configuring-uwsgi&#34;&gt;Configuring uWSGI&lt;/h6&gt;
&lt;h6 id=&#34;refreshing-docker-commands&#34;&gt;Refreshing Docker commands&lt;/h6&gt;
&lt;h4 id=&#34;operating-with-an-immutable-container&#34;&gt;Operating with an immutable container&lt;/h4&gt;
&lt;h4 id=&#34;testing-the-container&#34;&gt;Testing the container&lt;/h4&gt;
&lt;h4 id=&#34;creating-a-postgresql-database-container&#34;&gt;Creating a PostgreSQL database container&lt;/h4&gt;
&lt;h4 id=&#34;configuring-your-service&#34;&gt;Configuring your service&lt;/h4&gt;
&lt;h4 id=&#34;deploying-the-docker-service-locally&#34;&gt;Deploying the Docker service locally&lt;/h4&gt;
&lt;h4 id=&#34;pushing-your-docker-image-to-a-remote-registry&#34;&gt;Pushing your Docker image to a remote registry&lt;/h4&gt;
&lt;h4 id=&#34;obtaining-public-images-from-docker-hub&#34;&gt;Obtaining public images from Docker Hub&lt;/h4&gt;
&lt;h4 id=&#34;using-tags&#34;&gt;Using tags&lt;/h4&gt;
&lt;h4 id=&#34;pushing-into-a-registry&#34;&gt;Pushing into a registry&lt;/h4&gt;
&lt;h2 id=&#34;chapter-4-creating-a-pipeline-and-workflow&#34;&gt;Chapter 4: Creating a Pipeline and Workflow&lt;/h2&gt;
&lt;p&gt;Technical requirements
Understanding continuous integration practices
Producing automated builds
Knowing the advantages of using Docker for builds
Leveraging the pipeline concept
Branching, merging, and ensuring a clear main build&lt;/p&gt;
&lt;p&gt;Configuring Travis CI
Adding a repo to Travis CI
Creating the .travis.yml file
Working with Travis jobs
Sending notifications&lt;/p&gt;
&lt;p&gt;Configuring GitHub
Pushing Docker images from Travis CI
Setting the secret variables
Tagging and pushing builds
Tagging and pushing every commit&lt;/p&gt;
&lt;h2 id=&#34;chapter-5-using-kubernetes-to-coordinate-microservices&#34;&gt;Chapter 5: Using Kubernetes to Coordinate Microservices&lt;/h2&gt;
&lt;p&gt;Technical requirements
Defining the Kubernetes orchestrator
Comparing Kubernetes with Docker Swarm&lt;/p&gt;
&lt;p&gt;Understanding the different Kubernetes elements
Nodes
Kubernetes Control Plane
Kubernetes Objects&lt;/p&gt;
&lt;p&gt;Performing basic operations with kubectl
Defining an element
Getting more information
Removing an element&lt;/p&gt;
&lt;p&gt;Troubleshooting a running cluster&lt;/p&gt;
&lt;h2 id=&#34;chapter-6-local-development-with-kubernetes&#34;&gt;Chapter 6: Local Development with Kubernetes&lt;/h2&gt;
&lt;p&gt;Technical requirements
Implementing multiple services
Describing the Users Backend microservice
Describing the Frontend microservice
Connecting the services&lt;/p&gt;
&lt;p&gt;Configuring the services
Configuring the deployment
Configuring the service
Configuring the Ingress&lt;/p&gt;
&lt;p&gt;Deploying the full system locally
Deploying the Users Backend
Adding the Frontend&lt;/p&gt;
&lt;h2 id=&#34;chapter-7-configuring-and-securing-the-production-system&#34;&gt;Chapter 7: Configuring and Securing the Production System&lt;/h2&gt;
&lt;p&gt;Technical requirements
Using Kubernetes in the wild
Creating an IAM user&lt;/p&gt;
&lt;p&gt;Setting up the Docker registry
Creating the cluster
Creating the Kubernetes cluster
Configuring the cloud Kubernetes cluster
Configuring the AWS image registry
Configuring the usage of an externally accessible load balancer
Deploying the system&lt;/p&gt;
&lt;p&gt;Using HTTPS and TLS to secure external access
Being ready for migration to microservices
Running the example&lt;/p&gt;
&lt;p&gt;Deploying a new Docker image smoothly
The liveness probe
The readiness probe
Rolling updates&lt;/p&gt;
&lt;p&gt;Autoscaling the cluster
Creating a Kubernetes Horizontal Pod Autoscaler
Deploying the Kubernetes metrics server
Configuring the resources in deployments
Creating an HPA
Scaling the number of nodes in the cluster
Deleting nodes
Designing a winning autoscaling strategy&lt;/p&gt;
&lt;h2 id=&#34;chapter-8-using-gitops-principles&#34;&gt;Chapter 8: Using GitOps Principles&lt;/h2&gt;
&lt;p&gt;Technical requirements
Understanding the description of GitOps
Managing configuration
Understanding DevOps
Defining GitOps&lt;/p&gt;
&lt;p&gt;Setting up Flux to control the Kubernetes cluster
Starting the system
Configuring Flux&lt;/p&gt;
&lt;p&gt;Configuring GitHub
Forking the GitHub repo
Adding a deploy key
Syncing Flux&lt;/p&gt;
&lt;p&gt;Making a Kubernetes cluster change through GitHub
Working in production
Creating structure
Using GitHub features
Working with tags&lt;/p&gt;
&lt;h2 id=&#34;chapter-9-managing-workflows&#34;&gt;Chapter 9: Managing Workflows&lt;/h2&gt;
&lt;p&gt;Understanding the life cycle of a feature
Features that affect multiple microservices
Implementing a feature&lt;/p&gt;
&lt;p&gt;Reviewing and approving a new feature
Reviewing feature code
Approving releases&lt;/p&gt;
&lt;p&gt;Setting up multiple environments
Scaling the workflow and making it work
Reviewing and approving is done by the whole team
Understanding that not every approval is the same
Defining a clear path for releases
Emergency releases
Releasing frequently and adding feature flags
Using feature flags
Dealing with database migrations&lt;/p&gt;
&lt;h2 id=&#34;chapter-10-monitoring-logs-and-metrics&#34;&gt;Chapter 10: Monitoring Logs and Metrics&lt;/h2&gt;
&lt;p&gt;Technical requirements
Observability of a live system
Understanding logs
Understanding metrics&lt;/p&gt;
&lt;p&gt;Setting up logs
Setting up an rsyslog container
Defining the syslog pod
log-volume
syslog container
The front rail container
Allowing external access
Sending logs
Generating application logs
Dictionary configuration
Logging a request ID
Logging each request
Searching through all the logs
Detecting problems through logs
Detecting expected errors
Capturing unexpected errors
Logging strategy
Adding logs while developing&lt;/p&gt;
&lt;p&gt;Setting up metrics
Defining metrics for the Thoughts Backend
Adding custom metrics
Collecting the metrics
Plotting graphs and dashboards
Grafana UI
Querying Prometheus
Updating dashboards&lt;/p&gt;
&lt;p&gt;Being proactive
Alerting
Being prepared&lt;/p&gt;
&lt;h2 id=&#34;chapter-11-handling-change-dependencies-and-secrets-in-the-system&#34;&gt;Chapter 11: Handling Change, Dependencies, and Secrets in the System&lt;/h2&gt;
&lt;p&gt;Technical requirements
Understanding shared configurations across microservices
Adding the ConfigMap file
Using kubectl commands
Adding ConfigMap to the deployment
Thoughts Backend ConfigMap configuration
Users Backend ConfigMap configuration
Frontend ConfigMap configuration&lt;/p&gt;
&lt;p&gt;Handling Kubernetes secrets
Storing secrets in Kubernetes
Creating the secrets
Storing the secrets in the cluster
Secret deployment configuration
Retrieving the secrets by the applications&lt;/p&gt;
&lt;p&gt;Defining a new feature affecting multiple services
Deploying one change at a time
Rolling back the microservices&lt;/p&gt;
&lt;p&gt;Dealing with service dependencies
Versioning the services
Semantic versioning
Adding a version endpoint
Obtaining the version
Storing the version in the image
Implementing the version endpoint
Checking the version
Required version
The main function
Checking the version&lt;/p&gt;
&lt;h2 id=&#34;chapter-12-collaborating-and-communicating-across-teams&#34;&gt;Chapter 12: Collaborating and Communicating across Teams&lt;/h2&gt;
&lt;p&gt;Keeping a consistent architectural vision
Dividing the workload and Conway&amp;rsquo;s Law
Describing Conway&amp;rsquo;s Law
Dividing the software into different kinds of software units
Designing working structures
Structuring teams around technologies
Structuring teams around domains
Structuring teams around customers
Structuring teams around a mix&lt;/p&gt;
&lt;p&gt;Balancing new features and maintenance
Regular maintenance
Understanding technical debt
Continuously addressing technical debt
Avoiding technical debt&lt;/p&gt;
&lt;p&gt;Designing a broader release process
Planning in the weekly release meeting
Reflecting on release problems
Running post-mortem meetings&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Designing and Implementing an Application Layer Network Protocol Using UNIX Sockets and TCP</title>
      <link>http://www.yezheng.pro/post/specialization/systems/computer-networking/custom-protocol/</link>
      <pubDate>Sun, 07 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/specialization/systems/computer-networking/custom-protocol/</guid>
      
        <description>&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/21999964&#34;&gt;如何设计与实现一个自定义的二进制协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/307b3163b192&#34;&gt;手把手教你实现自定义的应用层协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.egr.msu.edu/classes/ece480/capstone/fall12/group02/documents/Ryan-Lattrel_App-Note.pdf&#34;&gt;Designing and Implementing an Application Layer Network Protocol Using UNIX Sockets and TCP&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>The Network Layer</title>
      <link>http://www.yezheng.pro/post/specialization/systems/computer-networking/computer-networks-4/</link>
      <pubDate>Sun, 07 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/specialization/systems/computer-networking/computer-networks-4/</guid>
      
        <description>&lt;h2 id=&#34;arp协议&#34;&gt;ARP协议&lt;/h2&gt;
&lt;p&gt;地址解析协议(Address Resolution Protocol)，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，以保证通信的顺利进行。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Transport Layer</title>
      <link>http://www.yezheng.pro/post/specialization/systems/computer-networking/computer-networks-3/</link>
      <pubDate>Sun, 07 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/specialization/systems/computer-networking/computer-networks-3/</guid>
      
        <description>&lt;h2 id=&#34;introduction-and-transport-layer-services&#34;&gt;Introduction and Transport-Layer Services&lt;/h2&gt;
&lt;p&gt;运输层位于应用层和网络层之间，该层为运行在不同主机上的应用进程提供直接的通信服务，它将网络层的在两个端系统之间的交付服务扩展到运行在两个不同端系统上的应用进程之间的交付服务。这句话的理解是，运输层协议为运行在不同主机上的应用进程之间提供了&lt;strong&gt;逻辑通信&lt;/strong&gt;(logic communication)功能，应用程序使用运输层提供的逻辑通信功能彼此发送报文，而无需考虑承载这些报文的物理基础设施的细节。&lt;/p&gt;
&lt;p&gt;运输层协议是在端系统中而不是在路由器中实现的。在发送端，运输层将从发送应用进程接收到的报文转换成运输层分组，该分组称为&lt;strong&gt;报文段&lt;/strong&gt;(segment)。实现方式可能是&lt;strong&gt;将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段&lt;/strong&gt;，然后在发送端系统中，运输层将这些报文段传递给网络层。注意：网络路由器仅作用于该数据报的网路层字段；即它们不检查封装在该数据报的运输层报文段的字段。在接收端，网络层从数据报中提取出运输层报文段，并将该报文段上交给运输层，经运输层处理后上交给应用进程使用。&lt;/p&gt;
&lt;h4 id=&#34;relationship-between-transport-and-network-layers&#34;&gt;Relationship Between Transport and Network Layers&lt;/h4&gt;
&lt;p&gt;运输层位于网络层之上。&lt;strong&gt;网络层&lt;/strong&gt;提供了&lt;strong&gt;主机&lt;/strong&gt;之间的逻辑通信，而&lt;strong&gt;运输层&lt;/strong&gt;为运行在不同&lt;strong&gt;主机的进程&lt;/strong&gt;之间提供了逻辑通信。&lt;strong&gt;运输层协议只工作在端系统中&lt;/strong&gt;，在端系统中，运输层协议将来自应用进程的报文移动到网络边缘(即网络层)，但对这些报文在网络核心如何移动并不做任何规定。中间路由器既不处理也不识别运输层加在应用层报文的任何信息。&lt;/p&gt;
&lt;p&gt;运输层协议常常受制于底层网络协议的服务模型。但即使底层网络协议是不可靠的，会使分组丢失、篡改和冗余，运输层协议也能为应用程序提供可靠的数据传输服务。&lt;/p&gt;
&lt;h4 id=&#34;overview-of-the-transport-layer-in-the-internet&#34;&gt;Overview of the Transport Layer in the Internet&lt;/h4&gt;
&lt;p&gt;因特网为应用层提供了两种截然不同的可用运输层协议，一个是UDP(用户数据报协议)，它为调用它的应用程序提供一种不可靠的、无连接的服务；另一个是TCP(传输控制协议)，它为调用它的应用程序提供一种可靠的、面向连接的服务。&lt;/p&gt;
&lt;p&gt;在讲UDP和TCP之前，需要简单了解网络层。网络层协议非常重要的是IP，即网际协议。IP为主机之间提供逻辑通信，IP的服务模型是&lt;strong&gt;尽力而为交付服务&lt;/strong&gt;(best-effort delivery service)，即它不确保报文段的交付，不保证报文段的按序交付，不保证报文段中数据的完整性，因此IP被称为&lt;strong&gt;不可靠服务&lt;/strong&gt;(unreliable service)。&lt;/p&gt;
&lt;p&gt;再来看UDP和TCP，两种协议的基本责任是&lt;strong&gt;将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程间的交付服务&lt;/strong&gt;。将主机间交付扩展到进程间交付被称为运输层的&lt;strong&gt;多路复用&lt;/strong&gt;(transport-layer multiplexing)与&lt;strong&gt;多路分解&lt;/strong&gt;(demultiplexing)。UDP和TCP还可以通过在其报文段首部中包括&lt;strong&gt;差错检查字段&lt;/strong&gt;而提供完整性检查。进程到进程的数据交付和差错检查是两种最低限度的运输层服务，也是UDP能提供的仅有的两种服务。&lt;/p&gt;
&lt;p&gt;另一方面，TCP为应用程序提供几种附加服务。一是&lt;strong&gt;可靠数据传输&lt;/strong&gt;(reliable data transfer)，通过使用流量控制、序号、确认和定时器，TCP确保正确地、按序地将数据交付；另一个是&lt;strong&gt;拥塞控制&lt;/strong&gt;(congestion control)，它防止任何一条TCP连接用过多流量来淹没通信主机之间的链路和交换设备。&lt;/p&gt;
&lt;h2 id=&#34;multiplexing-and-demultiplexing&#34;&gt;Multiplexing and Demultiplexing&lt;/h2&gt;
&lt;p&gt;一个主机有一个或多个进程，而一个进程有一个或多个套接字，将运输层报文段中的数据交付到正确的套接字的工作称为&lt;strong&gt;多路分解&lt;/strong&gt;(demultiplexing)；在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作称为&lt;strong&gt;多路复用&lt;/strong&gt;(multiplexing)。&lt;/p&gt;
&lt;p&gt;要实现多路复用，运输层需要：套接字有唯一的标识符；每个报文段有特殊字段来指示该报文段所要交付到的套接字。如图2.1，这些特殊字段是&lt;strong&gt;源端口号字段&lt;/strong&gt;(source port number filed)和&lt;strong&gt;目的端口号字段&lt;/strong&gt;(destination port number filed)。端口号是一个16比特的数，大小在0~65535之间。0~1023范围的端口号被称为周知端口号(well-known port number)，是受限制的，保留给如HTTP等周知的应用层协议使用。当我们开发一个新的应用程序时，必须为其分配一个端口号。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://img2020.cnblogs.com/blog/1550970/202011/1550970-20201126153426043-1801664430.png&#34;&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1550970/202011/1550970-20201126153428108-345024607.png&#34; alt=&#34;clip_image002&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​          图2.1 运输层报文段中的源与目的端口号字段&lt;/p&gt;
&lt;p&gt;因此多路分解就是，在报文段到达主机时，运输层检查报文段中的目的端口号，将其定位到相应的套接字。UDP基本上就是这样做的，但TCP的却更为复杂。&lt;/p&gt;
&lt;h6 id=&#34;无连接的多路复用和多路分解&#34;&gt;无连接的多路复用和多路分解&lt;/h6&gt;
&lt;p&gt;无连接的多路复用和多路分解，即UDP多路复用和多路分解。复用与分解的关键在于为套接字关联一个特定的端口号。在使用UDP通信时，创建一个UDP套接字，运输层可以自动为该套接字分配一个端口号，也可以手动为该套接字绑定一个特定的端口号。在形成运输层的报文段时，其中包括&lt;strong&gt;应用程序数据、源端口号(作为“返回地址”)、目的端口号和两个其他值&lt;/strong&gt;。这样就能够精确描述UDP的复用与分解。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;strong&gt;一个UDP套接字是由一个二元组全面标识的&lt;/strong&gt;，该二元组包含了一个目的IP地址和一个目的端口号。因此，如果两个UDP报文段有不同的源IP地址和源端口号，但是具有相同的目的IP地址和目的端口号，那么这两个报文段将&lt;strong&gt;通过&lt;/strong&gt;相同的&lt;strong&gt;目的套接字****被定向到&lt;/strong&gt;相同的目的&lt;strong&gt;进程&lt;/strong&gt;，**即目的主机只使用目的端口号和IP地址定位相应的套接字。这一点与TCP是不同的。&lt;/p&gt;
&lt;h6 id=&#34;面向连接的多路复用与多路分解&#34;&gt;面向连接的多路复用与多路分解&lt;/h6&gt;
&lt;p&gt;TCP套接字与UDP套接字不同的是，因为TCP是面向连接的，**TCP套接字是由一个四元组(源IP地址，源端口号，目的IP地址，目的端口号)来标识的。**因此，当一个TCP报文段从网络到达主机时，该主机使用全部4个值来将报文段定向到相应的套接字。比如，两个具有不同源IP地址或端口号的TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带的是初始创建连接的请求(因为TCP服务器有一个“欢迎套接字”，TCP连接建立时都需要先向该套接字发送请求)。&lt;/p&gt;
&lt;p&gt;服务器主机可以支持很多并行的TCP套接字，每个套接字与一个进程相联系，并由其四元组来标识每个套接字。当一个TCP报文段到达主机时，所有4个字段被用来将报文段定向分解到相应的套接字。&lt;/p&gt;
&lt;p&gt;端口扫描器nmap能够扫描能够接收TCP连接或能响应的UDP端口。&lt;/p&gt;
&lt;p&gt;如图2.2，主机A和主机C以及服务器B都有自己的唯一IP地址A、B、C，其中主机C向服务器B发送两个会话，主机A向服务器B发送一个会话。主机C为两个会话分配了两个不同的源端口号(26145和7532)，因为主机A选择源端口号时与主机C互不相干，因此它也可以将源端口号26145分配给其会话连接。尽管如此，服务器B仍能正确地分解这两个具有相同源端口号的连接，因为两个连接的源IP地址不同。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://img2020.cnblogs.com/blog/1550970/202011/1550970-20201126153438895-2037525561.png&#34;&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1550970/202011/1550970-20201126153440762-1703603010.png&#34; alt=&#34;clip_image003&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​                     图2.3 两个客户使用相同目的端口号和源端口号与同一服务器应用通信&lt;/p&gt;
&lt;h6 id=&#34;web服务器与tcp&#34;&gt;Web服务器与TCP&lt;/h6&gt;
&lt;p&gt;需要注意的是，**连接套接字并非与进程之间并不是一一对应关系。**早期每个Web服务器可以为每条连接生成一个新进程，这样每个进程都有自己的连接套接字，但现在的高性能Web服务器通常只使用一个进程，当客户请求连接时，这个进程会为每个新的客户创建一个具有新连接套接字的新线程，因此很多具有不同标识的的连接套接字连接到的是相同的进程。&lt;/p&gt;
&lt;h4 id=&#34;connectionless-transport-udp&#34;&gt;Connectionless Transport: UDP&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;运输层的最低限度是必须提供一种复用/分解服务，以便在网络层和正确的应用级进程之间传递数据。&lt;strong&gt;UDP就是一种非常简单的协议，在[RFC 768]的定义中，UDP除了&lt;/strong&gt;复用/分解以及少量差错检测&lt;/strong&gt;之外，几乎没有对IP增加别的东西。UDP从应用进程得到数据，附加上用于复用/分解的源和目的端口号字段，以及两个其他的小字段，然后形成报文段交给网络层。UDP做了非常少的工作，差不多应用进程是直接与IP交互。&lt;/p&gt;
&lt;p&gt;使用UDP时，在发送报文前，发送方和接收方的运输层实体之间&lt;strong&gt;没有握手&lt;/strong&gt;，正因如此，UDP被称为是&lt;strong&gt;无连接&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;DNS是一个通常使用UDP的应用层协议的例子。&lt;/p&gt;
&lt;p&gt;许多应用更适合使用UDP，主要原因有：&lt;/p&gt;
&lt;p&gt;（1）&lt;strong&gt;关于发送什么数据以及何时发送的应用层控制更为精细。&lt;strong&gt;采用UDP时，只要应用进程将数据传递给UDP，UDP就会将该数据打包进UDP报文段并传递给网络层。而TCP提供可靠传输服务，还有拥塞控制机制和超时重传机制，TCP不管可靠交付需要多长时间，一定要保证目的主机接收并确认。而&lt;/strong&gt;实时应用&lt;/strong&gt;通常要求最小的发送速率，不希望过分地延迟报文段的传送，且能容忍一些数据的丢失，TCP服务模型并不是特别适合这些应用的需要。这些应用可以使用UDP，并作为应用的一部分来&lt;strong&gt;实现所需、超出UDP的不提供不必要的报文段交付服务之外的额外功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（2）**无须建立连接。**UDP不需要任何准备即可进行数据传输，因此UDP不会引入建立连接的时延(这可能是DNS运行在UDP上的主要原因)。&lt;/p&gt;
&lt;p&gt;（3）**无连接状态。**TCP需要在端系统中维护连接状态，该状态包括缓存、拥塞控制参数以及序号确认序号。**而UDP不需要维护连接状态，**也不跟踪这些参数。因此，某些专门用于某种特定应用的服务器当应用程序运行在UDP之上而不是运行在TCP上时，&lt;strong&gt;一般都能支持更多活跃客户。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（4）**分组首部开销小。**每个TCP报文段都有20个字节的首部开销，而UDP仅有8字节的开销。&lt;/p&gt;
&lt;p&gt;UDP不提供可靠数据传输服务，但是使用UDP的应用是可能实现可靠数据传输的。这&lt;strong&gt;可以通过在应用进程自身中建立可靠性机制来完成&lt;/strong&gt;，（例如，可通过增加确认和重传机制来实现）如谷歌浏览器中的QUIC协议就是在UDP之上的应用层协议实现了可靠性。这样做可以使应用进程进行可靠通信，而无需受制于TCP的拥塞控制机制带来的传输速率限制。&lt;/p&gt;
&lt;h4 id=&#34;udp-segment-structure&#34;&gt;UDP Segment Structure&lt;/h4&gt;
&lt;p&gt;UDP首部只有4个字段，每个字段由两个字节组成。源端口号和目的端口号在复用/分解时被使用；长度字段指示了在UDP报文段中的字节数(首部+数据)，因为数据字段的长度在一个UDP段中不同于在其他层封装后的段中，所以需要一个明确长度；接收方使用校验和来检查在该报文段是否出现差错。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://img2020.cnblogs.com/blog/1550970/202011/1550970-20201126153826665-627460470.png&#34;&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1550970/202011/1550970-20201126153849397-1476776484.png&#34; alt=&#34;image&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​           图2.1 UDP报文段结构&lt;/p&gt;
&lt;h4 id=&#34;udp-checksum&#34;&gt;UDP Checksum&lt;/h4&gt;
&lt;p&gt;UDP提供了差错检测功能，具体为发送方的UDP对报文段中的所有16比特字段的和进行反码运算，求和时遇到的任何溢出都被回卷。得到的结果被放在UDP报文段中的检验和字段。&lt;/p&gt;
&lt;p&gt;用一个例子说明计算过程，有三个16比特：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://img2020.cnblogs.com/blog/1550970/202011/1550970-20201126153900674-1463253988.png&#34;&gt;&lt;img src=&#34;https://img2020.cnblogs.com/blog/1550970/202011/1550970-20201126153904492-1464881034.png&#34; alt=&#34;clip_image002&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后一次加法有溢出，它要被回卷，其结果进行反码运算后得到(1011010100111101)校验和。在接收方，包括校验和的全部的4个16比特加在一起，若没有出现差错，最后结果将是(1111111111111111)。&lt;/p&gt;
&lt;p&gt;UDP提供端到端的差错检测，但不能对差错进行恢复，某些实现是将受损报文段丢弃，其他实现是将受损报文段交给应用程序并给出警告。&lt;/p&gt;
&lt;h2 id=&#34;principles-of-reliable-data-transfer&#34;&gt;Principles of Reliable Data Transfer&lt;/h2&gt;
&lt;p&gt;为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。实现这种服务抽象是&lt;strong&gt;可靠数据传输协议&lt;/strong&gt; (reliable data transfer protocol) 的责任。&lt;/p&gt;
&lt;p&gt;由于可靠数据传输协议的下层协议也许是不可靠的，因此这是一项困难的任务。TCP是在不可靠的 (IP) 端到端网络层之上实现的可靠数据传输协议。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsgy1goicplw4myj30ot0fg405.jpg&#34; alt=&#34;9rTshXF.png&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;building-a-reliable-data-transfer-protocol&#34;&gt;Building a Reliable Data Transfer Protocol&lt;/h4&gt;
&lt;h6 id=&#34;1-经完全可靠信道的可靠数据传输rdt10&#34;&gt;1 经完全可靠信道的可靠数据传输：rdt1.0&lt;/h6&gt;
&lt;p&gt;假设底层信道是完全可靠的，此时协议为rdt1.0。&lt;strong&gt;有限状态机(Finite-State-Machine,FSM)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsgy1goicui54qpj30ed0c5aat.jpg&#34; alt=&#34;88p9BlE.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;该发送方和接收方的FSM每个都只有一个状态。FSM描述图中的箭头指示了协议从一个状态变迁到另一个状态（&lt;strong&gt;上图每个FSM都只有一个状态&lt;/strong&gt;，因此变迁的必定是从一个状态返回到自身。）&lt;/p&gt;
&lt;p&gt;引起变迁的事件显示在表示变迁的横线上方，事件发生时所采取的动作显示在横线下方。如果对一个事件没有动作，或没有事件就在横线上方或者下方用^符号表示。&lt;/p&gt;
&lt;p&gt;1)在发送端：rdt的发送端只通过rdt_send(data)事件接收来自较高层的数据，产生一个包含该数据的分组(经由make_pkt(data)动作)，并将分组发送到信道中。实际上，rdt_send(data)事件是由较高层应用过程调用产生的。&lt;/p&gt;
&lt;p&gt;2）在接收端：rdt通过rdt_rcv(packet)事件从底层信道接收一个分组，从分组中取出数据(经由extract(packet,data)动作)，并将数据上传给较高层(通过deliver_data(data)动作)。实际上，rdt_rev(packet)事件是由较底层协议的过程调用产生的。&lt;/p&gt;
&lt;h6 id=&#34;2-经具有比特差错信道的可靠数据传输rdt20&#34;&gt;2 经具有比特差错信道的可靠数据传输：rdt2.0&lt;/h6&gt;
&lt;p&gt;底层信道更为实际的模型是分组中的比特可能受损。在分组的传输、传播或缓存的过程中，这种&lt;strong&gt;比特差错&lt;/strong&gt;通常会出现在网络的物理部件中。此时仍然假定所有发送的分组（虽然有些比特可能受损）将按其发送的顺序被接收。&lt;/p&gt;
&lt;p&gt;利用&lt;strong&gt;控制报文&lt;/strong&gt;使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误并因此需要重复。在计算机网络中，基于这样&lt;strong&gt;重传机制&lt;/strong&gt;的可靠数据传输协议称为**自动重传请求(Automatic Repeat reQuest,ARQ)**协议。&lt;/p&gt;
&lt;p&gt;ARQ协议还需要另外三种协议来处理存在比特差错的情况：&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;差错检测&lt;/strong&gt;：这些技术需要有额外的比特（除了待发送的初始数据比特之外的比特）从发送方发送到接收方；这些比特将被汇集在rdt2.0数据分组的分组检验和字段中。&lt;/p&gt;
&lt;p&gt;2）&lt;strong&gt;接收方反馈&lt;/strong&gt;：rdt2.0协议将从接收方向发送方回送ACK(“肯定确认”)或者NAK（“否定确认”）分组。理论上，这些分组只需要一个比特长；用0表示NAK，用1表示ACK。&lt;/p&gt;
&lt;p&gt;3）&lt;strong&gt;重传&lt;/strong&gt;：接收方收到有差错的分组时，发送方将重传该分组文。
&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsgy1goid6c54prj30lk0jimz5.jpg&#34; alt=&#34;OoF58nx.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;rdt2.0的&lt;strong&gt;发送端FSM有两个状态，接收方FSM有一个状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先，发送端协议正等待来自上层传下来的数据。当产生rdt_send (data)事件时，发送方将产生一个包含待发送数据的分组，带有检验和，然后经由 udt_send(sndpkt)操作发送该分组。然后，发送方协议等待来自接收方的ACK或NAK分组。如果收到一个ACK 分组，则发送方知道最近发送的分组已被正确接收，因此协议返回到等待来向上层的数据的状态。如果收到NAK分组，该协议重传最后一个分组并等待接收方的响应。&lt;/p&gt;
&lt;p&gt;但是注意以下事实：&lt;/p&gt;
&lt;p&gt;1）当发送方处于等待ACK或NAK的状态时，它不能从上层获得更多的数据。这就是说rdt_send()事件不可能出现，仅当接收到ACK并离开该状态时才能发生这样的事件。因此，发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组。rdt2.0协议被称为停等(stop-and-wait)协议。&lt;/p&gt;
&lt;p&gt;2）它存在一个致命的缺陷，尤其是没考虑到ACK或NAK分组受损的可能性。&lt;/p&gt;
&lt;p&gt;解决这个新问题的一个简单方法（几乎所有现有的数据传输协议中，包括 TCP，都采用了这种方法）是&lt;strong&gt;在数据分组中添加一新字段，让发送方对其数据分组编号，即将发送数据分组的序号放在该字段&lt;/strong&gt;。于是，接收方只需要检查序号即可确定收到的分组是否一次重传。因为目前我们假定信道不丢失分组。ACK 和 NAK 分组本身不需要指明它们要确认的分组序号。 发送方知道所接收到的 ACK 和 NAK 分组（无论是否是含糊不清的）是为响应其最近发送的数据分组而生成的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsgy1goidpu1s1xj30ml0f0q4z.jpg&#34; alt=&#34;yMnU15e.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsgy1goids10z3uj30ph0d2wgw.jpg&#34; alt=&#34;2qQNPD0.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面是rdt2.2的FSM描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsgy1goidt7w8hjj30mq0ewac3.jpg&#34; alt=&#34;uuq9awx.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsgy1goidtek0mlj30nl0bvac3.jpg&#34; alt=&#34;O73tMVL.png&#34;&gt;&lt;/p&gt;
&lt;h6 id=&#34;3-经具有比特差错的丢包信道的可靠数据传输rdt30&#34;&gt;3 经具有比特差错的丢包信道的可靠数据传输：rdt3.0&lt;/h6&gt;
&lt;p&gt;现在假定除了&lt;strong&gt;比特受损&lt;/strong&gt;外，底层信道还会&lt;strong&gt;丢包&lt;/strong&gt;。协议现在必须处理另外两个关注的问题：&lt;strong&gt;怎样检测丢包以及发生丢包后该做些什么&lt;/strong&gt;。在rdt2.2中已经研发的技术：使用&lt;strong&gt;校验和、序号、ACK分组和重传&lt;/strong&gt;等。使得可以解决第二个问题，对于第一个问题，还需要增加一种新的协议机制。&lt;/p&gt;
&lt;p&gt;有很多可能的方法用于解决丢包问题（在本章结尾的习题中研究了几种其他方法）。在这里，我们让发送端负责检测和恢复丢包工作。假定发送端传输一个数据分组，该分组或者接收端对该分组的 ACK 发生了丢失。在这两种情况下，发送端都收不到应当到来的接收端的响应。&lt;/p&gt;
&lt;p&gt;因此实践中采取的方法是发送方明智地选择一个时间值，以判定可能发生了丢包(尽管不能确保)如果在这个时间内没有收到ACK，则&lt;strong&gt;重传&lt;/strong&gt;该分组。
注意，如果一个分组经历了一个大的时延，发送方可能会重传该分组，既是数据分组和ACK均没有发生丢失。这就需要考虑冗余数据分组的可能性。rdt2.2协议已经有足够的功能（即&lt;strong&gt;序号&lt;/strong&gt;）来处理分组情况，接收方可丢弃重复冗余分组。&lt;/p&gt;
&lt;p&gt;为了实现基于时间的重传机制，需要一个&lt;strong&gt;倒计数定时器&lt;/strong&gt;，在一个给定的时间量过期后，可中断发送方。因此，发送方需要能做到: ①每次发送一个分组(包括第一次分组和重传分组)时，便启动一个定时器。②响应定时器中断(采取适当的动作) ③终止定时器&lt;/p&gt;
&lt;p&gt;rdt3.0有时被称为&lt;strong&gt;比特交替协议(alternating-bit protocol)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsgy1goie9j0yo0j30jt0eraca.jpg&#34; alt=&#34;CwR3zp6.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据传输协议的要点：在检验和、序号、定时器、肯定和否定确认分组这些技术中，每种机制都在协议的运行中起到了必不可少的作用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsgy1goieay18f6j30md0non18.jpg&#34; alt=&#34;uXjj0Db.png&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;pipelined-reliable-data-transfer-protocols&#34;&gt;Pipelined Reliable Data Transfer Protocols&lt;/h4&gt;
&lt;p&gt;rdt3.0 性能问题的核心在于它是一个停等协议。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsgy1goieokyod6j30jp0almxp.jpg&#34; alt=&#34;stop-and-wait.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsgy1goienr373jj30jp0bb0th.jpg&#34; alt=&#34;pipelined.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;解决这种特殊的性能问题的一个简单方法是：不使用停等方式运行，允许发送方发送多个分组而无需等待确认。这种技术为&lt;strong&gt;流水线&lt;/strong&gt; (pipeline)：因为许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中。&lt;/p&gt;
&lt;p&gt;流水线技术对可靠数据传输协议带来如下影响：&lt;/p&gt;
&lt;p&gt;1）必须增加序号范围：因为每个输送中的分组必须有一个唯一的序号，而且也许有多个在输送中未确认的报文。&lt;/p&gt;
&lt;p&gt;2）协议的发送方和接收方两端也许必须缓存多个分组。&lt;/p&gt;
&lt;p&gt;3）所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决流水线的差错恢复&lt;/strong&gt;有两种基本的方法：&lt;strong&gt;回退N步(G0-Back-N,GBN)&lt;/strong&gt;，和&lt;strong&gt;选择重传(Selective Repeat,SR)&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;go-back-n-gbn&#34;&gt;Go-Back-N (GBN)&lt;/h4&gt;
&lt;p&gt;在回退N步协议中，允许发送方发送多个分组(当有多个分组可用时)而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。建议操作本书配套Web网站上的GBN Java小程序（这是个非常好的Java程序）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsgy1goifh815zoj30vg088jsw.jpg&#34; alt=&#34;Network_GBN-sender.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;base&lt;/code&gt;对应的分组被确认之后，窗口才会向右移动。&lt;code&gt;N&lt;/code&gt;被称为&lt;strong&gt;窗口长度&lt;/strong&gt;。限制窗口长度是要进行流量控制与拥塞控制。&lt;/p&gt;
&lt;p&gt;在实现中，一个分组的序号承载在分组首部的一个固定长度的字段中。如果分组序号字段的比特数是$k$，则该序号范围是$[0,2^k-1]$。在一个有限的序号范围内，所有涉及序号的运算必须使用模$2^k$运算。（即序号空间可被看作是一个长度为2k的环，其中序号2k-1紧接着序号0。）TCP有一个32比特的序号字段，其中的TCP序号是按字节流中的字节进行计数的，而不是按分组计数。&lt;/p&gt;
&lt;p&gt;基于ACK、无NAK的GBN协议的发送方和接收放这两端的扩展FSM：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsgy1goifwgy8xjj30uk0lm78r.jpg&#34; alt=&#34;Network_GBN-sender(1).png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsgy1goifws85l8j30ka0e6jty.jpg&#34; alt=&#34;Network_GBN-receiver.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;GBN发送方必须响应三种类型的事件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上层的调用。当上层调用了rdt_send()后，GBN发送方必须先检测其发送窗口是否已满（即是否有N个已发送但未被确认的分组）。如果没有满，则产生一个分组并将其发送；如果窗口已满，则GBN发送方将数据返回（退还）上层，告诉他现在还不能发送。&lt;/li&gt;
&lt;li&gt;收到一个ACK反馈报文。在GBN协议中，对序号为n的分组采用的是累积确认（cumulative acknowledge），即发送方当收到序号为n的ACK报文时，表明接收方已经正确接收了序号n 及n以前的所有的分组。如果发送方收到了一个损坏的反馈报文，则不做任何处理，继续等待。&lt;/li&gt;
&lt;li&gt;超时处理。当GBN协议中的发送方遇到超时事件时，将会重新启动计时器，并重新发送所有已发送但未被确认的报文。发送方只有一个定时器，指明当前最早发送但未被确认的分组（基序号base）；当发送方收到一个ACK，但仍有未被确认的分组时，则定时器重新被启动；但如果没有未被确认的分组，则定时器停止。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在GBN协议中，当接收方收到序号为n的分组且该分组是按序的（即上一个分组的序号是n-1），则接收方将为分组n发送一个ACK，并将该分组中的数据部分交付到上层。在所有其他情况下（序号为n的分组是失序的或是损坏的），接收方将丢弃该分组，并为最近按序接收到的分组重新发送ACK。&lt;/p&gt;
&lt;h4 id=&#34;selective-repeat-sr&#34;&gt;Selective Repeat (SR)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1goof4828ijj30lt0cvq3t.jpg&#34; alt=&#34;sr.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;SR接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存直达所有丢失分组（即序号更小的分组）皆被收到为止。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1goof4mqgpej30lt0kojt2.jpg&#34; alt=&#34;sr-operation.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1goof5bq9q6j30eb09tjru.jpg&#34; alt=&#34;sr-window-a.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1goof64e8luj30ec09z3z0.jpg&#34; alt=&#34;sr-window-b.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;Problem of SR with a too large window: a packet can be new data or a retransmission (an example with window size = 4):&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Window size of SR must be less than or equal to half the size of the sequence number space. ($\leqslant 2^{k-1}$).&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;可靠数据传输机制及其用途的总结&#34;&gt;&lt;strong&gt;可靠数据传输机制及其用途的总结&lt;/strong&gt;&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;机制&lt;/th&gt;
&lt;th&gt;用途和说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;检验和&lt;/td&gt;
&lt;td&gt;用于检测在一个传输分组中的比特错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;定时器&lt;/td&gt;
&lt;td&gt;用于超时/重传一个分组，可能因为该分组（或其ACK）在信道中丢失了。由于当一个分组延时但未丢失（过早超时），或当一个分组已被接受方收到但从接收方的ACK丢失时，可能产生超时事件，所以接收方可能会受到一个分组的的多个冗余副本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;序号&lt;/td&gt;
&lt;td&gt;用于为从发送方流向接收方的数据分组按顺序编号。所接受分组的序号间的空隙可使接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余副本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或积累的，这取决于协议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;否定确认&lt;/td&gt;
&lt;td&gt;接收方用于高速发送方某个分组未被正确地接受。否定确认报文通常携带着未被正确接受的分组的序号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;窗口、流水线&lt;/td&gt;
&lt;td&gt;发送方也许被限制仅发送那些序号落在一个指定范围的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上得到增加。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;connection-oriented-transport-tcp&#34;&gt;Connection-Oriented Transport: TCP&lt;/h2&gt;
&lt;h4 id=&#34;the-tcp-connection&#34;&gt;The TCP Connection&lt;/h4&gt;
&lt;p&gt;TCP被称为是面向连接的（connection-oriented），这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互“握手”，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。作为TCP连接建立的一部分，连接的双方都将初始化与TCP连接相关的许多TCP状态变量。&lt;/p&gt;
&lt;p&gt;这种TCP连接是一条逻辑连接，其共同状态进保留在两个通信端系统的TCP程序中。由于TCP协议只在端系统中运行，而不在中间的网络元素（路由器和链路层交换机）中运行，所以中间的网络元素不会维持TCP连接状态。对于中间路由器来说，它们看不到TCP连接，看到的只是一个个的数据报。&lt;/p&gt;
&lt;p&gt;TCP提供的是全双工服务（full-duplex service）：如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可以从进程B流向进程A的同时，也从进程A流向进程B。TCP连接总是点对点的，即在单个发送方与单个接收方之间的连接。在TCP中不可能出现“多播”的情况，即在一次发送操作中，从一个发送方将数据传送给多个接收方。&lt;/p&gt;
&lt;p&gt;TCP连接中发起连接的主机进程被称为客户进程，而另一个进程被称为服务器进程。该客户应用进程首先要通知客户运输层，它想与服务器上的一个进程建立一条连接。建立连接的过程大概如下：客户首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个特殊报文短作为响应。前两个报文段不承载应用层数据，第三个报文段可以承载应用层数据。由于在这两台主机之间发送了三个报文段，因此这种连接建立的过程通常被称为三次握手（three-way handshake）。&lt;/p&gt;
&lt;p&gt;一旦建立起一条TCP连接，两个应用进程之间就可以相互发送数据了。客户进程通过套接字传递数据流，数据在进入套接字后就由客户端中运行的TCP程序控制。TCP将这些数据引导到该连接的发送缓存（send buffer）里，发送缓存是发起三次握手期间设置的缓存之一。接下来TCP将不时从发送缓存里取出一块数据，并将数据传递到网络层。如下图所示：&lt;/p&gt;
&lt;p&gt;但TCP放入报文段的数据数量不是无限的，这取决于最大报文段长度（Maximum Segment Size，MSS）。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（即所谓的最大传输单元（Maximum Transmission Unit，MTU））来设置。设置该MSS要保证一个TCP报文段加上TCP/IP首部长度（通常40个字节）将适合单个链路层帧。例如以太网和PPP链路层协议都具有1500字节的MTU，因此MSS的典型值为1460字节。&lt;/p&gt;
&lt;p&gt;TCP为每块客户数据配上一个TCP首部，从而形成多个TCP报文段（TCP segment）。这些报文段被下传给网络层，网络层将其分别封装在网络层IP数据报中，然后这些IP数据报被发送的网络中。当TCP在另一端接收到一个报文段后，该报文段的数据就被放入该TCP连接的接受缓存中。应用程序从此缓存中读取数据流。该连接的每一端都有各自的发送缓存和接收缓存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1goog6r04b4j30o809jgnl.jpg&#34; alt=&#34;20201215004700137.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;以上可以得出TCP连接的组成包括：一台主机上的缓存、变量和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。&lt;/p&gt;
&lt;h4 id=&#34;tcp-segment-structure&#34;&gt;TCP Segment Structure&lt;/h4&gt;
&lt;p&gt;TCP报文段由首部字段和一个数据字段组成。数据字段包含一块应用数据。MSS限制了报文段数据字段的最大长度。当TCP发送一个大文件时，TCP通常将该文件划分成长度为MSS的若干块。TCP报文段的结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1googq31y88j30g70d1jrw.jpg&#34; alt=&#34;tcp-header.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;从上图可以得知，TCP报文段的首部是20字节。与UDP一样，首部包括源端口号和目的端口号，用于多路复用/分解来自或送到上层应用的数据，也包括检验和字段用于校验该分组是否存在比特差错。另外，TCP报文段首部还包含以下字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32比特的序号字段和32比特的确认号字段。这些字段被TCP发送方和接收方用来实现可靠数据传输服务，具体后面讨论；&lt;/li&gt;
&lt;li&gt;16比特的接收窗口字段。该字段用于指示接收方愿意接受的字节数量，用于流量控制；&lt;/li&gt;
&lt;li&gt;4比特的首部长度字段。该字段指示了以32比特的字为单位的TCP首部长度。由于TCP选项字段的原因，TCP首部的长度是可变的。当选项字段为空时，TCP首部的典型长度是20字节；&lt;/li&gt;
&lt;li&gt;可选与变长的选项字段。该字段用于发送方与接收方协商最大报文长度（MSS）时，或在高速网络环境下用作窗口调节因子时使用；&lt;/li&gt;
&lt;li&gt;6比特的标志字段。ACK比特用于指示确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认。RST、SYN和FIN比特用于连接建立和拆除。CWR和ECE比特用于明确拥塞通告。当PSH比特被置位时，就指示接收方应立即将数据交给上层，URG比特用来指示报文段里存在着被发送端的上层实体置为“紧急”的数据。紧急数据的最后一个字节由16比特的紧急数据指针字段指出。当紧急数据存在并给出指向紧急数据尾指针的时候，TCP必须通知接收端的上层实体。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;序号和确认号&#34;&gt;序号和确认号&lt;/h6&gt;
&lt;p&gt;TCP报文段首部中两个最重要的字段是序号字段和确认号字段，这两个字段是TCP可靠传输服务的关键部分。TCP把数据看成一个无结构的、有序的字节流，例如TCP的序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列上。因此在TCP协议中，&lt;strong&gt;一个报文段的序号&lt;/strong&gt;是该报文段首字节的字节流编号。例如，主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一个数据流。主机A上的TCP将隐式地对数据流中的每一个字节编号。假定数据流由一个包含50000字节的文件组成，其MSS为100字节，数据流的首字节编号是0。那么该TCP将为该数据流构建500个报文段，第一个报文段的序号是0，第二个报文段的序号是100，第三个报文段的序号是200，以此类推。每一个序号都被填入到相应的TCP报文段首部的序号字段中。&lt;/p&gt;
&lt;p&gt;确认号相比序号要难理解一些。之前介绍过，TCP是全双工的，因此主机A在接收来自主机B的数据的同时，也在向主机B发送数据，并且是在同一条TCP连接上。从主机B到达的每个报文段中都有一个序号用于从B流向A的数据。主机A填充进报文段的确认号就是主机A期望从主机B收到的下一字节的序号。例如主机A已经收到了来自主机B的编号为0~311的所有字节，同时它打算发送一个报文段给主机B，由于主机A下一次期望主机B发送过来的首字节是312，因此主机A会在它发往主机B的报文段的确认号字段中填上312。存在另一种情况，主机A接收到了来自主机B的编号为0~311的报文段，以及另一个包含了字节400~500的报文段，并没有收到312~399的报文段。而主机A为了重新构建主机B的数据流，仍在等待字节312~399，因此主机A到主机B的下一个报文段将在确认号中填上312。因为TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供&lt;strong&gt;累计确认&lt;/strong&gt; (cummulative acknowledgment)。&lt;/p&gt;
&lt;p&gt;当主机在一条TCP连接中收到失序报文段时该怎么办？TCP RFC并没有为此明确规定，而是由TCP的编程人员实现。他有两个基本的选择：①接收方立即丢弃失序报文段；②接收方保留失序的字节，并等待缺少的字节以填补该间隔（后一种选择对网络带宽而言更为有效，是实践中采用的方法）。&lt;/p&gt;
&lt;p&gt;值得注意的是，对客户到服务器的数据的确认被装载在一个承载服务器到客户的数据的报文段中；这种确认被称为是被捎带(piggybacked)在服务器到客户的数据报文段中的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1googvzgnvdj30h10f775p.jpg&#34; alt=&#34;o9D7GZq.png&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;round-trip-time-estimation-and-timeout&#34;&gt;Round-Trip Time Estimation and Timeout&lt;/h4&gt;
&lt;p&gt;TCP如同rdt协议一样，它采用超时/重传机制来处理报文段的丢失问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超时间隔长度的设置？显然，超时时间间隔必须大于该连接的往返时间(RTT),即从一个报文段发出到它被确认的时间。&lt;/li&gt;
&lt;li&gt;如何估计往返时间？&lt;/li&gt;
&lt;li&gt;是否应该为所有未确认的报文段各设一个定时器？&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;估计往返时间&#34;&gt;估计往返时间&lt;/h6&gt;
&lt;p&gt;报文段的样本RTT(表示为SampleRTT)就是从某报文段被发出(即交给IP)到对该报文段的确认被收到之间的时间量。大多数TCP的实现仅在某个时刻做一次SampleRTT测量，而不是为每个发送的报文段测量一个SampleRTT.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//指数加权移动平均(Exponential Weighted Moving Average,EWMA)。
//推荐的a=0.25
EstimatedRTT = (1 – a) • EstimatedRTT + a • SampleRTT
//推荐的b=0.25
//DevRTT：RTT偏差，测量RTT的变化。
DevRTT = (1 – b) • DevRTT + b•| SampleRTT – EstimatedRTT |
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&#34;设置和管理重传超时间隔&#34;&gt;设置和管理重传超时间隔&lt;/h6&gt;
&lt;p&gt;超时间隔应该大于等于EstimatedRTT,否则将造成不必要的重传。但超时时间间隔也不能比EstimatedRTT大太多，否则当报文段丢失时，TCP不能很快地重传该报文段，导致数据传输时延大。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//推荐TimeoutInterval值为1秒。超时后，TimeoutInterval值将加倍。
//一旦报文段收到并更新EstimatedRTT后，TimeoutInterval就使用下式
TimeoutInterval = EstimatedRTT + 4 • DevRTT
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP通过使用肯定确认与定时器来提供可靠数据传输。TCP确认正确接收到的数据，而当认为报文段或其确认报文丢失或受损后，TCP会重传这些报文段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP使用流水线，使得发送方在任意时刻都可以有多个已发出但还未确认的报文段存在。一个发送方具有的未被确认报文段的确切个数是由TCP的流量控制和拥塞控制机制决定的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;reliable-data-transfer&#34;&gt;Reliable Data Transfer&lt;/h4&gt;
&lt;p&gt;对于IP服务，数据报能够溢出路由器缓存而永远不能到达目的地，数据报也可能乱序到达，而且数据报中的比特可能损坏。TCP在IP不可靠的尽力而为服务之上创建一种可靠数据传输服务。TCP的可靠数据传输服务确保了一个进程从其接收缓存中读取数据流是无损坏、无间隔、非冗余和按序的数据流。&lt;/p&gt;
&lt;p&gt;接下来讨论：&lt;/p&gt;
&lt;p&gt;1）简化版本：发送方只用超时技术来恢复报文段丢失。&lt;/p&gt;
&lt;p&gt;2）全面版本：除了使用超时机制外，还使用冗余确认技术。&lt;/p&gt;
&lt;p&gt;简化版本描述：TCP发送方有3个与发送和重传有关的主要事件（①从上层应用程序接收数据；②定时器超时；③收到ACK；）&lt;/p&gt;
&lt;p&gt;TCP在IP不可靠的尽力而为服务之上创建了一种可靠数据传输服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送数据，启动计时器&lt;/li&gt;
&lt;li&gt;超时重发，重启计时器&lt;/li&gt;
&lt;li&gt;收到ACK，更新确认计数器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/* Assume sender is not constrained by TCP flow or congestion control, that data from above is less than MSS in size, and that data transfer is in one direction only. */
NextSeqNum=InitialSeqNumber
SendBase=InitialSeqNumber

loop (forever) {
    switch(event)

        event: data received from application above
            create TCP segment with sequence number NextSeqNum
            if (timer currently not running)
                start timer
            pass segment to IP
            NextSeqNum=NextSeqNum+length(data)
            break;

        event: timer timeout
            retransmit not-yet-acknowledged segment with
                smallest sequence number
            start timer
            break;

        event: ACK received, with ACK field value of y
            if (y &amp;gt; SendBase) {
                SendBase=y
                if (there are currently any not-yet-acknowledged segments)
                    start timer
            }
        break;
} /* end of loop forever */
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1）TCP从应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给IP。（①注意到每一个报文段都包含一个序号，这个序号就是该报文段第一个数据字节的字节流编号。②如果定时器还没有为某些其他报文段而运行，则当报文段被传给IP时，TCP就启动该定时器。）&lt;/p&gt;
&lt;p&gt;2）超时：TCP通过重传引起超时的报文段来响应超时事件。&lt;/p&gt;
&lt;p&gt;3）来自接收方的确认报文段(ACK)的到达：TCP将ACK的值y与它的变量SendBase（是最早未被确认的字节序号）进行比较。TCP采用累积确认，所以y确认了字节编号在y之前的所有字节都已经收到。如果y &amp;gt; SenfBase，则该ACK是在确认一个或多个先前未被确认的报文段。因此，发送方更新它的SendBase变量。&lt;/p&gt;
&lt;h6 id=&#34;一些有趣的情况&#34;&gt;一些有趣的情况&lt;/h6&gt;
&lt;p&gt;三种丢包重传的情况：（注意图二中只重传第一个没有确认的包，后面的不会重传）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1gooh9bpndmj30ci0eaq3b.jpg&#34; alt=&#34;tcp-re-a.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1gooh9lsiznj30gx0fa0td.jpg&#34; alt=&#34;tcp-re-b.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1gooh9sqvvij30gz0fawex.jpg&#34; alt=&#34;tcp-re-c.jpg&#34;&gt;&lt;/p&gt;
&lt;h6 id=&#34;超时间隔加倍&#34;&gt;超时间隔加倍&lt;/h6&gt;
&lt;p&gt;TCP重传具有最小序号的还未确认的报文段。只是每次TCP重传时都会将下一次的超时间隔设为先前值的两倍，而不是用EstimatedRTT和DevRTT推算出的值.&lt;/p&gt;
&lt;p&gt;大多数TCP实现中所做的一些修改：TCP重传具有最小序号的还未被确认的报文段。只是每次TCP重传时都会将下一次的超时间隔设为先前值的两倍，而不是从EstimatedRTT和DevRTT推算出的值。然而，每当定时器在另两个事件（即收到上层应用数据或收到ACK）中的任意一个启动，TimeoutInterval由最近的EstimatedRTT和DevRTT推算得到。&lt;/p&gt;
&lt;p&gt;优点：这种修改提供了一个形式受限的拥塞控制。定时器过期很有可能是由网络拥塞引起的，即太多的分组到达源与目的地之间路径上一台（或多台）路由器的队列中，造成分组丢失或长时间的排队时延。在拥塞的时候，如果源持续重传分组，会使拥塞更加严重。因此，TCP使用更好的方法，每个发送方的重传都是经过越来越长的时间间隔后进行的。&lt;/p&gt;
&lt;h6 id=&#34;快速重传&#34;&gt;快速重传&lt;/h6&gt;
&lt;p&gt;问题：超时触发重传存在的问题是超时周期可能相对较长，当一个报文段丢失时，这种长超时周期迫使发送方延迟重传丢失的分组，因而增加了端到端时延。&lt;/p&gt;
&lt;p&gt;解决办法：冗余ACK(duplicate ACK)：就是再次确认某个报文段的ACK，而发送方先前已经收到对该报文段的确认。（通过下面理解：发送方通常在超时事件发生之前通过注意所谓冗余ACK来较好地检测到丢包情况。）&lt;/p&gt;
&lt;p&gt;因为发送方经常一个接一个地发送大量的报文段，如果一个报文段丢失，就很可能引起许多一个接一个的冗余ACK。如果TCP发送方接收到对相同数据的3个冗余ACK，它把这当做一种暗示，说明跟在这个已被确认3次的报文段之后的报文段已经丢失（为何是3个冗余ACK？）。一旦受到3个冗余ACK，TCP就执行快速重传(fast retransmit)，即在该报文段的定时器过期之前重传丢失的报文段。&lt;/p&gt;
&lt;p&gt;冗余ACK就是再次确认某个报文段的ACK，而发送方先前已经收到对该报文段的确认
一旦收到三个冗余ACK，TCP就执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1goohf14oagj30da0gb3zb.jpg&#34; alt=&#34;tcp-fr.jpg&#34;&gt;&lt;/p&gt;
&lt;h6 id=&#34;是回退n步还是选择重传&#34;&gt;是回退N步还是选择重传&lt;/h6&gt;
&lt;p&gt;对TCP提出的一种修改意见是所谓的选择确认，它允许TCP接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接受的有序报文段。&lt;/p&gt;
&lt;p&gt;TCP是一个GBN协议还是一个SR协议？&lt;/p&gt;
&lt;p&gt;1）TCP确认是累积式地、正确地接收，但是失序的报文段是不会被接收方逐个确认的。TCP发送方仅需维持已发送过但未被确认的字节的最小序号(SendBase)和下一个要发送的字节的序号(NextSeqNum)。这个意义下，TCP看起来更像一个GBN风格的协议。&lt;/p&gt;
&lt;p&gt;2）但是TCP和GBN协议之间有着一些显著的区别，许多TCP实现会将正确接收但失序的报文段缓存起来。考虑一下当发送方发送一组报文段1、2、…N的序列时，所有的报文段都是在接收方按序无差错的情况下到达的。进一步假设，对包n小于N的确认报文丢失了，但是其余的N-1确认报文在它们各自的超时之前到达了发送端。在这个例子中,GBN不仅会重新传输数据包n，还会传送所有的后续分组，n+1 n+2，…N。另一方面，TCP将重传至多一个报文段，即报文段n。此外，如果报文段n+1的确认报文在报文段n超时之前到达。TCP甚至不会重新传输段n。&lt;/p&gt;
&lt;p&gt;3）TCP提出的一种修改意见是所谓的选择确认(selective acknowledgment)[RFC2018],它允许TCP接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段。当该机制与选择重传机制结合起来使用时（即跳过重传那些已被接收方选择性地确认过的报文段），TCP看起来像SR协议。因此，TCP的差错恢复机制最后被分类为GBN协议与SR协议的混合体。&lt;/p&gt;
&lt;h4 id=&#34;flow-control&#34;&gt;Flow Control&lt;/h4&gt;
&lt;p&gt;一条TCP连接的每一侧主机都为该连接设置了接收缓存。当该TCP连接收到正确、按序的字节后，他就将数据放入到接收缓存。（注意：相关联的进程会从该缓存中读取数据，但不是数据刚一到就立即读取。）&lt;/p&gt;
&lt;p&gt;TCP为应用程序提供了流量控制服务(flow-control-service)以消除发送方使接收方缓存溢出的可能性。&lt;/p&gt;
&lt;p&gt;流量控制服务(flow-control-service)：是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。&lt;/p&gt;
&lt;p&gt;拥塞控制(congestion control)：TCP发送方可能因为IP网络的拥塞而被抑制。&lt;/p&gt;
&lt;p&gt;注意：本节假设TCP接收方丢弃失序的报文段。&lt;/p&gt;
&lt;p&gt;接收窗口(receive window)：用于给发送方一个指示：该接收方还有多少可用的缓存空间。TCP通过让发送方维护一个称为接收窗口的变量来控制流量的控制。&lt;/p&gt;
&lt;p&gt;因为TCP是全双工通信，在连接两端的发送方都各自维护一个接收窗口。&lt;/p&gt;
&lt;p&gt;假设主机A通过一条TCP连接向主机B发送一个大文件。主机B为连接分配了一个接收缓存RecvBuffer表示其大小。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//定义以下变量
• LastByteRead: the number of the last byte in the data stream read from the buffer by the application process in B
• LastByteRcvd: the number of the last byte in the data stream that has arrived from the network and has been placed in the receive buffer at B
//由于TCP不允许已分配缓存溢出，下式必须成立：
LastByteRcvd – LastByteRead ≤ RcvBuffer
//接收窗口用rwnd表示，根据缓存可用空间数量来设置：
rwnd = RcvBuffer – [LastByteRcvd – LastByteRead]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于该空间是随着时间变化的，所以rwnd是动态的，rwnd也称为滑动窗口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1goohi99gxjj30ea074dfx.jpg&#34; alt=&#34;JpD4aJs.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;1）连接是如何使用变量rwnd提供流量控制服务？主机B通过把当前的rwnd值放入它发送给主机A的报文段接收窗口字段中，通知主机A它在该连接的缓存中还有多少可用空间。&lt;/p&gt;
&lt;p&gt;开始时，主机B设定rwnd = RecvBuffer。主机A轮流跟踪两个变量LastByteSent和LastByteAcked。（LastByteSent-LastByteAcked：表示主机A发送到连接中但未被确认的数据量）。通过将未确认的数据量控制在rwnd以内，就可以保证主机A不会使主机B的接收缓存溢出。&lt;/p&gt;
&lt;p&gt;因此，主机A在整个生命周期需保证：LastByteSent – LastByteAcked ≤ rwnd&lt;/p&gt;
&lt;p&gt;2）这个方案有一个小技术问题。 假设主机B的接收缓冲区已满，使得rwnd = 0。在将rwnd = 0通知给主机A，也假设B没有什么可以发送到A。现在考虑发生什么情况，当B中的应用进程清空缓冲区时，TCP不会向主机A发送新的带有rwnd新值的新报文段; 实际上，TCP只有它有数据或者有确认要发送时才会发送保文段向主机A。因此，主机A不知道Host B的接收缓冲区已有新的空间了。即主机A被阻塞，并且不能传输更多的数据！ 为了解决这个问题，TCP规范要求：当B的接收窗口为零时，主机A继续发送一个只有1个字节数据的报文段。 这些报文段将会被接收器确认。最终缓冲区将开始清空，并且确认报文里将包含一个非0的rwnd值。&lt;/p&gt;
&lt;h4 id=&#34;tcp-connection-management&#34;&gt;TCP Connection Management&lt;/h4&gt;
&lt;p&gt;本节关注建立和拆除一条TCP连接。即三次握手，四次挥手。&lt;/p&gt;
&lt;h6 id=&#34;建立连接&#34;&gt;建立连接&lt;/h6&gt;
&lt;p&gt;TCP连接的建立会显著地增加人们感受到的时延。客户中的TCP会用以下方式与服务器中的TCP建立一条&lt;/p&gt;
&lt;p&gt;TCP连接：&lt;/p&gt;
&lt;p&gt;TCP SYN报文段&lt;/p&gt;
&lt;p&gt;1）第一步：客户端TCP首先向服务器端的TCP发送一个特殊的TCP报文段（TCP SYN报文段：该报文段不包含应用层数据，但在报文段的首部中的一个标志位SYN被置为1.）。另外，客户会随机选择一个初始序号(client_isn)，并将次编号放置与该起始的TCP SYN报文段的序号字段中。该报文段会被封装在一个IP数据报中，并发送给服务器。&lt;/p&gt;
&lt;p&gt;SYNACK报文段&lt;/p&gt;
&lt;p&gt;2）第二步：一旦包含TCP SYN报文段的IP数据报到达服务器主机（假定它的确达到了），服务器会从该数据报中提取出TCP SYN报文段，为TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段（分配的这些缓存和变量，使得TCP易于受到SYN洪泛的拒绝服务攻击），这个允许连接的报文段(SYNACK报文段：该首部有3个重要信息①SYN置为1；②确认号字段被置为client_isn+1;③服务器选择自己的初始序号server_isn，并将其放在TCP报文段首部的序号字段中。)不包含应用层数据。&lt;/p&gt;
&lt;p&gt;3）在收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另外一个报文段；这最后一个报文段对服务器的允许连接的报文段进行了确认（首部中：①确认字段为server_isn+1;②序号字段为client_isn+1;③SYN比特置为0）。该三次握手的第三个阶段可以在报文段负载中携带客户到服务器的数据。&lt;/p&gt;
&lt;p&gt;在以后的每一个报文段中，SYN比特都被置为0；这种连接创建过程被称为3次握手(three-way handshake)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1gooht0ym97j30gq0doabb.jpg&#34; alt=&#34;rX6qD9Y.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三次握手&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。&lt;/li&gt;
&lt;li&gt;服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。&lt;/li&gt;
&lt;li&gt;最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id=&#34;tcp拆除&#34;&gt;TCP拆除：&lt;/h6&gt;
&lt;p&gt;参与一条TCP连接的两个进程中的任意一个都能终止该连接。当连接结束后，主机中的“资源(缓存和变量)”将被释放。&lt;/p&gt;
&lt;p&gt;假设某客户打算关闭连接：&lt;/p&gt;
&lt;p&gt;1）客户应用进程发送一个关闭连接命令：客户TCP向服务器进程发送一个特许TCP报文段(首部的标志位FIN置为1)。&lt;/p&gt;
&lt;p&gt;2）当服务器接收到该报文段后，就向发送方发送一个确认报文段。&lt;/p&gt;
&lt;p&gt;3）服务器发送它自己的终止报文段，其FIN比特置为1.&lt;/p&gt;
&lt;p&gt;4）客户对这个服务器的终止报文段进行确认。（此时，两个主机用于连接的所有资源都被释放了。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1goohtz18m4j30fz0ew755.jpg&#34; alt=&#34;QY4o3q9.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;客户TCP状态图
1）客户TCP开始处于CLOSED状态。&lt;/p&gt;
&lt;p&gt;客户应用程序发起一个新的连接，则客户TCP向服务器中的TCP发送一个SYN报文段。&lt;/p&gt;
&lt;p&gt;2）发送过SYN报文段后，客户TCP进入了SYN_SENT状态。&lt;/p&gt;
&lt;p&gt;接着，等待来自服务器TCP的对客户所发报文段进行确认且SYN比特被置为1的一个报文段(SYNACK报文段)。&lt;/p&gt;
&lt;p&gt;3）收到SYNACK报文段之后，客户TCP进入ESTABLISHED（已建立）状态。&lt;/p&gt;
&lt;p&gt;当处在ESTABLISHED状态时，TCP客户就能发送和接收包含有效载荷数据(即应用层产生的数据)的TCP报文段了。&lt;/p&gt;
&lt;p&gt;4）假设客户要决定关闭该连接，这引起客户TCP发送一个带有FIN比特被置为1的TCP报文段，进入FIN_WAIT_1状态。&lt;/p&gt;
&lt;p&gt;客户等待来自服务器的带有确认的TCP报文段。&lt;/p&gt;
&lt;p&gt;5）收到上述报文段后，客户TCP进入FIN_WAIT_2状态。&lt;/p&gt;
&lt;p&gt;客户等待来自服务器的FIN比特置为1的另一个报文段。&lt;/p&gt;
&lt;p&gt;6）收到上述报文段后，客户TCP对服务器发送确认报文段进行确认，并进入TIME_WAIT状态。&lt;/p&gt;
&lt;p&gt;假设ACK丢失，TIME_WAIT状态使TCP客户重传最后的确认报文。在TIME_WAIT状态中所消耗的时间是与具体实现有关的，而典型值是30s，1min，或2min。经过等待后，连接就正式关闭，客户端所有资源(包括端口号)将被释放。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1goohutah9oj30h80cu0tx.jpg&#34; alt=&#34;caZ8EU7.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;服务器TCP状态图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1goohv8wiirj30gz0camy7.jpg&#34; alt=&#34;w26dgs4.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面考虑一台主机接收到一个TCP报文段，其端口号或源IP地址与该主机上进行中的套接字都不匹配。则该主机将向源发送一个特殊重置报文：该报文段将RST标志位置为1.当一台主机接收一个UDP分组，它的目的端口与进行中的UDP套接字不匹配，该主机发送一个特殊的ICMP数据报。&lt;/p&gt;
&lt;p&gt;nmap是一个功能强大的工具，该工具不仅能“侦查”打开的TCP端口，也能“侦查”UDP端口，还能侦查防火墙及其配置，甚至能侦查应用程序的版本和操作系统，大多数都能通过操作TCP连接管理报文段完成。可以从http://www.nmap.org中下载nmap。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四次挥手&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然.&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送一个数据分段, 其中的 FIN 标记设置为1. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据.&lt;/li&gt;
&lt;li&gt;服务器接收到带有 FIN = 1 的数据分段, 发送带有 ACK = 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息.&lt;/li&gt;
&lt;li&gt;服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = 1 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = 1 的确认报文.&lt;/li&gt;
&lt;li&gt;客户端收到服务器发来带有 FIN = 1 的报文, 返回 ACK = 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;principles-of-congestion-control&#34;&gt;Principles of Congestion Control&lt;/h2&gt;
&lt;p&gt;在实践中，丢包一般是当网络变得拥塞时由于路由器缓存溢出而引起的。分组重传作为网络拥塞的征兆，但是却无法处理导致网络拥塞的原因。因为有大多的源想以过高的速率发送数据。为了处理网络拥塞，需要一些机制在面临网络拥塞时抑制发送方。&lt;/p&gt;
&lt;h4 id=&#34;the-causes-and-the-costs-of-congestion&#34;&gt;The Causes and the Costs of Congestion&lt;/h4&gt;
&lt;p&gt;每连接的吞吐量(per-connection throughput)：接收方每秒接收的字节数。&lt;/p&gt;
&lt;p&gt;1）当分组的到达速率接近链路容量时，分组经历巨大的排队时延。&lt;/p&gt;
&lt;p&gt;2）发送方必须执行重传以补偿因为缓存溢出而丢弃的分组。&lt;/p&gt;
&lt;p&gt;3）发送方在遇到大时延时所进行的不必要的重传会引起路由器利用链路带宽来转发不必要的分组副本。&lt;/p&gt;
&lt;p&gt;4）由于拥塞而丢弃分组的另一种代价：当一个分组沿一条路径被丢弃时，每个上游路由器用于转发分组到丢弃该分组而使用的传输容量最终被浪费掉了。&lt;/p&gt;
&lt;h4 id=&#34;approaches-to-congestion-control&#34;&gt;Approaches to Congestion Control&lt;/h4&gt;
&lt;p&gt;根据网络层是否为运输层拥塞控制提供显示帮助开划分：&lt;/p&gt;
&lt;p&gt;1）端到端拥塞控制：网络层没有为运输层拥塞控制提供显示支持。TCP必须通过端到端的方法解决拥塞控制，因为IP层不会向端系统提供有关网络拥塞的反馈信息。TCP报文段的丢失（通过超时或3次冗余确认而得知）被认为是网络拥塞的一个迹象。&lt;/p&gt;
&lt;p&gt;2）网络辅助的拥塞控制：网络层构件（即路由器）向发送方提供有关于网络中拥塞状态的显示反馈信息。这一般有两种形式，如下图：&lt;/p&gt;
&lt;h4 id=&#34;network-assisted-congestion-control-example-atm-abr-congestion-control&#34;&gt;Network-Assisted Congestion-Control Example: ATM ABR Congestion Control&lt;/h4&gt;
&lt;p&gt;ATM ABR中的拥塞控制算法，即一种采用网络辅助方法解决拥塞控制的协议。ATM基本上采用一种面向虚电路(VC)的方法来处理分组交换。ABR被设计为一种弹性数据传输服务，该服务方式使人联想起TCP。当网络轻载时，ABR服务会充分利用空闲可用带宽；当网络拥塞时，ABR服务会将其传输速率抑制为某些预先确定的最小传输速率。&lt;/p&gt;
&lt;h2 id=&#34;tcp-congestion-control&#34;&gt;TCP Congestion Control&lt;/h2&gt;
&lt;p&gt;TCP为运行在不同主机上的两个进程之间提供了可靠传输服务和拥塞控制机制。TCP使用端到端拥塞控制（让每一个发送方根据所感受到的网络拥塞程度来限制其能向连接发送流量的速率。）而不是使用网络辅助的拥塞控制，因为IP层不向端系统提供显示的网络拥塞反馈。&lt;/p&gt;
&lt;p&gt;本节主要解决3个问题：&lt;/p&gt;
&lt;p&gt;1）一个TCP发送方如何限制它向其连接发送流量速率？&lt;/p&gt;
&lt;p&gt;2）一个TCP发送方如何感知从它到目的地之间的路径上存在拥塞？&lt;/p&gt;
&lt;p&gt;3）当发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率？&lt;/p&gt;
&lt;p&gt;TCP连接的每一端包含：①一个接收缓存②一个发送缓存③几个变量(LastByteRead，rwnd等)。另外，运行在发送方的TCP拥塞控制机制跟踪一个额外的变量：拥塞窗口(congestion window,cwmd)。&lt;/p&gt;
&lt;p&gt;特别是，在一个发送方中未被确认的数据量不会超过cwmd和rwnd中的最小值。即LastByteSent – LastByteAcked ≤ min{cwnd, rwnd}&lt;/p&gt;
&lt;p&gt;TCP发送方如何确定它们的发送速率，即使得网络不会拥塞，于此同时又能充分利用所有可能可用的带宽？&lt;/p&gt;
&lt;p&gt;1）一个丢失的报文段意为着拥塞，因此，当丢失报文段时应当降低TCP发送方的速率。&lt;/p&gt;
&lt;p&gt;2）一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认达到时，能够增加发送方的速率。&lt;/p&gt;
&lt;p&gt;3）带宽探测：TCP调节其传输速率的策略是增加其速率以响应达到的ACK，减小其速率以响应丢包事件。&lt;/p&gt;
&lt;p&gt;TCP拥塞控制算法(TCP congestion control algorithm)：①慢启动；②拥塞控制；③快速恢复。慢启动和拥塞避免是TCP的强制部分，两者的差异在于对收到的ACK做出反应时增加cwnd长度的方式。慢启动比拥塞避免能更快地增加cwnd的长度。快速恢复是推荐部分，对TCP发送方式非必须的。&lt;/p&gt;
&lt;h6 id=&#34;慢启动&#34;&gt;慢启动&lt;/h6&gt;
&lt;p&gt;当一条TCP连接开始，cwnd值通常初始置为一个MSS较小值。这使得初始发送速率为MSS/RTT。在慢启动(slow-start)状态，cwnd的值以1个MSS开始并且每当传输的报文段首次被确认就增加一个MSS。&lt;/p&gt;
&lt;p&gt;何时结束慢启动阶段的指数增长呢？①如果存在一个由超时指示的丢包事件，TCP发送方将cwnd设置为1并重新开始慢启动过程。它还将第二个状态变量的值ssthresh（慢启动阈值）设置为cwnd/2，即当检测到拥塞时将ssthresh置为拥塞窗口值的一半。②当检测到拥塞时ssthresh设为cwnd的一半，当到达或超过ssthresh的值时，结束慢启动并且TCP转移到拥塞避免模式。③如果检测到3个冗余ACK，这时TCP执行一种快速重传并进入快速恢复状态。&lt;/p&gt;
&lt;p&gt;特点：指数增长。&lt;/p&gt;
&lt;p&gt;TCP慢启动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1gooi6hc6j5j30b10f3dgg.jpg&#34; alt=&#34;slow-start.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;TCP拥塞控制的FSM描述&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/0083FLjsly1gooi62fthuj30nv0ia75w.jpg&#34; alt=&#34;tcp-congestion-control.jpg&#34;&gt;&lt;/p&gt;
&lt;h6 id=&#34;拥塞避免&#34;&gt;拥塞避免&lt;/h6&gt;
&lt;p&gt;每个RTT只将cwnd的值增加一个MSS：对于TCP发送方无论何时到达一个新的确认，就将cwnd增加一个MSS(MSS/cwnd)字节。&lt;/p&gt;
&lt;p&gt;例如，如果MSS是1460字节，并且cwnd是14 600字节，则在一个RTT内发送10个报文段。每个到达ACK增加1/10MSS的拥塞窗口长度，因此在收到对所有10个报文段的确认后，拥塞窗口的值将增加了一个MSS。&lt;/p&gt;
&lt;p&gt;当出现超时时，TCP的拥塞避免与慢启动阶段一样。&lt;/p&gt;
&lt;p&gt;当出现丢包时，网络继续从发送方向接收方交付报文段，当接收到3个冗余ACK时，将ssthresh的值置为cwnd的一半，同时将cwnd的值减半加上3个MSS。&lt;/p&gt;
&lt;h6 id=&#34;快速恢复&#34;&gt;快速恢复&lt;/h6&gt;
&lt;p&gt;1）对收到的每个用冗余ACK，cwnd值增加一个MSS。&lt;/p&gt;
&lt;p&gt;2）当对丢失报文段的一个ACK到达时，TCP在降低cwnd进入拥塞避免状态。&lt;/p&gt;
&lt;p&gt;3）如果出现超时事件，执行如同慢启动和拥塞避免中相同的动作后，迁移到慢启动状态。&lt;/p&gt;
&lt;p&gt;下图延时了Reno版TCP与Tahoe版TCP的拥塞控制窗口的演化情况。&lt;/p&gt;
&lt;h6 id=&#34;tcp拥塞控制&#34;&gt;TCP拥塞控制&lt;/h6&gt;
&lt;p&gt;TCP拥塞控制常被称为加性增、乘性减(Additove-Increase,Multiplicative-Decrease,AIMD)拥塞控制方式：假定丢包由3个冗余的ACK而不是超时指示，TCP的拥塞控制是：每个RTT内cwnd线性增加1MSS，然后出现3个冗余ACK事件时cwnd减半(乘性减)。&lt;/p&gt;
&lt;h6 id=&#34;tcp吞吐量宏观描述&#34;&gt;TCP吞吐量宏观描述&lt;/h6&gt;
&lt;p&gt;TCP连接的吞吐量：即平均速率。在一个往返间隔内，TCP发送数据的速率是拥塞窗口(w字节)与当期RTT的函数（TCP发送速率大约是w/RTT）。&lt;/p&gt;
&lt;p&gt;一条连接的平均吞吐量 = 0.75*W / RTT&lt;/p&gt;
&lt;h2 id=&#34;programming-assignments&#34;&gt;Programming Assignments&lt;/h2&gt;
&lt;h3 id=&#34;implementing-a-reliable-transport-protocol&#34;&gt;Implementing a Reliable Transport Protocol&lt;/h3&gt;
&lt;p&gt;In this laboratory programming assignment, you will be writing the sending and receiving transport-level code for implementing a simple reliable data transfer protocol. There are two versions of this lab, the alternating-bit-protocol version and the GBN version. This lab should be fun—your implementation will differ very little from what would be required in a real-world situation.&lt;/p&gt;
&lt;p&gt;Since you probably don’t have standalone machines (with an OS that you can modify), your code will have to execute in a simulated hardware/software environment. However, the programming interface provided to your routines—the code that would call your entities from above and from below—is very close to what is done in an actual UNIX environment. (Indeed, the software interfaces described in this programming assignment are much more realistic than the infinite loop senders and receivers that many texts describe.) Stopping and starting timers are also simulated, and timer interrupts will cause your timer handling routine to be activated.&lt;/p&gt;
&lt;h2 id=&#34;wireshark-lab-exploring-tcp&#34;&gt;Wireshark Lab: Exploring TCP&lt;/h2&gt;
&lt;p&gt;In this lab, you’ll use your Web browser to access a file from a Web server. As in earlier Wireshark labs, you’ll use Wireshark to capture the packets arriving at your computer. Unlike earlier labs, you’ll also be able to download a Wireshark-readable packet trace from the Web server from which you downloaded the file. In this server trace, you’ll find the packets that were generated by your own access of the Web server. You’ll analyze the client- and server-side traces to explore aspects of TCP. In particular, you’ll evaluate the performance of the TCP connection between your computer and the Web server. You’ll trace TCP’s window behavior, and infer packet loss, retransmission, flow control and congestion control behavior, and estimated roundtrip time.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www-net.cs.umass.edu/wireshark-labs/Wireshark_TCP_v8.0.pdf&#34;&gt;Wireshark Lab: TCP&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;wireshark-lab-exploring-udp&#34;&gt;Wireshark Lab: Exploring UDP&lt;/h2&gt;
&lt;p&gt;In this short lab, you’ll do a packet capture and analysis of your favorite application that uses UDP (for example, DNS or a multimedia application such as Skype). As we learned in Section 3.3, UDP is a simple, no-frills transport protocol. In this lab, you’ll investigate the header fields in the UDP segment as well as the checksum calculation.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www-net.cs.umass.edu/wireshark-labs/Wireshark_UDP_v8.0.pdf&#34;&gt;Wireshark Lab: UDP&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html?tab=contents&#34;&gt;Computer Networking: A Top-Down Approach, 6th Edition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://doowzs.com/docs/52-net/3/&#34;&gt;Chapter 3 - Transport Layer&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Application Layer</title>
      <link>http://www.yezheng.pro/post/specialization/systems/computer-networking/computer-networks-2/</link>
      <pubDate>Sat, 06 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/specialization/systems/computer-networking/computer-networks-2/</guid>
      
        <description>&lt;h2 id=&#34;principles-of-network-applications&#34;&gt;Principles of Network Applications&lt;/h2&gt;
&lt;p&gt;研究网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。不需要写在网络核心设备如路由器或链路层交换机上运行的软件。&lt;/p&gt;
&lt;h4 id=&#34;network-application-architectures&#34;&gt;Network Application Architectures&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在**客户-服务器体系结构 (client-server architecture)**中，有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。著名的应用程序包括Web、FTP、Telnet和电子邮件。&lt;/li&gt;
&lt;li&gt;在一个&lt;strong&gt;P2P体系结构(P2P architecture)&lt;strong&gt;中,对位于数据中心的专用服务器有最小的(或者没有)依赖。相反，应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为&lt;/strong&gt;对等方&lt;/strong&gt;。这些应用包括文件共享（例如BitTorrent）、对等放协助下载加速器（如迅雷）、因特网电话（例如Skype）和IPTV（如迅雷看看）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;processes-communicating&#34;&gt;Processes Communicating&lt;/h4&gt;
&lt;p&gt;在操作系统术语中，进行通信的实际上是&lt;strong&gt;进程（process）&lt;/strong&gt;。一个进程可以被认为是运行在端系统中的一个程序。当程序运行在相同的端系统上时，它们使用进程间通信机制相互通信。在不同端系统上的进程，通过跨越计算机网络交换报文（message）而相互通信。&lt;/p&gt;
&lt;h6 id=&#34;客户与服务器进程&#34;&gt;客户与服务器进程&lt;/h6&gt;
&lt;p&gt;在一对进程之间的通信会话场景中，发起通信(即在该会话开始时发起与其他进程的联系)的进程被标识为客户（client），在会话开始时等待联系的进程是服务器（server）。&lt;/p&gt;
&lt;h6 id=&#34;进程与计算机网络之间的接口&#34;&gt;进程与计算机网络之间的接口&lt;/h6&gt;
&lt;p&gt;进程通过一个称为**套接字(socket)**的软件接口向网络发送报文和从网络接收报文。应用程序可以控制套接字在应用层端的一切，但是对该套接字的运输层几片没有控制权。除选择运输层协议与设定几个运输层参数，如最大缓存和最大报文段长度等。&lt;/p&gt;
&lt;h6 id=&#34;进程寻址&#34;&gt;进程寻址&lt;/h6&gt;
&lt;p&gt;为了标识接受进程的地址，需要定义两种信息，主机的地址和定义在目的主机中的接收进程的标识符。主机友IP地址（IP address）标识。目的地端口号标识进程。&lt;/p&gt;
&lt;p&gt;Web服务器用端口号80来标识，邮件服务器进程(使用SMTP协议)用端口号25来标识。&lt;/p&gt;
&lt;h4 id=&#34;transport-services-available-to-applications&#34;&gt;Transport Services Available to Applications&lt;/h4&gt;
&lt;p&gt;一个运输层协议能够为调用它的应用程序提供什么样的服务呢？从四个方面对应用程序服务要求进行分类：可靠数据传输、吞吐量、定时、安全性.&lt;/p&gt;
&lt;h4 id=&#34;transport-services-provided-by-the-internet&#34;&gt;Transport Services Provided by the Internet&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP服务&lt;/p&gt;
&lt;p&gt;TCP服务模型包括&lt;strong&gt;面向连接服务&lt;/strong&gt;和&lt;strong&gt;可靠数据传输&lt;/strong&gt;服务，TCP还提供&lt;strong&gt;拥塞控制&lt;/strong&gt;机制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向连接：客户机/服务器进程间需建立连接。握手过程提示客户和服务器，使它们为大量分组的到来做好准备。在握手阶段后，一个TCP连接（TCP connection）就在两个进程的套接字之间建立了。这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发。&lt;/li&gt;
&lt;li&gt;可靠的传输：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　UDP是一种不提供不需要服务的轻量级运输协议，无连接：它不需在两主机间建立连接，提供&lt;strong&gt;不可靠的数据传输&lt;/strong&gt;，UDP协议并不保证该报文将到达接收进程。不仅如此，到达接收进程的报文也可能是乱序到达的。没有包括拥塞控制机制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因特网运输协议所不提供的服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论TCP还是UDP都没有提供任何加密机制，TCP的加强版本称为&lt;strong&gt;安全套接字层（Secure Sockets Layer, SSL）&lt;/strong&gt;，包括加密、数据完整性和端点鉴别。SSL不是与TCP和UDP在相同层次上的第三种运输协议，**是在应用层上实现的强化。**如果一个应用要使用SSL的服务，需要在该应用程序的客户端和服务端包括SSL代码（利用现有的、高度优化的库和类）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic2.zhimg.com/80/v2-a62b18a6ceee21254425f68cba7496f5_1440w.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;application-layer-protocols&#34;&gt;Application-Layer Protocols&lt;/h4&gt;
&lt;p&gt;应用层协议(application-layer protocol)定义了运行在不同 端系统上的应用程序进程如何相互传递报文&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公开协议：由RFC定义，Web的应用层协议是HTTP,它定义了在浏览器和Web服务器之间传输的报文格式和序列。用于电子邮件的主要应用层协议就是SMTP&lt;/li&gt;
&lt;li&gt;私有协议：多数P2P文件共享应用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;the-web-and-http&#34;&gt;The Web and HTTP&lt;/h2&gt;
&lt;h4 id=&#34;overview-of-http&#34;&gt;Overview of HTTP&lt;/h4&gt;
&lt;p&gt;Web的应用层协议是&lt;strong&gt;超文本传输协议(HyperText Transfer Protocol, HTTP)&lt;/strong&gt;,它是Web 的核心，在[RFC 1945]和[RFC 2616]中进行了定义。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;web页面=多个对象组成（对象只是一个文件，如一个html文件，一个图形，一个java小程序或一个视频）。每个对象通过一个对应的URL寻址。&lt;/li&gt;
&lt;li&gt;HTTP使用TCP作为它的支撑运输协议。&lt;/li&gt;
&lt;li&gt;HTTP客户首先发起一个与服务器的TCP连接。一旦连接建立，该浏览器和服务器进程就可以通过套接字接口访问TCP 。&lt;/li&gt;
&lt;li&gt;一旦客户向它的套接字接口发送了一个请求报文，该报文就脱离了客户控制并进入TCP的控制。 因为TCP协议，一个客户进程发出的每个HTTP请求报文最终能完整地到达服务器&lt;/li&gt;
&lt;li&gt;HTTP服务器并不保存关于客户的任何信息，所以我们说HTTP是一个无状态协议(stateless protocol)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;idempotence幂等-&#34;&gt;Idempotence(幂等 )&lt;/h4&gt;
&lt;p&gt;HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的&lt;strong&gt;副作用&lt;/strong&gt;。(注意是副作用)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GET http://www.bank.com/account/123456&lt;/code&gt;，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。&lt;code&gt;GET http://www.news.com/latest-news&lt;/code&gt;这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。&lt;/p&gt;
&lt;p&gt;DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：&lt;code&gt;DELETE http://www.forum.com/article/4231&lt;/code&gt;，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。&lt;/p&gt;
&lt;p&gt;POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：&lt;code&gt;POST http://www.forum.com/articles&lt;/code&gt;的语义是在&lt;code&gt;http://www.forum.com/articles&lt;/code&gt;下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。&lt;/p&gt;
&lt;p&gt;PUT所对应的URI是要创建或更新的资源本身。比如：&lt;code&gt;PUT http://www.forum/articles/4231&lt;/code&gt;的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。&lt;/p&gt;
&lt;h4 id=&#34;non-persistent-and-persistent-connections&#34;&gt;Non-Persistent and Persistent Connections&lt;/h4&gt;
&lt;p&gt;每个请求/响应对是经一个单独的TCP连接发送，还是所有的请求及其响应经相同的TCP连接发送呢?采用前一种方法，该应用程序被称为使用非持续连接(non-persistent connection); 采用后一种方法，该应用程序被称为使用持续连接(persistent connection) 。&lt;/p&gt;
&lt;p&gt;使用持续连接或非持续连接是由应用层决定的（HTTP默认使用的是持续连接）&lt;/p&gt;
&lt;h6 id=&#34;采用非持续连接的http&#34;&gt;采用非持续连接的HTTP&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Connection: close
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
Date: Thu, 11 Aug 2016 15:23:13 GMT
Last-Modified: Mon, 25 Jul 2016 04:32:39 GMT
Server: Apache

(body)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Connection: close&lt;/code&gt;&lt;/strong&gt; 不希望使用持续连接&lt;/p&gt;
&lt;p&gt;每个TCP连接只传输一个请求报文和一个响应报文。每次服务器发送响应报文后，会通知该TCP断开该TCP连接。HTTP客户接收响应报文，TCP连接关闭。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic3.zhimg.com/80/v2-7172e4c449549b0887fe70294748815e_1440w.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;客户向服务器发送一个TCP报文段，服务器用TCP报文段做出响应，客户向服务器返回确认。三次握手中前两个部分所耗费时间占一个RTT。完成了三次握手的前两部分后，客户结合三次握手的第三部分(确认)向该TCP连接发送一个请求报文。一旦请求报文到达服务器，服务器就在服务器就在该TCP连接上发送 HTML文件。TCP三次握手以及时间分析，总计两个往返时间RTT（Round-Trip Time, RTT）+服务器传输Html文件的时间。因此非持续连接是非常低效率的。&lt;/p&gt;
&lt;p&gt;非持续连接的两个缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要为每个请求的对象建立一个连接，对于每个连接，客户和服务器中都要分配TCP缓冲区和保持TCP变量，给服务器带来严重负担；&lt;/li&gt;
&lt;li&gt;每个对象都要遭受两倍RTT的交付时延，一个RTT用来创建TCP，另一个RTT用来请求和接受一个对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;采用持续连接的http&#34;&gt;采用持续连接的HTTP&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Connection: Keep-Alive
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
Date: Thu, 11 Aug 2016 15:23:13 GMT
Keep-Alive: timeout=5, max=1000
Last-Modified: Mon, 25 Jul 2016 04:32:39 GMT
Server: Apache

(body)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Connection: Keep-Alive&lt;/code&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;code&gt;Keep-Alive: timeout=20, max=1000&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务器在发送响应之后保持该TCP连接打开。因此，位于同一台服务器的多个Web页面都可以在单个TCP上进行传输。请求可以一个接一个地发而不必等待未决请求的回答（流水线）。如果一条连接经过一定时间间隔（一个可配置的超时间隔）仍未被使用，HTTP服务器就关闭该连接。&lt;/p&gt;
&lt;p&gt;HTTTP的默认模式是使用带流水线的持续连接。&lt;/p&gt;
&lt;h4 id=&#34;http-message-format&#34;&gt;HTTP Message Format&lt;/h4&gt;
&lt;h6 id=&#34;http请求报文&#34;&gt;HTTP请求报文&lt;/h6&gt;
&lt;p&gt;一个典型的http请求报文：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET /somedir/page.html HTTP/1.1
Host: www.hans941.tk
Connection: close
User-agent: Chrome/57.0
Accept-language: ch
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Host首部行是Web代理高速缓存所要求的。Connection:close高速浏览器不希望使用持续连接，服务器发送完请求对象后就关闭连接。&lt;/p&gt;
&lt;p&gt;User-agent服务器可以为不同类型的用户发送相同对象的不同的版本。&lt;/p&gt;
&lt;p&gt;下图是请求报文的通用格式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&#34;https://img2018.cnblogs.com/blog/226988/201905/226988-20190525102530882-1860346972.jpg&#34; alt=&#34;&#34;&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首部行后面的 实体体(Entity body),在使用 POST 方法时存储用户提交的表单。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求头Host字段,一个服务器多个网站&lt;/li&gt;
&lt;li&gt;长链接&lt;/li&gt;
&lt;li&gt;文件断点续传&lt;/li&gt;
&lt;li&gt;身份认证,状态管理,Cache缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;HTTP Method&lt;/p&gt;
&lt;p&gt;同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GET和POST除了语义之外没有区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;现代的Web Server都是支持GET中包含BODY这样的请求。虽然这种请求不可能从浏览器发出，但是现在的Web Server又不是只给浏览器用，已经完全地超出了HTML服务器的范畴了。&lt;/li&gt;
&lt;li&gt;HTTP头和Body都没有长度的要求。而对于URL长度上的限制，有两方面的原因造成：浏览器和服务器。API网关一般会限制报文大小&lt;/li&gt;
&lt;li&gt;安全不安全和GET、POST没有关系&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GET&lt;/p&gt;
&lt;p&gt;GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。&lt;/p&gt;
&lt;p&gt;GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HEAD&lt;/p&gt;
&lt;p&gt;HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POST&lt;/p&gt;
&lt;p&gt;POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PUT&lt;/p&gt;
&lt;p&gt;PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DELETE&lt;/p&gt;
&lt;p&gt;DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CONNECT&lt;/p&gt;
&lt;p&gt;CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OPTIONS&lt;/p&gt;
&lt;p&gt;OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TRACE&lt;/p&gt;
&lt;p&gt;TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。&lt;/p&gt;
&lt;p&gt;HTTP/1.1之后增加的方法&lt;/p&gt;
&lt;p&gt;在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PATCH&lt;/p&gt;
&lt;p&gt;PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：&lt;/p&gt;
&lt;p&gt;但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。 当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;http响应报文&#34;&gt;HTTP响应报文&lt;/h6&gt;
&lt;p&gt;http响应报文由三部分组成：一个初始状态行（status line），之后有6个首部行（header line），然后是实体体（entity body）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Connection: close
Date: Tue, 09 Aug 2011 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html

(data data data data data ......)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;服务器永Connection: close首部行高速客户，发送完报文后就关闭该TCP连接。Date首部行指的是服务器从文件系统中检索到对象，插入响应报文的时间，而不是对象创建或最后修改的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Last-Modified首部行指示了对象创建或者最后修改的日期和时间，对既可能在本地客户也可能在网络缓存服务器上的对象缓存来说非常重要。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个HTTP响应报文的通用格式&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img2018.cnblogs.com/blog/226988/201905/226988-20190525103019639-986868984.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;常见状态码：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态码&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1xx 报告&lt;/td&gt;
&lt;td&gt;接收到请求，继续进程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2xx 成功&lt;/td&gt;
&lt;td&gt;步骤成功接收，被理解，并被接受&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3xx 重定向&lt;/td&gt;
&lt;td&gt;为了完成请求,必须采取进一步措施&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4xx 客户端出错&lt;/td&gt;
&lt;td&gt;请求包括错的顺序或不能完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5xx 服务器出错&lt;/td&gt;
&lt;td&gt;服务器无法完成显然有效的请求&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;200 OK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;201 Created&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;204 No Content&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;301 Moved Permanently&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;302 Found&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;304 Not Modified&lt;/p&gt;
&lt;p&gt;这用于缓存目的。它告诉客户端尚未修改响应，因此客户端可以继续使用相同的缓存版本的响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;401 Unauthorized&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;400 Bad Request&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;403 Forbidden&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;404 Not Found&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;405 Method Not Allowed&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;500 Internal Server Error&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;502 Bad Gateway&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;505 HTTP Version Not Supported&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;user-server-interaction-cookies&#34;&gt;User-Server Interaction: Cookies&lt;/h4&gt;
&lt;p&gt;HTTP服务器是无状态化的，这简化了服务器的设计，这让工程师可以去开发能同时处理大量数据的高性能服务器。但是有时Web站点希望能去识别用户，为此HTTP使用了cookie来进行用户跟踪。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cookies are mainly used for three purposes:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Session management&lt;/p&gt;
&lt;p&gt;Logins, shopping carts, game scores, or anything else the server should remember&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Personalization&lt;/p&gt;
&lt;p&gt;User preferences, themes, and other settings&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tracking&lt;/p&gt;
&lt;p&gt;Recording and analyzing user behavior&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cookie技术有4个组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 HTTP 响应报文中的一个 cookie 首部行；&lt;/li&gt;
&lt;li&gt;在 HTTP 请求报文中的一个 cookie 首部行；&lt;/li&gt;
&lt;li&gt;在用户端系统中保留有一个 cookie 文件，并由用户的浏览器进行管理；&lt;/li&gt;
&lt;li&gt;位于 Web 站点的一个后端数据库。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　&lt;img src=&#34;https://img2018.cnblogs.com/blog/226988/201905/226988-20190525103608022-1309036437.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;cookie可以用于标识一个用户，cookie可以在无状态的HTTP之上建立一个用户会话层。&lt;/p&gt;
&lt;p&gt;站点不必知道用户身份，可以记录按什么顺序，在什么时间，访问了哪些页面。能够根据过去访问的网页对用户推荐产品。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cookie和Session&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会话是存储用户信息的服务器端文件，而Cookie是包含本地计算机上的用户信息的客户端文件。&lt;/li&gt;
&lt;li&gt;会话依赖于Cookie，而Cookie不依赖于Session。&lt;/li&gt;
&lt;li&gt;当用户关闭浏览器或从应用程序注销时，会话结束，而Cookies在设置的时间到期。&lt;/li&gt;
&lt;li&gt;会话可以存储用户想要的尽可能多的数据，而Cookies的大小限制为4KB。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;web-caching&#34;&gt;Web Caching&lt;/h4&gt;
&lt;p&gt;Web缓存器(Web cache)也叫代理服务器(proxy server)，它是能够代表初始Web服务器来满足HTTP请求的网络实体.Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。&lt;/p&gt;
&lt;p&gt;客户对过Web缓存器请求对象:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&#34;https://img2018.cnblogs.com/blog/226988/201905/226988-20190525104346988-822885012.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;浏览器建立一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求。&lt;/li&gt;
&lt;li&gt;Web缓存器进行检查，看看本地是否缓存了该对象副本。如果有，Web缓存器就向客户浏览器用HTTP响应报文返回该对象。&lt;/li&gt;
&lt;li&gt;如果web缓存器没有该对象，就打开一个与该对象的初始服务器的TCP连接，Web缓存器向初始服务器的TCP连接上发送一个HTTP请求。&lt;/li&gt;
&lt;li&gt;Web缓存器收到该对象，本地存储空间存储副本，并向客户浏览器利用现有TCP连接发送HTTP响应包含该副本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Web缓存器既是服务器又是客户。当它接收浏览器的请求并发回响应 时，它是一个服务器。当它向初始服务器发出请求并接收响应时，它是一个客户。&lt;/p&gt;
&lt;p&gt;Web缓存器通常由ISP购买并安装。Web缓存器可以减少成本，降低响应时间。&lt;/p&gt;
&lt;p&gt;通过使用内容分发网络（Content Distribution Network, CDN），Web缓存服务器正在因特网中发挥着越来越重要的作用。&lt;/p&gt;
&lt;h4 id=&#34;the-conditional-get&#34;&gt;The Conditional GET&lt;/h4&gt;
&lt;p&gt;那么Web缓存器什么时候才会去刷新缓存下来的页面，以保存提供给客户是最新的对象呢？&lt;/p&gt;
&lt;p&gt;HTTP协议有一处机制&amp;mdash;&amp;ndash;条件GET(conditional GET)方法。&lt;/p&gt;
&lt;p&gt;若同时满足以下两点的则称为 条件 GET 方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;请求报文使用 GET 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求报文中包含一个 &lt;strong&gt;If-Modified-Since&lt;/strong&gt;: 首部行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原始服务器向Web缓存器中返回HTTP响应时包含&lt;strong&gt;Last-Modified&lt;/strong&gt;首部行，缓存器在存储该对象的同事也存储了最后修改日期。&lt;/p&gt;
&lt;p&gt;Web缓存器向原始Web服务器发送请求：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET / HTTP/1.1
Host: www.sina.com.cn:80
If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT
Connection: Close
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Web服务器向缓存器发送一个响应报文&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.0 304 Not Modified
Date: Thu, 04 Feb 2010 12:38:41 GMT

(empty entity body)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;ldquo;Not Modified&amp;rdquo;，没有在响应报文中包含所请求的对象，高速缓存器可以使用该对象，向请求浏览器转发代理缓存器缓存的对象副本。&lt;/p&gt;
&lt;h4 id=&#34;https&#34;&gt;HTTPS&lt;/h4&gt;
&lt;p&gt;HTTPS (Hypertext Transfer Protocol Secure) is a secure version of the HTTP protocol that uses the &lt;strong&gt;SSL&lt;/strong&gt;/&lt;strong&gt;TLS&lt;/strong&gt; protocol for &lt;strong&gt;encryption&lt;/strong&gt; and &lt;strong&gt;authentication&lt;/strong&gt;.&lt;/p&gt;
&lt;h6 id=&#34;how-is-https-different-from-http&#34;&gt;How is HTTPS different from HTTP?&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS adds &lt;strong&gt;encryption&lt;/strong&gt; (加密), &lt;strong&gt;authentication&lt;/strong&gt; (认证), and &lt;strong&gt;integrity&lt;/strong&gt; (完整性) to the HTTP protocol:&lt;/li&gt;
&lt;li&gt;由于HTTP最初是作为纯文本协议设计的，因此容易受到&lt;strong&gt;窃听和中间人攻击&lt;/strong&gt;。通过包括SSL/TLS加密，HTTPS可以防止第三方拦截和读取通过Internet发送的数据。&lt;/li&gt;
&lt;li&gt;与HTTP不同，HTTPS包括通过SSL / TLS协议进行的可靠身份验证。&lt;/li&gt;
&lt;li&gt;HTTPS Web服务器发送到浏览器的每个文档（例如网页，图像或JavaScript文件）都包含数字签名，网络浏览器可以使用该数字签名来确定文档没有被第三方或否则在运输过程中损坏。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;https-message-sequence-diagram-with-detailed-tls-handshaking-steps&#34;&gt;HTTPS message sequence diagram with detailed TLS handshaking steps&lt;/h6&gt;
&lt;p&gt;&lt;img src=&#34;https://www.researchgate.net/profile/Kanchana-Thilakarathna/publication/306187575/figure/fig1/AS:395752913293314@1471366255623/HTTPS-message-sequence-diagram-with-detailed-TLS-handshaking-steps.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;**“客户端问候”消息：**客户端通过向服务器发送“问候”消息来发起握手。该消息将包括客户端支持的TLS版本，支持的密码套件以及称为“客户端随机”的随机字节字符串。&lt;/li&gt;
&lt;li&gt;**“服务器问候”消息：**作为对客户端问候消息的答复，服务器发送一条消息，其中包含服务器的&lt;a href=&#34;https://www.cloudflare.com/learning/ssl/what-is-an-ssl-certificate/&#34;&gt;SSL证书&lt;/a&gt;，服务器选择的密码套件和“服务器随机”，这是服务器生成的另一个随机字节字符串。&lt;/li&gt;
&lt;li&gt;**身份验证：**客户端使用颁发它的证书颁发机构验证服务器的SSL证书。这确认服务器是它所说的身份，并且该客户端正在与该域的实际所有者进行交互。&lt;/li&gt;
&lt;li&gt;**premaster机密：**客户端再发送一个随机的字节串，即“ premaster机密”。Premaster机密使用公钥加密，并且只能由服务器使用私钥解密。（客户端从服务器的SSL证书获取&lt;a href=&#34;https://www.cloudflare.com/learning/ssl/how-does-public-key-encryption-work/&#34;&gt;公共密钥&lt;/a&gt;。）&lt;/li&gt;
&lt;li&gt;**使用的私钥：**服务器解密premaster机密。&lt;/li&gt;
&lt;li&gt;**创建的会话密钥：**客户端和服务器均根据客户端随机数，服务器随机数和premaster机密生成会话密钥。他们应该得出相同的结果。&lt;/li&gt;
&lt;li&gt;**客户端已准备就绪：**客户端发送“完成”消息，该消息已用会话密钥加密。&lt;/li&gt;
&lt;li&gt;**服务器已准备就绪：**服务器发送了一条用会话密钥加密的“完成”消息。&lt;/li&gt;
&lt;li&gt;**实现了安全的对称加密：**握手已完成，并且使用会话密钥继续进行通信。&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id=&#34;how-the-client-verifies-the-servers-ssl-certificate&#34;&gt;How the client verifies the server&amp;rsquo;s SSL certificate&lt;/h6&gt;
&lt;p&gt;使用发行者&lt;strong&gt;证书发行者的公钥&lt;/strong&gt;解开服务器的证书，查看是否和服务器的实际域名相匹配；&lt;/p&gt;
&lt;h6 id=&#34;tls-cryptographic-algorithms&#34;&gt;TLS Cryptographic Algorithms&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;All TLS handshakes make use of &lt;strong&gt;asymmetric encryption&lt;/strong&gt; (the public and private key) . which means that they &lt;strong&gt;use two different keys: a public key for encryption and a private key for decryption.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RSA (Rivest-Shamir-Adleman), DH (Difﬁe-Hellman),&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generate session keys in order to use symmetric encryption after the handshake is complete.&lt;/p&gt;
&lt;p&gt;All the &lt;strong&gt;bulk cipher algorithms&lt;/strong&gt; are &lt;strong&gt;symmetric algorithms&lt;/strong&gt; using &lt;strong&gt;the same key for encryption and decryption&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;AES, RC4&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;http2&#34;&gt;HTTP2&lt;/h4&gt;
&lt;h6 id=&#34;binary-framing-layer-二进制框架层&#34;&gt;Binary framing layer (二进制框架层)&lt;/h6&gt;
&lt;p&gt;At the core of all performance enhancements of HTTP/2 is the new binary framing layer, both client and server must use the new &lt;strong&gt;binary encoding&lt;/strong&gt; mechanism to understand each other.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.oreilly.com/library/view/high-performance-browser/9781449344757/images/hpbn_1201.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h6 id=&#34;streams-messages-and-frames&#34;&gt;Streams, messages, and frames&lt;/h6&gt;
&lt;p&gt;&lt;img src=&#34;https://www.oreilly.com/library/view/high-performance-browser/9781449344757/images/hpbn_1202.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;HTTP/2 breaks down the HTTP protocol communication into an exchange of binary-encoded frames, which are then mapped to &lt;strong&gt;messages that belong to a particular stream&lt;/strong&gt;, all of which are multiplexed within a single TCP connection.&lt;/p&gt;
&lt;h6 id=&#34;request-and-response-multiplexing&#34;&gt;Request and response multiplexing&lt;/h6&gt;
&lt;p&gt;&lt;img src=&#34;https://www.oreilly.com/library/view/high-performance-browser/9781449344757/images/hpbn_1203.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用HTTP / 1.x，如果客户端希望发出多个并行请求以提高性能，则必须使用&lt;strong&gt;多个TCP连接&lt;/strong&gt;。此行为是HTTP / 1.x传递模型的直接结果，该模型确保&lt;strong&gt;每个连接一次只能传递一个响应&lt;/strong&gt;（响应队列）。更糟糕的是，这还会导致行头阻塞和底层TCP连接的低效使用。&lt;/p&gt;
&lt;p&gt;HTTP / 2中新的二进制框架层消除了这些限制，并通过允许客户端和服务器将HTTP消息分解为独立的帧，进行交织，然后在另一端重新组装，从而实现了完整的请求和响应多路复用。&lt;/p&gt;
&lt;h6 id=&#34;server-push&#34;&gt;Server push&lt;/h6&gt;
&lt;p&gt;Another powerful new feature of HTTP/2 is the ability of the server to &lt;strong&gt;send multiple responses for a single client request&lt;/strong&gt;. That is, in addition to the response to the original request, the server can &lt;strong&gt;push additional resources to the client&lt;/strong&gt; without the client having to request each one explicitly.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.oreilly.com/library/view/high-performance-browser/9781449344757/images/hpbn_1204.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;dnsthe-internets-directory-service&#34;&gt;DNS–The Internet’s Directory Service&lt;/h2&gt;
&lt;h4 id=&#34;services-provided-by-dns&#34;&gt;Services Provided by DNS&lt;/h4&gt;
&lt;h4 id=&#34;overview-of-how-dns-works&#34;&gt;Overview of How DNS Works&lt;/h4&gt;
&lt;h4 id=&#34;dns-records-and-messages&#34;&gt;DNS Records and Messages&lt;/h4&gt;
&lt;h2 id=&#34;peer-to-peer-applications&#34;&gt;Peer-to-Peer Applications&lt;/h2&gt;
&lt;h4 id=&#34;p2p-file-distribution&#34;&gt;P2P File Distribution&lt;/h4&gt;
&lt;h4 id=&#34;distributed-hash-tables-dhts&#34;&gt;Distributed Hash Tables (DHTs)&lt;/h4&gt;
&lt;h4 id=&#34;case-study-p2p-internet-telephony-with-skype&#34;&gt;Case Study: P2P Internet Telephony with Skype&lt;/h4&gt;
&lt;h2 id=&#34;socket-programming-creating-network-applications&#34;&gt;Socket Programming: Creating Network Applications&lt;/h2&gt;
&lt;p&gt;网络应用程序有两类。&lt;strong&gt;一类是实现在协议标准&lt;/strong&gt;（如一个RFC或某种其他标准文档）&lt;strong&gt;中所定义的操作；这样的应用程序又称为“开放”的&lt;/strong&gt;，因为定义其操作的这些规则人所共知。对于这样的实现，客户程序和服务器程序必须遵守由该RFC所规定的规则。如果一个开发者编写客户程序的代码，另一个开发者编写服务器程序的代码，并且两者都完全遵从该RFC的各种规则，那么这两个程序将能够交互操作。&lt;/p&gt;
&lt;p&gt;另一类网络应用程序是&lt;strong&gt;专用的网络应用程序&lt;/strong&gt;。在这种情况下，由客户和服务器程序应用的应用层协议没有公开发布在某RFC中或其他地方。某单独的开发者（或开发团队）创建了客户和服务器程序，并且该开发者用他的代码完全控制程序的功能。但是因为这些代码并没有实现一个开放的协议，其他独立的开发者将不能开发出和该应用程序交互的代码。&lt;/p&gt;
&lt;p&gt;在研发阶段，开发者必须最先做的一个决定是，应用程序是运行在TCP上还是运行在UDP上。前面讲过TCP是面向连接的，并且为两个端系统之间的数据流动提供可靠的字节流通道。UDP是无连接的，从一个端系统向另一个端系统发送独立的数据分组，不对交付提供任何保证。前面也讲过当客户或服务器程序&lt;strong&gt;实现了一个由某RFC定义的协议，它应当使用与该协议关联的周知端口号&lt;/strong&gt;；与之相反，&lt;strong&gt;当研发一个专用应用程序，研发者必须注意避免使用这样的周知端口号&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;socket-programming-with-udp&#34;&gt;Socket Programming with UDP&lt;/h4&gt;
&lt;p&gt;应用程序开发者在套接字的应用层一侧可以控制所有东西；然而，它几乎无法控制运输层一侧。&lt;/p&gt;
&lt;p&gt;在发送进程能够将数据分组推出套接字之门之前，当使用UDP时，必须先将目的地址附在该分组之上。在该分组传过发送方的套接字之后，因特网将使用该目的地址通过因特网为该分组选路到接收进程的套接字。当分组到达接收套接字时，接收进程将通过该套接字取回分组，进而检查分组的内容并采取适当的动作。&lt;/p&gt;
&lt;p&gt;当生成一个套接字时，就为它分配一个称为端口号（port number）的标识符。因此，如你所期待的，分组的目的地址也包括该套接字的端口号。&lt;/p&gt;
&lt;p&gt;归纳起来，&lt;strong&gt;发送进程为分组附上的目的地址是由目的主机的IP地址和目的地套接字的端口号组成的&lt;/strong&gt;。此外，如我们很快将看到的那样，发送方的源地址也是由源主机的IP地址和源套接字的端口号组成，该源地址也要附在分组之上。然而，将源地址附在分组之上通常并不是由UDP应用程序代码所为，而是由底层操作系统自动完成的。&lt;/p&gt;
&lt;p&gt;下显示了客户和服务器的主要与套接字相关的活动，两者通过UDP运输服务进行通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://yqfile.alicdn.com/f3a0f4417d3d8aa377ee4f987f52623a4031c0fc.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;客户程序被称为UDPClient.py，服务器程序被称为UDPServer.py。为了强调关键问题，我们有意提供最少的代码。“好代码”无疑将具有一些更为辅助性的代码行，特别是用于处理出现差错的情况。&lt;/p&gt;
&lt;h6 id=&#34;udpclientpy&#34;&gt;UDPClient.py&lt;/h6&gt;
&lt;p&gt;下面是该应用程序客户端的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from socket import *

# 服务器的P地址（如“128.138.32.126”）或者服务器的主机名（如“cis.poly.edu”）的字符串, 如果我们使用主机名，则将自动执行DNS lookup从而得到IP地址
serverName = ‘hostname’                                           
serverPort = 12000 

# 创建了客户的套接字，第一个参数指示了地址簇；特别是，AF_INET指示了底层网络使用了IPv4。
# 第二个参数指示了该套接字是SOCK_DGRAM类型的，这意味着它是一个UDP套接字
# 没有指定客户套接字的端口号,操作系统会设置
clientSocket = socket(AF_INET, SOCK_DGRAM) 

message = raw_input(’Input lowercase sentence:’) 

# 为报文附上目的地址，并且向进程的套接字clientSocket发送结果分组
# 源地址也附到分组上，尽管这是自动完成的，而不是显式地由代码完成的。
clientSocket.sendto(message.encode(),(serverName, serverPort)) 

# 方法recvfrom也取缓存长度2048作为输入
modifiedMessage, serverAddress = clientSocket.recvfrom(2048) 

print modifiedMessage.decode() 

# 关闭套接字
clientSocket.close()
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&#34;udpserverpy&#34;&gt;UDPServer.py&lt;/h6&gt;
&lt;p&gt;现在来看看这个应用程序的服务器端：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from socket import * 

serverPort = 12000 

# 创建套接字类型SOCK_DGRAM（一种UDP套接字）
serverSocket = socket(AF_INET, SOCK_DGRAM) 

# 将端口号12000与个服务器的套接字绑定（即分配）在一起,代码显式地为该套接字分配一个端口号
serverSocket.bind((&#39;&#39;, serverPort)) 

print (“The server is ready to receive”) 

while True: 
    # 当某分组到达该服务器的套接字时，该分组的数据被放置到变量message中，其源地址被放置到变量clientAddress中。
	message, clientAddress = serverSocket.recvfrom(2048) 
	modifiedMessage = message.decode().upper() 
	# UDPServer将利用该源地址信息返回
	# 将该客户的地址（IP地址和端口号）附到大写报文上，并将所得的分组发送到服务器的套接字中。
	# 服务器地址也附在分组上，尽管这是自动而不是显式地由代码完成的。
	serverSocket.sendto(modifiedMessage.encode(), clientAddress)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了测试这对程序，在服务器主机上执行编译的服务器程序UDPServer.py。这在服务器上创建了一个进程，等待着某个客户与之联系。然后，保证在UDPClient.py中包括适当的服务器主机名或IP地址，在客户主机上执行编译的客户器程序UDPClient.py。这在客户上创建了一个进程。最后，在客户上使用应用程序，键入一个句子并以回车结束。&lt;/p&gt;
&lt;h4 id=&#34;socket-programming-with-tcp&#34;&gt;Socket Programming with TCP&lt;/h4&gt;
&lt;p&gt;与UDP不同，TCP是一个面向连接的协议。这意味着在客户和服务器能够开始互相发送数据之前，它们先要握手和创建一个TCP连接。TCP连接的一端与客户套接字相联系，另一端与服务器套接字相联系。当创建该TCP连接时，我们将其与客户套接字地址（IP地址和端口号）和服务器套接字地址（IP地址和端口号）关联起来。使用创建的TCP连接，当一侧要向另一侧发送数据时，它只需经过其套接字将数据丢给TCP连接。这与UDP不同，UDP服务器在将分组丢进套接字之前必须为其附上一个目的地地址。
现在我们仔细观察一下TCP中客户程序和服务器程序的交互。客户具有向服务器发起接触的任务。服务器为了能够对客户的初始接触做出反应，服务器必须已经准备好。这意味着两件事。第一，与在UDP中的情况一样，TCP服务器在客户试图发起接触前必须作为进程运行起来。第二，服务器程序必须具有一扇特殊的门，更精确地说是一个特殊的套接字，该门欢迎来自运行在任意主机上的客户进程的某些初始接触。使用房子/门来比喻进程/套接字，有时我们将客户的初始接触称为“敲欢迎之门”。
随着服务器进程的运行，客户进程能够向服务器发起一个TCP连接。这是由客户程序通过创建一个TCP套接字完成的。当该客户生成其TCP套接字时，它指定了服务器中的欢迎套接字的地址，即服务器主机的IP地址及其套接字的端口号。生成其套接字后，该客户发起了一个三次握手并创建与服务器的一个TCP连接。发生在运输层的三次握手，对于客户和服务器程序是完全透明的。
在三次握手期间，客户进程敲服务器进程的欢迎之门。当该服务器“听”到敲门时，它将生成一扇新门（更精确地讲是一个新套接字），它专门用于特定的客户。在我们下面的例子中，欢迎之门是一个我们称为serverSocket的TCP套接字对象；它专门对客户进行连接的新生成的套接字，称为连接套接字（connection Socket）。初次遇到TCP套接字的学生有时会混淆欢迎套接字（这是所有要与服务器通信的客户的起始接触点）和每个新生成的服务器侧的连接套接字（这是随后为与每个客户通信而生成的套接字）。
从应用程序的观点来看，客户套接字和服务器连接套接字直接通过一根管道连接。如图2-29所示，客户进程可以向它的套接字发送任意字节，并且TCP保证服务器进程能够按发送的顺序接收（通过连接套接字）每个字节。TCP因此在客户和服务器进程之间提供了可靠服务。此外，就像人们可以从同一扇门进和出一样，客户进程不仅能向它的套接字发送字节，也能从中接收字节；类似地，服务器进程不仅从它的连接套接字接收字节，也能向其发送字节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://yqfile.alicdn.com/449d86f1fb6c99e9dda16b5e075cf1e77ec2289a.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;下图显示了客户和服务器的主要与套接字相关的活动，两者通过TCP运输服务进行通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://yqfile.alicdn.com/4054507a62b63bc6c0ce7c4ac9496aa6979190b6.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;h6 id=&#34;tcpclientpy&#34;&gt;TCPClient.py&lt;/h6&gt;
&lt;p&gt;这里给出了应用程序客户端的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from socket import * 

serverName = ’servername’ 
serverPort = 12000 

# 第一个参数仍指示底层网络使用的是IPv4。第二个参数指示该套接字是SOCK_STREAM类型。这表明它是一个TCP套接字（而不是一个UDP套接字）
# 创建该客户套接字时仍未指定其端口号；操作系统会自动附上端口号
clientSocket = socket(AF_INET, SOCK_STREAM) 

# 前面讲过在客户能够使用一个TCP套接字向服务器发送数据之前（反之亦然），必须在客户与服务器之间创建一个TCP连接。
# 这行发起了客户和服务器之间的这条TCP连接。这行代码执行完后，执行三次握手，并在客户和服务器之间创建起一条TCP连接。
clientSocket.connect((serverName,serverPort)) 

sentence = raw_input(‘Input lowercase sentence:’) 

# 该程序并未显式地创建一个分组并为该分组附上目的地址，而使用UDP套接字却要那样做。客户程序只是将字符串sentence中的字节放入该TCP连接中去。
clientSocket.send(sentence.encode()) 

# 等待接收来自服务器的字节，字符继续积累在modifiedSentence中，直到收到回车符才会结束该行。
modifiedSentence = clientSocket.recv(1024) 

print(‘From Server:’, modifiedSentence.decode()) 

# 关闭客户的套接字，因此关闭了客户和服务器之间的TCP连接。它引起客户中的TCP向服务器中的TCP发送一条TCP报文
clientSocket.close()
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&#34;tcpserverpy&#34;&gt;TCPServer.py&lt;/h6&gt;
&lt;p&gt;现在我们看一下服务器程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from socket import * 

serverPort = 12000 

# 服务器创建一个TCP套接字
serverSocket = socket(AF_INET,SOCK_STREAM) 

# 将服务器的端口号serverPort与该套接字关联起来
serverSocket.bind((‘’,serverPort)) 

# 但对TCP而言，serverSocket将是我们的欢迎套接字
# 该行让服务器聆听来自客户的TCP连接请求。其中参数定义了请求连接的最大数（至少为1）
serverSocket.listen(1) 

print ‘The server is ready to receive’ 

while True: 
    # 当客户敲该门时，程序为serverSocket调用accept()，这在服务器中创建了一个称为connectionSocket的新套接字，由这个特定的客户专用。
    # 客户和服务器则完成了握手，在客户的clientSocket和服务器的serverSocket之间创建了一个TCP连接。
    connectionSocket, addr = serverSocket.accept() 
    
    # 借助于创建的TCP连接，客户与服务器现在能够通过该连接相互发送字节。
    sentence = connectionSocket.recv(1024).decode() 
    
    capitalizedSentence = sentence.upper() 
    
    # 使用TCP，从一侧发送的所有字节不仅确保到达另一侧，而且确保按序到达。
    connectionSocket.send(capitalizedSentence)
    
    # 关闭了该连接套接字,但由于serverSocket保持打开，所以另一个客户此时能够敲门并向该服务器发送一个句子要求修改。
    connectionSocket.close()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在两台单独的主机上运行这两个程序，也可以修改它们以达到稍微不同的目的。你应当将前面两个UDP程序与这两个TCP程序进行比较，观察它们的不同之处。&lt;/p&gt;
&lt;h2 id=&#34;socket-programming-assignments&#34;&gt;Socket Programming Assignments&lt;/h2&gt;
&lt;p&gt;The companion Web site includes six socket programming assignments. The first four assignments are summarized below. The fifth assignment makes use of the ICMP protocol and is summarized at the end of Chapter 4. The sixth assignment employs multimedia protocols and is summarized at the end of Chapter 7. It is highly recommended that students complete several, if not all, of these assignments.  Students can find full details of these assignments, as well as important snippets of the Python code, at the Web site &lt;a href=&#34;http://www.awl.com/kurose-ross&#34;&gt;http://www.awl.com/kurose-ross&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;assignment-1-web-server&#34;&gt;Assignment 1: Web Server&lt;/h4&gt;
&lt;p&gt;In this assignment, you will develop a simple Web server in Python that is capable of processing only one request. Specifically, your Web server will (i) create a con- nection socket when contacted by a client (browser); (ii) receive the HTTP request from this connection; (iii) parse the request to determine the specific file being requested; (iv) get the requested file from the server’s file system; (v) create an HTTP response message consisting of the requested file preceded by header lines; and (vi) send the response over the TCP connection to the requesting browser. If a browser requests a file that is not present in your server, your server should return a “404 Not Found” error message.&lt;/p&gt;
&lt;p&gt;In the companion Web site, we provide the skeleton code for your server. Your job is to complete the code, run your server, and then test your server by sending requests from browsers running on different hosts. If you run your server on a host that already has a Web server running on it, then you should use a different port than port 80 for your Web server.&lt;/p&gt;
&lt;h4 id=&#34;assignment-2-udp-pinger&#34;&gt;Assignment 2: UDP Pinger&lt;/h4&gt;
&lt;p&gt;In this programming assignment, you will write a client ping program in Python.  Your client will send a simple ping message to a server, receive a corresponding pong message back from the server, and determine the delay between when the client sent the ping message and received the pong message. This delay is called the Round Trip Time (RTT). The functionality provided by the client and server is similar to the functionality provided by standard ping program available in modern operating systems. However, standard ping programs use the Internet Control Mes- sage Protocol (ICMP) (which we will study in Chapter 4). Here we will create a nonstandard (but simple!) UDP-based ping program.  Your ping program is to send 10 ping messages to the target server over UDP.  For each message, your client is to determine and print the RTT when the correspon- ding pong message is returned. Because UDP is an unreliable protocol, a packet sent by the client or server may be lost. For this reason, the client cannot wait indefinitely for a reply to a ping message. You should have the client wait up to one second for a reply from the server; if no reply is received, the client should assume that the packet was lost and print a message accordingly.&lt;/p&gt;
&lt;p&gt;In this assignment, you will be given the complete code for the server (avail- able in the companion Web site). Your job is to write the client code, which will be very similar to the server code. It is recommended that you first study carefully the server code. You can then write your client code, liberally cutting and pasting lines from the server code.&lt;/p&gt;
&lt;h4 id=&#34;assignment-3-mail-client&#34;&gt;Assignment 3: Mail Client&lt;/h4&gt;
&lt;p&gt;The goal of this programming assignment is to create a simple mail client that sends email to any recipient. Your client will need to establish a TCP connection with a mail server (e.g., a Google mail server), dialogue with the mail server using the SMTP protocol, send an email message to a recipient (e.g., your friend) via the mail server, and finally close the TCP connection with the mail server.&lt;/p&gt;
&lt;p&gt;For this assignment, the companion Web site provides the skeleton code for your client. Your job is to complete the code and test your client by sending email to different user accounts. You may also try sending through different servers (for example, through a Google mail server and through your university mail server).&lt;/p&gt;
&lt;h4 id=&#34;assignment-4-multi-threaded-web-proxy&#34;&gt;Assignment 4: Multi-Threaded Web Proxy&lt;/h4&gt;
&lt;p&gt;In this assignment, you will develop a Web proxy. When your proxy receives an HTTP request for an object from a browser, it generates a new HTTP request for the same object and sends it to the origin server. When the proxy receives the corresponding HTTP response with the object from the origin server, it creates a new HTTP response, including the object, and sends it to the client. This proxy will be multi-threaded, so that it will be able to handle multiple requests at the same time.&lt;/p&gt;
&lt;p&gt;For this assignment, the companion Web site provides the skeleton code for the proxy server. Your job is to complete the code, and then test it by having different browsers request Web objects via your proxy.&lt;/p&gt;
&lt;h2 id=&#34;wireshark-lab-http&#34;&gt;Wireshark Lab: HTTP&lt;/h2&gt;
&lt;p&gt;In this lab, we’ll explore several aspects of the HTTP protocol: &lt;strong&gt;the basic GET/response interaction&lt;/strong&gt;, &lt;strong&gt;HTTP message formats&lt;/strong&gt;, &lt;strong&gt;retrieving large HTML files&lt;/strong&gt;, &lt;strong&gt;retrieving HTML files with embedded objects&lt;/strong&gt;, and &lt;strong&gt;HTTP authentication and security&lt;/strong&gt;.&lt;/p&gt;
&lt;h4 id=&#34;the-basic-http-getresponse-interaction&#34;&gt;The Basic HTTP GET/response interaction&lt;/h4&gt;
&lt;p&gt;Let’s begin our exploration of HTTP by downloading a very simple HTML file - one that is very short, and contains no embedded objects. Do the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Start up your web browser.&lt;/li&gt;
&lt;li&gt;Start up the Wireshark packet sniffer, as described in the Introductory lab (but don’t yet begin packet capture). Enter “http” (just the letters, not the quotation marks) in the display-filter-specification window, so that only captured HTTP messages will be displayed later in the packet-listing window. (We’re only interested in the HTTP protocol here, and don’t want to see the clutter of all captured packets).&lt;/li&gt;
&lt;li&gt;Wait a bit more than one minute (we’ll see why shortly), and then begin Wireshark packet capture.&lt;/li&gt;
&lt;li&gt;Enter the following to your browser &lt;a href=&#34;http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html&#34;&gt;http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html&lt;/a&gt; Your browser should display the very simple, one-line HTML file.&lt;/li&gt;
&lt;li&gt;Stop Wireshark packet capture.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Your Wireshark window should look similar to the window shown in Figure 1. If you are unable to run Wireshark on a live network connection, you can download a packet trace that was created when the steps above were followed.&lt;/p&gt;
&lt;p&gt;Figure 1: Wireshark Display after &lt;a href=&#34;http://gaia.cs.umass.edu/wireshark-labs/&#34;&gt;http://gaia.cs.umass.edu/wireshark-labs/&lt;/a&gt; HTTPwireshark-file1.html has been retrieved by your browser&lt;/p&gt;
&lt;p&gt;The example in Figure 1 shows in the packet-listing window that two HTTP messages were captured: the GET message (from your browser to the gaia.cs.umass.edu web server) and the response message from the server to your browser. The packet-contents window shows details of the selected message (in this case the HTTP OK message, which is highlighted in the packet-listing window). Recall that since the HTTP message was carried inside a TCP segment, which was carried inside an IP datagram, which was carried within an Ethernet frame, Wireshark displays the Frame, Ethernet, IP, and TCP packet information as well. We want to minimize the amount of non-HTTP data displayed (we’re interested in HTTP here, and will be investigating these other protocols is later labs), so make sure the boxes at the far left of the Frame, Ethernet, IP and TCP information have a plus sign or a right-pointing triangle (which means there is hidden, undisplayed information), and the HTTP line has a minus sign or a down-pointing triangle (which means that all information about the HTTP message is displayed).&lt;/p&gt;
&lt;p&gt;Download the zip file &lt;a href=&#34;http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip&#34;&gt;http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip&lt;/a&gt; and extract the file http-ethereal-trace-1. The traces in this zip file were collected by Wireshark running on one of the author’s computers, while performing the steps indicated in the Wireshark lab. Once you have downloaded the trace, you can load it into Wireshark and view the trace using the File pull down menu, choosing Open, and then selecting the http-ethereal-trace-1 trace file. The resulting display should look similar to Figure 1. (The Wireshark user interface displays just a bit differently on different operating systems, and in different versions of Wireshark).&lt;/p&gt;
&lt;p&gt;(Note: You should ignore any HTTP GET and response for favicon.ico. If you see a reference to this file, it is your browser automatically asking the server if it (the server) has a small icon file that should be displayed next to the displayed URL in your browser. We’ll ignore references to this pesky file in this lab.).&lt;/p&gt;
&lt;p&gt;By looking at the information in the HTTP GET and response messages, answer the following questions. When answering the following questions, you should print out the GET and response messages (see the introductory Wireshark lab for an explanation of how to do this) and indicate where in the message you’ve found the information that answers the following questions. When you hand in your assignment, annotate the output so that it’s clear where in the output you’re getting the information for your answer (e.g., for our classes, we ask that students markup paper copies with a pen, or annotate electronic copies with text in a colored font).&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Is your browser running HTTP version 1.0 or 1.1? What version of HTTP is the server running?&lt;/li&gt;
&lt;li&gt;What languages (if any) does your browser indicate that it can accept to the server?&lt;/li&gt;
&lt;li&gt;What is the IP address of your computer? Of the gaia.cs.umass.edu server?&lt;/li&gt;
&lt;li&gt;What is the status code returned from the server to your browser?&lt;/li&gt;
&lt;li&gt;When was the HTML file that you are retrieving last modified at the server?R&lt;/li&gt;
&lt;li&gt;How many bytes of content are being returned to your browser?&lt;/li&gt;
&lt;li&gt;By inspecting the raw data in the packet content window, do you see any headers within the data that are not displayed in the packet-listing window? If so, name one.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In your answer to question 5 above, you might have been surprised to find that the document you just retrieved was last modified within a minute before you downloaded the document. That’s because (for this particular file), the gaia.cs.umass.edu server is setting the file’s last-modified time to be the current time, and is doing so once per minute. Thus, if you wait a minute between accesses, the file will appear to have been recently modified, and hence your browser will download a “new” copy of the document.&lt;/p&gt;
&lt;h4 id=&#34;the-http-conditional-getresponse-interaction&#34;&gt;The HTTP CONDITIONAL GET/response interaction&lt;/h4&gt;
&lt;p&gt;Recall from Section 2.2.5 of the text, that most web browsers perform object caching and thus perform a conditional GET when retrieving an HTTP object. Before performing the steps below, make sure your browser’s cache is empty. (To do this under Firefox, select Tools-&amp;gt;Clear Recent History and check the Cache box, or for Internet Explorer, select Tools-&amp;gt;Internet Options-&amp;gt;Delete File; these actions will remove cached files from your browser’s cache.) Now do the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Start up your web browser, and make sure your browser’s cache is cleared, as discussed above.&lt;/li&gt;
&lt;li&gt;Start up the Wireshark packet sniffer&lt;/li&gt;
&lt;li&gt;Enter the following URL into your browser &lt;a href=&#34;http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file2.html&#34;&gt;http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file2.html&lt;/a&gt; Your browser should display a very simple five-line HTML file.&lt;/li&gt;
&lt;li&gt;Quickly enter the same URL into your browser again (or simply select the refresh button on your browser)&lt;/li&gt;
&lt;li&gt;Stop Wireshark packet capture, and enter “http” in the display-filter-specification window, so that only captured HTTP messages will be displayed later in the packet-listing window.&lt;/li&gt;
&lt;li&gt;(Note: If you are unable to run Wireshark on a live network connection, you can use the http-ethereal-trace-2 packet trace to answer the questions below; see footnote 1. This trace file was gathered while performing the steps above on one of the author’s computers.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Answer the following questions:&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;Inspect the contents of the first HTTP GET request from your browser to the server. Do you see an “IF-MODIFIED-SINCE” line in the HTTP GET?&lt;/li&gt;
&lt;li&gt;Inspect the contents of the server response. Did the server explicitly return the contents of the file? How can you tell?&lt;/li&gt;
&lt;li&gt;Now inspect the contents of the second HTTP GET request from your browser to the server. Do you see an “IF-MODIFIED-SINCE:” line in the HTTP GET? If so, what information follows the “IF-MODIFIED-SINCE:” header?&lt;/li&gt;
&lt;li&gt;What is the HTTP status code and phrase returned from the server in response to this second HTTP GET? Did the server explicitly return the contents of the file? Explain.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;retrieving-long-documents&#34;&gt;Retrieving Long Documents&lt;/h4&gt;
&lt;p&gt;In our examples thus far, the documents retrieved have been simple and short HTML files. Let’s next see what happens when we download a long HTML file. Do the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Start up your web browser, and make sure your browser’s cache is cleared, as discussed above.&lt;/li&gt;
&lt;li&gt;Start up the Wireshark packet sniffer&lt;/li&gt;
&lt;li&gt;Enter the following URL into your browser &lt;a href=&#34;http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file3.html&#34;&gt;http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file3.html&lt;/a&gt; Your browser should display the rather lengthy US Bill of Rights.&lt;/li&gt;
&lt;li&gt;Stop Wireshark packet capture, and enter “http” in the display-filter-specification window, so that only captured HTTP messages will be displayed.&lt;/li&gt;
&lt;li&gt;(Note: If you are unable to run Wireshark on a live network connection, you can use the http-ethereal-trace-3 packet trace to answer the questions below; see footnote 1. This trace file was gathered while performing the steps above on one of the author’s computers.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the packet-listing window, you should see your HTTP GET message, followed by a multiple-packet TCP response to your HTTP GET request. This multiple-packet response deserves a bit of explanation. Recall from Section 2.2 (see Figure 2.9 in the text) that the HTTP response message consists of a status line, followed by header lines, followed by a blank line, followed by the entity body. In the case of our HTTP GET, the  entity body in the response is the entire requested HTML file. In our case here, the HTML file is rather long, and at 4500 bytes is too large to fit in one TCP packet. The single HTTP response message is thus broken into several pieces by TCP, with each piece being contained within a separate TCP segment (see Figure 1.24 in the text). In recent versions of Wireshark, Wireshark indicates each TCP segment as a separate packet, and the fact that the single HTTP response was fragmented across multiple TCP packets is indicated by the “TCP segment of a reassembled PDU” in the Info column of the Wireshark display. Earlier versions of Wireshark used the “Continuation” phrase to indicated that the entire content of an HTTP message was broken across multiple TCP segments.. We stress here that there is no “Continuation” message in HTTP!&lt;/p&gt;
&lt;p&gt;Answer the following questions:&lt;/p&gt;
&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;How many HTTP GET request messages did your browser send? Which packet number in the trace contains the GET message for the Bill or Rights?&lt;/li&gt;
&lt;li&gt;Which packet number in the trace contains the status code and phrase associated with the response to the HTTP GET request?&lt;/li&gt;
&lt;li&gt;What is the status code and phrase in the response?&lt;/li&gt;
&lt;li&gt;How many data-containing TCP segments were needed to carry the single HTTP response and the text of the Bill of Rights?&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;html-documents-with-embedded-objects&#34;&gt;HTML Documents with Embedded Objects&lt;/h4&gt;
&lt;p&gt;Now that we’ve seen how Wireshark displays the captured packet traffic for large HTML files, we can look at what happens when your browser downloads a file with embedded objects, i.e., a file that includes other objects (in the example below, image files) that are stored on another server(s).&lt;/p&gt;
&lt;p&gt;Do the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Start up your web browser, and make sure your browser’s cache is cleared, as discussed above.&lt;/li&gt;
&lt;li&gt;Start up the Wireshark packet sniffer&lt;/li&gt;
&lt;li&gt;Enter the following URL into your browser &lt;a href=&#34;http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file4.html&#34;&gt;http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file4.html&lt;/a&gt; Your browser should display a short HTML file with two images. These two images are referenced in the base HTML file. That is, the images themselves are not contained in the HTML; instead the URLs for the images are contained in the downloaded HTML file. As discussed in the textbook, your browser will have to retrieve these logos from the indicated web sites. Our publisher’s logo is retrieved from the gaia.cs.umass.edu web site. The image of the cover for our 5th edition (one of our favorite covers) is stored at the caite.cs.umass.edu server. (These are two different web servers inside cs.umass.edu).&lt;/li&gt;
&lt;li&gt;Stop Wireshark packet capture, and enter “http” in the display-filter-specification window, so that only captured HTTP messages will be displayed.&lt;/li&gt;
&lt;li&gt;(Note: If you are unable to run Wireshark on a live network connection, you can use the http-ethereal-trace-4 packet trace to answer the questions below; see footnote 1. This trace file was gathered while performing the steps above on one of the author’s computers.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Answer the following questions:&lt;/p&gt;
&lt;ol start=&#34;16&#34;&gt;
&lt;li&gt;How many HTTP GET request messages did your browser send? To which Internet addresses were these GET requests sent?&lt;/li&gt;
&lt;li&gt;Can you tell whether your browser downloaded the two images serially, or whether they were downloaded from the two web sites in parallel? Explain.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;http-authentication&#34;&gt;HTTP Authentication&lt;/h4&gt;
&lt;p&gt;Finally, let’s try visiting a web site that is password-protected and examine the sequence of HTTP message exchanged for such a site. The URL &lt;a href=&#34;http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wireshark-file5.html&#34;&gt;http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wireshark-file5.html&lt;/a&gt; is password protected. The username is “wireshark-students” (without the quotes), and the password is “network” (again, without the quotes). So let’s access this “secure” password-protected site. Do the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Make sure your browser’s cache is cleared, as discussed above, and close down your browser. Then, start up your browser&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Start up the Wireshark packet sniffer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Enter the following URL into your browser &lt;a href=&#34;http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wiresharkfile5.html&#34;&gt;http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wiresharkfile5.html&lt;/a&gt; Type the requested user name and password into the pop up box.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stop Wireshark packet capture, and enter “http” in the display-filter-specification window, so that only captured HTTP messages will be displayed later in the packet-listing window.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(Note: If you are unable to run Wireshark on a live network connection, you can use the http-ethereal-trace-5 packet trace to answer the questions below; see footnote 2. This trace file was gathered while performing the steps above on one of the author’s computers.)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now let’s examine the Wireshark output. You might want to first read up on HTTP authentication by reviewing the easy-to-read material on “HTTP Access Authentication Framework” at &lt;a href=&#34;http://frontier.userland.com/stories/storyReader$2159&#34;&gt;http://frontier.userland.com/stories/storyReader$2159&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Answer the following questions:&lt;/p&gt;
&lt;ol start=&#34;18&#34;&gt;
&lt;li&gt;What is the server’s response (status code and phrase) in response to the initial HTTP GET message from your browser?&lt;/li&gt;
&lt;li&gt;When your browser’s sends the HTTP GET message for the second time, what new field is included in the HTTP GET message?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The username (wireshark-students) and password (network) that you entered are encoded in the string of characters (d2lyZXNoYXJrLXN0dWRlbnRzOm5ldHdvcms=) following  the “Authorization: Basic” header in the client’s HTTP GET message. While it may appear that your username and password are encrypted, they are simply encoded in a format known as Base64 format. The username and password are not encrypted! To see this, go to &lt;a href=&#34;http://www.motobit.com/util/base64-decoder-encoder.asp&#34;&gt;http://www.motobit.com/util/base64-decoder-encoder.asp&lt;/a&gt; and enter the base64-encoded string d2lyZXNoYXJrLXN0dWRlbnRz and decode. Voila! You have translated from Base64 encoding to ASCII encoding, and thus should see your username! To view the password, enter the remainder of the string Om5ldHdvcms= and press decode. Since anyone can download a tool like Wireshark and sniff packets (not just their own) passing by their network adaptor, and anyone can translate from Base64 to ASCII (you just did it!), it should be clear to you that simple passwords on WWW sites are not secure unless additional measures are taken.&lt;/p&gt;
&lt;p&gt;Fear not! As we will see in Chapter 8, there are ways to make WWW access more secure. However, we’ll clearly need something that goes beyond the basic HTTP authentication framework!&lt;/p&gt;
&lt;h2 id=&#34;wireshark-lab-dns&#34;&gt;Wireshark Lab: DNS&lt;/h2&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html?tab=contents&#34;&gt;Computer Networking: A Top-Down Approach, 6th Edition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gaia.cs.umass.edu/kurose_ross/wireshark.htm&#34;&gt;&lt;strong&gt;Wireshark Labs&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Computer Networks and the Internet</title>
      <link>http://www.yezheng.pro/post/specialization/systems/computer-networking/computer-networks-1/</link>
      <pubDate>Fri, 05 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>http://www.yezheng.pro/post/specialization/systems/computer-networking/computer-networks-1/</guid>
      
        <description>&lt;h2 id=&#34;what-is-the-internet&#34;&gt;What Is the Internet?&lt;/h2&gt;
&lt;h4 id=&#34;a-nuts-and-bolts-description&#34;&gt;A Nuts-and-Bolts Description&lt;/h4&gt;
&lt;p&gt;设备：称为&lt;strong&gt;主机（host）&lt;strong&gt;或&lt;/strong&gt;端系统（end system）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;端系统通过**通信链路（communication link）&lt;strong&gt;和&lt;/strong&gt;分组交换机（packet switch）**连接到一起。&lt;/p&gt;
&lt;p&gt;通信链路的物理媒体包含：电缆、铜线、光纤和无线电频谱。&lt;/p&gt;
&lt;p&gt;端系统向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节，形成的信息包称为&lt;strong&gt;分组（packet）&lt;/strong&gt;，分组到目的端系统被装配成初始数据。&lt;/p&gt;
&lt;p&gt;分组交换机：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**路由器（router）**通常用于网络核心中&lt;/li&gt;
&lt;li&gt;**链路层交换机（link-layer swtich）**通常用于接入网中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;端系统通过**因特网服务提供商（Internet Service Provider, ISP）**接入因特网。每个ISP自身就是一个由多台分组交换机和多段通信链路组成的网络。因特网就是将端系统互联，因此为端系统提供的ISP也必须互联起来。无论是较高层还是较低层ISP网络,它们每个都是独立管理的,运行着IP协议,遵从一定的命名和地址规则。&lt;/p&gt;
&lt;p&gt;端系统、分组交换机和其他因特网部件都要运行一系列&lt;strong&gt;协议(protocol)&lt;/strong&gt;,这些协议控制因特网中信息的接收和发送。**TCP(Transmission Control Protocol, 传输控制协议)&lt;strong&gt;和&lt;/strong&gt;IP(Intemnet Protocol,网际协议)**是因特网中两个最为重要的协议。IP协议定义了在路由器和端系统之间发送和接收的分组格式。&lt;strong&gt;因特网的主要协议统称为TCP/IP。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;a-services-description&#34;&gt;A Services Description&lt;/h4&gt;
&lt;p&gt;涉及多个相互交换数据的端系统的应用程序, 被称为&lt;strong&gt;分布式应用程序(distributed application)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;与因特网相连的端系统提供了一个&lt;strong&gt;套接字接口（socket interface）&lt;/strong&gt;,该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序交付数据的方式。&lt;/p&gt;
&lt;h4 id=&#34;what-is-a-protocol&#34;&gt;What Is a Protocol?&lt;/h4&gt;
&lt;p&gt;**协议（protocol）**定义了在两个或多个通信实体之间交换的报文的格式和顺序,以及报文发送和/或接收一条报文或其他事件所采取的动作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;掌握计算机网络领域知识的过程就是理解网络协议的构成、原理和工作方式的过程。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;the-network-edge&#34;&gt;The Network Edge&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主机 = 端系统&lt;/strong&gt;。主机有时又被进一步划分为两类：&lt;strong&gt;客户（client）&lt;strong&gt;和&lt;/strong&gt;服务器(server)&lt;/strong&gt;。今天, 大部分提供搜索结果、电子邮件、Web页面和视频的服务器都属于&lt;strong&gt;大型数据中心(data center)&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;access-networks&#34;&gt;Access Networks&lt;/h4&gt;
&lt;p&gt;接入网是指将端系统物理连接到其**边缘路由器（edge rounter）**的物理链路。边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;家庭接人:数字用户线（Digital Subscriber Line, DSL）、电缆（Cable）、光纤入户（FTTH）、拨号（很慢）和卫星&lt;/li&gt;
&lt;li&gt;企业(和家庭)接人:以太网和WiFi，以太网是用局域网（LAN）技术，WIFI是无线LAN。现在家庭通常电缆或DSL可以与无线局域网结合使用&lt;/li&gt;
&lt;li&gt;广域无线接人:3G和LTE，通过蜂窝网提供商运营的基站发送接收分组。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;physical-media&#34;&gt;Physical Media&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;双绕铜线&lt;/li&gt;
&lt;li&gt;同轴电缆&lt;/li&gt;
&lt;li&gt;光纤&lt;/li&gt;
&lt;li&gt;陆地无线电信道&lt;/li&gt;
&lt;li&gt;卫星无线电信道&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;the-network-core&#34;&gt;The Network Core&lt;/h2&gt;
&lt;h4 id=&#34;packet-switching&#34;&gt;Packet Switching&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在各种网络应用中,端系统彼此交换&lt;strong&gt;报文(message)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;报文能够包含协议设计者需要的任何东西。&lt;strong&gt;报文可以执行一种控制功能,也可以包含数据&lt;/strong&gt;, 例如电子邮件数据、JPEC图像或MP3音频文件。&lt;/li&gt;
&lt;li&gt;为了从源端系统向目的端系统发送一个报文, 源将长报文划分为较小的数据块,称之为&lt;strong&gt;分组(packet)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在源和目的地之间,每个分组都通过通信链路和**分组交换机(packet switch)**传送。(交换机主要有两类:&lt;strong&gt;路由器(router)&lt;strong&gt;和&lt;/strong&gt;链路层交换机(link-layer switch)&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;存储转发传输&#34;&gt;存储转发传输&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;多数分组交换机在链路的输人端使用**存储转发传输(store-and-forward transmission)**机制。存储转发传输是指在交换机能够开始向输出链路传输该分组的第一个比特之前,必须接收到整个分组。&lt;/li&gt;
&lt;li&gt;通过由N条速率均为R的链路组成的路径，有N-1台路由器，从源到目的地发送一个分组，端到端时延是$$N\frac{L}{R}$$&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;排队时延和分组丢失&#34;&gt;排队时延和分组丢失&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;每台分组交换机有多条链路与之相连。对于每条相连的链路,该分组交换机具有一个&lt;strong&gt;输出缓存(output buffer,也称为输出队列(output queue))&lt;/strong&gt;,它用于存储路由器准备发往那条链路的分组。该输出缓存在分组交换中起着重要的作用。&lt;/li&gt;
&lt;li&gt;除了存储转发时延以外,分组还要承受输出缓存的&lt;strong&gt;排队时延(queuing delay)&lt;/strong&gt;。这些时延是变化的,变化的程度取决于网络的拥塞程度。因为缓存空间的大小是有限的,一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。在此情况下,将出现&lt;strong&gt;分组丢失(丢包)(packet loss)&lt;/strong&gt;,到达的分组或已经排队的分组之一将被丢弃。&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;转发表和路由选择协议&#34;&gt;转发表和路由选择协议&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;在因特网中，每个端系统具有一个称为&lt;strong&gt;IP地址&lt;/strong&gt;的地址。&lt;/li&gt;
&lt;li&gt;每台路由器具有一个&lt;strong&gt;转发表(forwarding table)&lt;/strong&gt;,用于将目的地址（或目的地址的一部分）映射成为输出链路。&lt;/li&gt;
&lt;li&gt;因特网具有一些特殊的&lt;strong&gt;路由选择协议（routing protocol）&lt;/strong&gt; ，用于自动地设置这些转发表。&lt;/li&gt;
&lt;li&gt;使用Traceroute程序可以看到分组在因特网中所走的端到端路由。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;circuit-switching&#34;&gt;Circuit Switching&lt;/h4&gt;
&lt;p&gt;通过网络链路和交换机移动数据有两种基本方法:&lt;strong&gt;电路交换(circuit switching)&lt;strong&gt;和&lt;/strong&gt;分组交换(packet switching)&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;a-network-of-networks&#34;&gt;A Network of Networks&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;因为接入ISP向全球传输ISP付费,故接人ISP被认为是&lt;strong&gt;客户(customer)&lt;/strong&gt;,而全球传输ISP被认为是&lt;strong&gt;提供商(provider)&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;在任何给定的区域,可能有一个&lt;strong&gt;区域ISP(regional ISP)&lt;/strong&gt;，区域中的接人ISP与之连接。每个区域ISP则与&lt;strong&gt;第一层ISP(tier-1 ISP)连接&lt;/strong&gt;。第一层ISP类似于我们假想的全球传输ISP,尽管它不是在世界上每个城市中都存在,但它确实存在。&lt;/li&gt;
&lt;li&gt;任何ISP〔(除了第一层ISP)可以选择&lt;strong&gt;多宿(multi-home)&lt;/strong&gt;,即可以与两个或更多提供商ISP连接。例如,一个接人ISP可能与两个区域ISP多宿,既可以与两个区域ISP多宿,也可以与多个第一层ISP多宿。当一个ISP提供商出现故障，能够继续发送和接收分组。&lt;/li&gt;
&lt;li&gt;位于相同等级结构层次的邻近一对ISP能够&lt;strong&gt;对等(peer)&lt;/strong&gt;, 也就是说,能够直接将它们的网络连到一起,使它们之间的所有流量经直接连接而不是通过上游的中间ISP传输。当两个ISP对等时,通常不进行结算,即任一个ISP不向其对等付费。因特网交换点（Internet Exchange Point, IXP）多个ISP能够在这里共同对等。&lt;/li&gt;
&lt;li&gt;顶部有&lt;strong&gt;内容提供商网络（content provider network）&lt;/strong&gt;，数据中心绕过较高层ISP，直接与较低层ISP连接。&lt;/li&gt;
&lt;li&gt;今天的因特网是一个&lt;strong&gt;网络的网络&lt;/strong&gt;，其结构复杂，由十多个第一层ISP和数十万个较低层ISP组成。较低层的ISP与较高层的ISP相连,较高层ISP彼此互联。用户和内容提供商是较低层ISP的客户,较低层ISP是较高层ISP的客户。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://pic1.zhimg.com/80/v2-aeb1ce8889ea9b88cb57afbe5c49cc6c_1440w.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;delay-loss-and-throughput-in-packet-switched-networks&#34;&gt;Delay, Loss, and Throughput in Packet-Switched Networks&lt;/h2&gt;
&lt;h4 id=&#34;overview-of-delay-in-packet-switched-networks&#34;&gt;Overview of Delay in Packet-Switched Networks&lt;/h4&gt;
&lt;p&gt;当分组从一个节点(主机或路由器)沿着这条路径到后继节点(主机或路由器),该分组在沿途的冬个节点经受了几种不同类型的时延。这些时延最为重要的是&lt;strong&gt;节点处理时延(nodalprocessing delay)&lt;/strong&gt;、&lt;strong&gt;排队时延(queuing delay)&lt;/strong&gt;、&lt;strong&gt;传输时延(transmission delay)&lt;strong&gt;和&lt;/strong&gt;传播时延(propagation delay)&lt;/strong&gt;,这些时延总体累加起来是&lt;strong&gt;节点总时延(totalnodal delay)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic1.zhimg.com/80/v2-5d5e8ce120b48b8ea632f8e6564480f0_1440w.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;处理时延&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;检查分组首部和决定将该分组导向何处所需要的时间是&lt;strong&gt;处理时延&lt;/strong&gt;的一部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;排队时延&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在队列中,当分组在链路上等待传输时,它经受&lt;strong&gt;排队时延&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传输时延&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用L比特表示该分组的长度,用Rbps(即b/s)表示从路由器A到路由器B的链路传输速率。链路,速率史=10Mbps;对于100Mbps的以太网链路,速率R=100Mbps。&lt;strong&gt;传输时延是L/R&lt;/strong&gt;。这是将所有分组的比特推向链路(即传输,或者说发射)所需要的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传播时延&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一旦一个比特被推向链路,该比特需要向路由器B传播。从该链路的起点到路由器B传播所需要的时间是&lt;strong&gt;传播时延&lt;/strong&gt;。该比特以该链路的传播速率传播。该传播速率取决于该链路的物理媒体(即光纤、双绞铜线等),其速率范围是2x10~3x10m/s,这等于或略小于光速。该传播时延等于两台路由器之间的距离除以传播速率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输时延是路由器将分组推出所需要的时间，是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传播时延是一个比特从一台路由器向另一台路由器传播所需要的时间，是两台路由器之间距离的函数，而与分组长度或链路传播速率无关。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;queuing-delay-and-packet-loss&#34;&gt;Queuing Delay and Packet Loss&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;节点时延的最为复杂和有趣的成分是排队时延。&lt;/li&gt;
&lt;li&gt;与其他三项时延（即、 和 ）不同的是，排队时延对不同的分组可能是不同的&lt;/li&gt;
&lt;li&gt;令 $a$ 表示分组到达队列的平均速率（单位：分组/秒，即 $pkt/s$）；$R$是传输速率，即从队列中推出比特的速率（单位 $bps$：，即$b/s$）；假定所以分组都是由$L$比特组成的**，**则比特到达队列的平均速率是$La/R &amp;gt; 1$。假定该队列非常大，因此它基本能容纳无限数量的比特。比率$La/R$被称为**流量强度（traffic intensity）**。&lt;/li&gt;
&lt;li&gt;如果，则比特到达队列的平均速率超过从该队列传输出去的速率，该队列趋向于无限增加，并且排队时延将趋向无穷大！因此，流量工程的一条金科玉律是：&lt;strong&gt;设计系统时流量强度不能大于1&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在上述讨论中,我们已经假设队列能够容纳无穷多的分组。在现实中,一条链路前的队列只有有限的容量,尽管排队容量极大地依赖于路由器设计和成本。因为该排队容量是有限的,随着流量强度接近1,排队时延并不真正趋向无穷大。相反,到达的分组将发现一个满的队列。由于没有地方存储这个分组,路由器将&lt;strong&gt;丢弃(drop)&lt;strong&gt;该分组,即该分组将会&lt;/strong&gt;丢失(lost)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分组丢失的比例随着流量强度增加而增加&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;end-to-end-delay&#34;&gt;End-to-End Delay&lt;/h4&gt;
&lt;p&gt;假定在源主机和目的主机之间有台路由器。我们还要假设该网络此时是无拥塞的(因此排队时延是微不足道的),在每台路由器和源主机上的处理时延是$d_{proc}$。,每台路由器和源主机的输出速率是$R$ bps,每条链路的传播时延是$d_{prop}$。节点时延累加起来, 得到端到端时延:$d_{end-end}=N(d_{proc}+d_{trans}+d_{prop})$  式中，其中$L$是分组长度，$d_{trans} = L/R$&lt;/p&gt;
&lt;h4 id=&#34;throughput-in-computer-networks-计算机网络中的吞吐量&#34;&gt;Throughput in Computer Networks (计算机网络中的吞吐量)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;考虑从主机A到主机B跨越计算机网络传送一个大文件，在任何时间瞬间的&lt;strong&gt;瞬时吞吐量（instantaneous throughput）&lt;strong&gt;是主机B接收到该文件的&lt;/strong&gt;速率&lt;/strong&gt;（以计）。&lt;/li&gt;
&lt;li&gt;如果该文件由比特组成，主机B接收到所有F比特用去秒，则文件传送的**平均吞吐量（average throughout）**是&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;protocol-layers-and-their-service-models&#34;&gt;Protocol Layers and Their Service Models&lt;/h2&gt;
&lt;h4 id=&#34;layered-architecture&#34;&gt;Layered Architecture&lt;/h4&gt;
&lt;h6 id=&#34;协议分层&#34;&gt;协议分层&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;协议分层的优缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：协议分层具有概念化和结构化的优点。分层提供了一种结构化方式来讨论系统组件。模块化使更新系统组件更为容易。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：分层的一个潜在缺点是一层可能冗余较低层的功能。第二个潜在的缺点 是某层的功能可能需要仅在其他某层才出现的信息（如时间戳值），这违反了层次分离的目标。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各层的所有协议被称为协议栈(protocol stack)。&lt;/p&gt;
&lt;p&gt;五层因特网协议栈:&lt;strong&gt;物理层、链路层、网络层、运输层和应用层&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;七层ISO OSI参考模型：&lt;strong&gt;物理层、链路层、网络层、运输层、会话层、表示层和应用层&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因特网协议栈自顶向下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;应用层&lt;/p&gt;
&lt;p&gt;因特网的应用层包括许多协议，例如HTTP（Web文档请求和传送）、SMTP（电子邮件报文的传输）、FTP（两个端系统之间的文件传送）、DNS（域名系统）等。&lt;/p&gt;
&lt;p&gt;应用层协议分布在多个端的系统上，一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息的分组。应用层的信息分组称为&lt;strong&gt;报文(message)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运输层&lt;/p&gt;
&lt;p&gt;因特网的运输层在应用程序端点之间&lt;strong&gt;传送应用层报文&lt;/strong&gt;。因特网中有两个运输协议，即TCP和UDP，两个都可以运输应用层报文。&lt;/p&gt;
&lt;p&gt;TCP是面向连接的，这种服务包括了应用层报文向目的地的&lt;strong&gt;确保传递&lt;/strong&gt;和&lt;strong&gt;流量控制&lt;/strong&gt;，TCP也将长报文&lt;strong&gt;划分为短报文&lt;/strong&gt;，并提供&lt;strong&gt;拥塞控制&lt;/strong&gt;机制，因此当网络拥塞时，源地址会抑制其传输速率。&lt;/p&gt;
&lt;p&gt;UDP协议提供无连接服务，这是一种不提供不必要服务的服务，&lt;strong&gt;没有可靠性，没有流量控制，也没有拥塞控制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;运输层分组称为&lt;strong&gt;报文段(segment)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络层
网络层的分组称为 &lt;strong&gt;数据报(datagram)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因特网的网络层把数据包从一台主机移动到另一台主机。在一台源主机中的因特网运输层协议（TCP或UDP）向网络层&lt;strong&gt;递交运输层报文段和目的地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;网络层中包括&lt;strong&gt;IP协议&lt;/strong&gt;，该协议定义了数据包中的各个字段以及端系统和路由器如何作用于这些字段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链路层
因特网的网络层通过源和目的地之间的一系列路由器路由数据报。网络层依靠链路层的服务来将分组从结点(主机或路由器)移动到路径上的下一个结点。在每一个结点，网络层将数据报下，链路层沿着路径将数据报传递给下一个结点，在下一个结点，链路层将数据报上传给网络层。&lt;/p&gt;
&lt;p&gt;某些协议基于链路层提供可靠传递，从传输结点跨越一条链路到接收结点，这种可靠传输不同于TCP的可靠传输。(从一个端系统到另一个端系统)&lt;/p&gt;
&lt;p&gt;链路层分组称为 &lt;strong&gt;帧(frame)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;物理层
链路层的任务是把整个帧从一个网络元素移动到邻近的网络元素，物理层的任务则是把&lt;strong&gt;该帧中的一个个比特从一个结点移动到下一个结点&lt;/strong&gt;，这些仍是和链路相关的，但是是与链路的实际传输媒体相关的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OSI模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;表示层&lt;/p&gt;
&lt;p&gt;表示层的作用是使通信的应用程序能够解释交换数据的含义。这些服务包括数据压缩、数据加密以及数据描述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会话层&lt;/p&gt;
&lt;p&gt;会话层提供了数据交换定界和同步功能，包括了建立检查点和恢复方案的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因特网缺少了OSI模型中的两层，这两层留给应用程序开发者处理。&lt;/p&gt;
&lt;h4 id=&#34;encapsulation&#34;&gt;Encapsulation&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://pic3.zhimg.com/80/v2-9a7b7f552162bcb27dd2c4986c03568a_1440w.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;数据从发送端系统的协议栈向下，向上和向下经过中间的链路层交换机和路由器协议栈，进而向上到达接收端系统的协议栈。&lt;/p&gt;
&lt;p&gt;路由器和链路层交换机并不实现协议栈中的所有层次。链路层交换机实现了链路层和物理层，路由器实现了链路层、物理层和网络层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;封装（encapsulation）&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运输层收到&lt;strong&gt;应用层报文(application-layer message)&lt;strong&gt;并附上运输层首部信息，构成了&lt;/strong&gt;运输层报文端（transport-layer segment）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;网络层增加了如源和目的端系统地址和网络层首部信息，产生&lt;strong&gt;网络层数据报（network-layer datagram）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;链路层增加链路层首部信息并创建&lt;strong&gt;链路层帧（link-layer frame）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在每一层，一个分组都具有两种类型的字段：&lt;strong&gt;首部字段和有效载荷字段（payload field）&lt;/strong&gt;，有效符合通常来自上一层的分组。&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html?tab=contents&#34;&gt;Computer Networking: A Top-Down Approach, 6th Edition&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
  </channel>
</rss>
